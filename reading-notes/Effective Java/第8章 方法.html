<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 8 章方法"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 8 章方法 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link active" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Effective Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC2%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 创建和销毁对象"><!---->第 2 章 创建和销毁对象<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC3%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对于所有对象都通用的方法"><!---->第 3 章 对于所有对象都通用的方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类和接口"><!---->第 4 章 类和接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 泛型"><!---->第 5 章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 枚举和注解"><!---->第 6 章 枚举和注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 Lambda 和 Stream"><!---->第 7 章 Lambda 和 Stream<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 8 章方法"><!---->第 8 章方法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-49-条-检查参数的有效性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 49 条：检查参数的有效性"><!---->第 49 条：检查参数的有效性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-50-条-必要时进行保护性拷贝" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 50 条：必要时进行保护性拷贝"><!---->第 50 条：必要时进行保护性拷贝<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-51-条-谨慎设计方法签名" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 51 条：谨慎设计方法签名"><!---->第 51 条：谨慎设计方法签名<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-52-条-慎用重载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 52 条：慎用重载"><!---->第 52 条：慎用重载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-53-条-慎用可变参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 53 条：慎用可变参数"><!---->第 53 条：慎用可变参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-54-条-返回零长度的数组或者集合-而不是-null" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 54 条：返回零长度的数组或者集合，而不是 null"><!---->第 54 条：返回零长度的数组或者集合，而不是 null<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-55-条-谨慎返回-optinal" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 55 条：谨慎返回 optinal"><!---->第 55 条：谨慎返回 optinal<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-56-条-为所有导出的-api-元素编写文档注释" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 56 条：为所有导出的 API 元素编写文档注释"><!---->第 56 条：为所有导出的 API 元素编写文档注释<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章通用编程"><!---->第 9 章通用编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC10%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章异常"><!---->第 10 章异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章并发"><!---->第 11 章并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC12%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章序列化"><!---->第 12 章序列化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 8 章方法</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月16日</span><meta property="datePublished" content="2022-06-16T01:04:26.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 63 分钟</span><meta property="timeRequired" content="PT63M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 19026 字</span><meta property="wordCount" content="19026"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-49-条-检查参数的有效性" class="router-link-active router-link-exact-active toc-link level2">第 49 条：检查参数的有效性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-50-条-必要时进行保护性拷贝" class="router-link-active router-link-exact-active toc-link level2">第 50 条：必要时进行保护性拷贝</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-51-条-谨慎设计方法签名" class="router-link-active router-link-exact-active toc-link level2">第 51 条：谨慎设计方法签名</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-52-条-慎用重载" class="router-link-active router-link-exact-active toc-link level2">第 52 条：慎用重载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-53-条-慎用可变参数" class="router-link-active router-link-exact-active toc-link level2">第 53 条：慎用可变参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-54-条-返回零长度的数组或者集合-而不是-null" class="router-link-active router-link-exact-active toc-link level2">第 54 条：返回零长度的数组或者集合，而不是 null</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-55-条-谨慎返回-optinal" class="router-link-active router-link-exact-active toc-link level2">第 55 条：谨慎返回 optinal</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html#第-56-条-为所有导出的-api-元素编写文档注释" class="router-link-active router-link-exact-active toc-link level2">第 56 条：为所有导出的 API 元素编写文档注释</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-8-章方法" tabindex="-1"><a class="header-anchor" href="#第-8-章方法" aria-hidden="true">#</a> 第 8 章方法</h1><p>本章要讨论方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，如何为方法编写文档。本章大部分内容既适用于构造器，也适用于普通的方法。本章的焦点集中在可用性、健壮性和灵活性上。</p><h2 id="第-49-条-检查参数的有效性" tabindex="-1"><a class="header-anchor" href="#第-49-条-检查参数的有效性" aria-hidden="true">#</a> 第 49 条：检查参数的有效性</h2><p>大多数方法和构造器对于传递给它们的参数值都会有某些限制。例如，索引值必须是非负数，对象引用不能为 null，等等，这些都是很常见的。你应该在文档中清楚地指明这些限制，并且在方法体的开头处检查参数，以强制施加这些限制。它是“发生错误之后应该尽快检测出错误”这一普遍原则的一种特例。如果不能做到这一点，检测到错误的可能性就比较小，即使检测到错误了，也比较难以确定错误的根源。</p><p>如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常。如果这个方法没有检查它的参数，就有可能发生几种情形。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常返回，但是会悄悄地计算出错误的结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发出错误。换句话说，没有验证参数的有效性，可能导致违背失败原子性。</p><p>对于公有的和受保护的方法，要用 Javadoc 的 @throws 标签在文档中说明违反参数值限制时会抛出的异常。这样的异常通常为 IllegalArgumentException、IndexOutOfBoundsException 和 NullPointerException。一旦在文档中记录了对于方法参数的限制，并且记录了一旦违反这些限制将要抛出的异常，强加这些限制就是非常简单的事情了。下面是一个典型的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Returns a BigInteger whose value is (this mod m). This method
 * differs from the remainder method in that it always returns a
 * non-negative BigInteger.
 *
 * <span class="token keyword">@param</span> <span class="token parameter">m</span> the modulus, which must be positive
 * <span class="token keyword">@return</span> this mod m
 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">ArithmeticException</span></span> if m is less than or equal to 0
 */</span>
<span class="token keyword">public</span> <span class="token class-name">BigInteger</span> <span class="token function">mod</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">signum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">&quot;Modulus &lt;= 0: &quot;</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// ... Do the computation</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，文档注释中并没有说“如果 m 为 null，mod 就抛出 NullPointerException”，而是作为调用 m.signum() 的副产物，即使方法正是这么做的。这个异常的文档是建立在外围 BigInteger 类的类级文档注释中。类级注释运用到该类的所有公有方法中的所有参数。这样可以很好地避免分别在每个方法中给每个 NullPointerException 建立文档而引起的混乱。它可以结合 @Nullable 或者类似的注解一起使用，表示某个特殊的参数可以为 null，不过这个实践不是标准的，有多个注解可以完成这个作用。</p><p>在 Java 7 中增加的 Objects.requireNonNull 方法比较灵活且方便，因此不必再手工进行 null 检查。只要你愿意，还可以指定自己的异常详情。这个方法会返回其输入，因此可以在使用一个值的同时执行 null 检查：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Inline use of Java&#39;s null-checking facility</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>strategy<span class="token punctuation">,</span> <span class="token string">&quot;strategy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以忽略返回值，并在必要的地方，用 Objects.requireNonNull 作为独立的 null 检查。</p><p>在 Java 9 中增加了检查范围的设施：java.util.Objects。这个设施包含三个方法：checkFromIndexSize、checkFromToIndex 和 checkIndex。这个设施不像检查 null 的方法那么灵活。它不允许指定自己的异常详情，而是专门设计用于列表和数组索引的。它不处理关闭的范围（包含其两个端点）。但是如果它所做的正是你需要的，那么就是一个有用的工具。</p><p>对于未被导出的方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言来检查它们的参数，具体做法如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Private helper function for a recursive sort</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">assert</span> a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">assert</span> offset <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> offset <span class="token operator">&lt;=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> 
  <span class="token keyword">assert</span> length <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token number">1</span>ength <span class="token operator">&lt;=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> offset<span class="token punctuation">;</span>
	<span class="token comment">// ... Do the computation</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出 AssertionError。不同于一般的有效性检查，如果它们没有起到作用，本质上也不会有成本开销，除非通过将 -ea（或者- enableassertions）标记传递给 Java 解释器，来启用它们。</p><p>对于有些参数，方法本身没有用到，却被保存起来供以后使用，检验这类参数的有效性尤为重要。比如，以第 20 条中的静态工厂方法为例，它的参数为一个 int 数组，并返回该数组的 List 视图。如果这个方法的客户端要传递 null，该方法将会抛出一个 NullPointerException，因为该方法包含一个显式的条件检查（调用 Objects.requireNonNull）。如果省略了这个条件检査，它就会返回一个指向新建 List 实例的引用，一旦客户端企图使用这个引用，立即就会抛出 NullPointerException。到那时，要想找到 List 实例的来源可能就非常困难了，从而使得调试工作更加复杂。</p><p>如前所述，有些参数被方法保存起来供以后使用，构造器正是代表了这种原则的一种特例。检查构造器参数的有效性是非常重要的，这样可以避免构造出来的对象违反了这个类的约束条件。</p><p>在方法执行它的计算任务之前，应该先检查它的参数，这一规则也有例外。一个很重要的例外是，在某些情况下，有效性检查工作非常昂贵，或者根本是不切实际的，而且有效性检查已隐含在计算过程中完成。例如，以为对象列表排序的方法 Collections.sort(List) 为例，列表中的所有对象都必须是可以相互比较的。在为列表排序的过程中，列表中的每个对象将与其他某个对象进行比较。如果这些对象不能相互比较，其中的某个比较操作就会抛出 ClassCastException，这正是 sort 方法应该做的事情。因此，提前检查列表中的元素是否可以相互比较，这并没有多大意义。然而，请注意，不加选择地使用这种方法将会导致失去失败原子性。</p><p>有时候，某些计算会隐式地执行必要的有效性检查，但是如果检查不成功，就会抛出错误的异常。换句话说，由于无效的参数值而导致计算过程抛出的异常，与文档中标明这个方法将抛出的异常并不相符。在这种情况下，应该使用第 73 条中讲述的异常转换技术，将计算过程中抛出的异常转换为正确的异常。</p><p>请不要由本条目的内容得出这样的结论：对参数的任何限制都是件好事。相反，在设计方法时，应该使它们尽可能通用，并符合实际的需要。假如方法对于它能接受的所有参数值都能够完成合理的工作，对参数的限制就应该是越少越好。然而，通常情况下，有些限制对于被实现的抽象来说是固有的。</p><p>简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。养成这样的习惯是非常重要的。只要有效性检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利地得到偿还了。</p><h2 id="第-50-条-必要时进行保护性拷贝" tabindex="-1"><a class="header-anchor" href="#第-50-条-必要时进行保护性拷贝" aria-hidden="true">#</a> 第 50 条：必要时进行保护性拷贝</h2><p>Java 用起来如此舒适的一个因素在于，它是一门安全的语言。这意味着，它对于缓冲区溢出、数组越界、非法指针以及其他的内存破坏错误都自动免疫，而这些错误却困扰着诸如 C 和 C++ 这样的不安全语言。在一门安全语言中，在设计类的时候，可以确切地知道，无论系统的其他部分发生什么问题，这些类的约束都可以保持为真。对于那些“把所有内存当作一个巨大的数组来对待”的语言来说，这是不可能的。</p><p>即使在安全的语言中，如果不采取一点措施，还是无法与其他的类隔离开来。假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性地设计程序。实际上，只有当有人试图破坏系统的安全性时，才可能发生这种情形；更有可能的是，对你的 API 产生误解的程序员，所导致的各种不可预期的行为，只好由类来处理。无论是哪种情况，编写一些面对客户的不良行为时仍能保持健壮性的类，这是非常值得投入时间去做的事情。</p><p>如果没有对象的帮助，另一个类不可能修改对象的内部状态，但是对象很容易在无意识的情况下提供这种帮助。例如，以下面的类为例，它声称可以表示一段不可变的时间周期：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Broken &quot;immutable&quot; time period class</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Date</span> end<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * <span class="token keyword">@param</span> <span class="token parameter">start</span> the beginning of the period
     * <span class="token keyword">@param</span> <span class="token parameter">end</span>   the end of the period; must not precede start
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IllegalArgumentException</span></span> if start is after end
     * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">NullPointerException</span></span>     if start or end is null
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Period</span><span class="token punctuation">(</span><span class="token class-name">Date</span> start<span class="token punctuation">,</span> <span class="token class-name">Date</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">&quot; after &quot;</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... Remainder omitted</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍看之下，这个类似乎是不可变的，并且强加了约束条件：周期的起始时间（start）不能在结束时间（end）之后。然而，因为 Date 类本身是可变的，因此很容易违反这个约束条件：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Attack the internals of a Period instance</span>
<span class="token class-name">Date</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Date</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Modifies internals of p!</span>
end<span class="token punctuation">.</span><span class="token function">setYear</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Java 8 开始，修正这个问题最明显的方式是使用 Instant（或 LocalDateTime，或者 ZonedDateTime）代替 Date，因为 Instant（以及另一个 java.time 类）是不可变的。Date 已经过时了，不应该在新代码中使用。也就是说，问题依然存在：有时候，还是需要在 API 和内部表达式中使用可变的值类型，本条目中讨论的方法正适用于这些情况。</p><p>为了保护 Period 实例的内部信息避免受到这种攻击，对于构造器的每个可变参数进行保护性拷贝是必要的，并且使用备份对象作为 Period 实例的组件，而不使用原始的对象：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Repaired constructor - makes defensive copies of parameters</span>
<span class="token keyword">public</span> <span class="token class-name">Period</span><span class="token punctuation">(</span><span class="token class-name">Date</span> start<span class="token punctuation">,</span> <span class="token class-name">Date</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">&quot; after &quot;</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用了新的构造器之后，上述的攻击对于 Period 实例不再有效。注意，保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。虽然这样做看起来有点不太自然，却是必要的。这样做可以避免在“危险阶段“期间从另一个线程改变类的参数，这里的危险阶段是指从检查参数开始，直到拷贝参数之间的时间段。在计算机安全社区中，这被称作 Time-Of-Check/Time-Of-Use 或者 TOCTOU 攻击。</p><p>同时也请注意，我们没有用 Date 的 clone 方法来进行保护性拷贝。因为 Date 是非 final 的，不能保证 clone 方法一定返回类为 java.util. Date 的对象：它有可能返回专门出于恶意的目的而设计的不可信子类的实例。例如，这样的子类可以在每个实例被创建的时候，把指向该实例的引用记录到一个私有的静态列表中，并且允许攻击者访问这个列表。这将使得攻击者可以自由地控制所有的实例。为了阻止这种攻击，对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Second attack on the internals of a Period instance</span>
<span class="token class-name">Date</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Date</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Period</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Modifies internals of p!</span>
p<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setYear</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了防御这第二种攻击，只需修改这两个访问方法，使它返回可变内部域的保护性拷贝：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Repaired accessors - make defensive copies of internal fields</span>
<span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">Date</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>采用了新的构造器和新的访问方法之后，Period 真正是不可变的了。不管程序员是多么恶意，或者多么不合格，都绝对不会违反“周期的起始时间不能晚于结束时间”这个约束条件。确实如此，因为除了 Period 类自身之外，其他任何类都无法访问 Period 实例中的任何一个可变域。这些域被真正封装在对象的内部。</p><p>访问方法与构造器不同，它们在进行保护性拷贝的时候允许使用 clone 方法。之所以如此，是因为我们知道，Period 内部的 Date 对象的类型是 java.util.Date，而不可能是其他某个潜在的不可信子类。也就是说，基于第 13 条中所阐述的原因，一般情况下，最好使用构造器或者静态工厂。</p><p>参数的保护性拷贝并不仅仅针对不可变类。每当编写方法或者构造器时，如果它允许客户提供的对象进入到内部数据结构中，则有必要考虑一下，客户提供的对象是否有可能是可变的。如果是，就要考虑你的类是否能够容忍对象进入数据结构之后发生变化。如果答案是否定的，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。例如，如果你正在考虑使用由客户提供的对象引用作为内部 Set 实例的元素，或者作为内部 Map 实例的键（key），就应该意识到，如果这个对象在插入之后再被修改，Set 或者 Map 的约束条件就会遭到破坏。</p><p>在内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样的道理。不管类是否为不可变的，在把一个指向内部可变组件的引用返回给客户端之前，也应该加倍认真地考虑。解决方案是，应该返回保护性拷贝。记住长度非零的数组总是可变的。因此，在把内部数组返回给客户端之前，总要进行保护性拷贝。另一种解决方案是，给客户端返回该数组的不可变视图。</p><p>可以肯定地说，上述的真正启示在于，只要有可能都应该使用不可变的对象作为对象内部的组件，这样就不必再为保护性拷贝操心。在前面的 Period 例子中，使用了 Instant（或 LocalDateTime，或者 ZonedDateTime），除非使用 Java 8 之前的版本。如果使用的是较早的版本，一种选择是保存 Date.getTime() 返回的 long 基本类型，而不是使用 Date 对象引用。</p><p>保护性拷贝可能会带来相关的性能损失，这种说法并不总是正确的。如果类信任它的调用者不会修改内部的组件，可能因为类及其客户端都是同一个包的双方，那么不进行保护必拷贝也是可以的。在这种情况下，类的文档中就必须清楚地说明，调用者绝不能修改受到影响的参数或者返回值。</p><p>即使跨越包的作用范围，也并不总是适合在将可变参数整合到对象中之前，对它进行保护性拷贝。有一些方法和构造器的调用，要求参数所引用的对象必须有个显式的交接过程。当客户端调用这样的方法时，它承诺以后不再直接修改该对象。如果方法或者构造器期望接管一个由客户端提供的可变对象，它就必须在文档中明确地指明这一点。</p><p>如果类所包含的方法或者构造器的调用需要移交对象的控制权，这个类就无法让自身抵御恶意的客户端。只有当类和它的客户端之间有着互相的信任，或者破坏类的约束条件不会伤害到除了客户端之外的其他对象时，这种类才是可以接受的。后一种情形的例子是包装类模式。根据包装类的本质特征，客户端只需在对象被包装之后直接访问它，就可以破坏包装类的约束条件，但是，这么做往往只会伤害到客户端自己。</p><p>简而言之，如果一个类包含有从客户端得到或者返回到客户端的可变组件，这个类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。</p><h2 id="第-51-条-谨慎设计方法签名" tabindex="-1"><a class="header-anchor" href="#第-51-条-谨慎设计方法签名" aria-hidden="true">#</a> 第 51 条：谨慎设计方法签名</h2><p>本条目是若干 API 设计技巧的总结，它们都还不足以单独开设一个条目。综合来说，这些设计技巧将有助于使你的 API 更易于学习和使用，并且比较不容易出错。</p><p>谨慎地选择方法的名称。方法的名称应该始终遵循标准的命名习惯。首要目标应该是选择易于理解的，并且与同一个包中的其他名称风格一致的名称。第二个目标应该是选择与大众认可的名称（如果存在的话）相一致的名称。如果还有疑问，请参考 Java 类库的 API。尽管 Java 类库的 API 中也有大量不一致的地方，考虑到这些 Java 类库的规模和范围，这是不可避免的，但它们还是得到了相当程度的认可。</p><p>不要过于追求提供便利的方法。每个方法都应该尽其所能。方法太多会使类难以学习、使用、文档化、测试和维护。对于接口而言，这无疑是正确的，方法太多会使接口实现者和接口用户的工作变得复杂起来。对于类和接口所支持的每个动作，都提供一个功能齐全的方法。只有当一项操作被经常用到的时候，才考虑为它提供快捷方式。如果不能确定，最好不要提供快捷方式。</p><p>避免过长的参数列表。目标是四个参数或者更少。大多数程序员都无法记住更长的参数列表。如果你编写的许多方法都超过了这个限制，你的 API 就不太便于使用，除非用户不停地参考它的文档。现代的 IDE 通过智能提示会有所帮助，但最好还是使用简短的参数列表。相同类型的长参数序列格外有害。API 的用户不仅无法记住参数的顺序，而且，当他们不小心弄错了参数顺序时，程序仍然可以编译和运行，只不过这些程序不会按照作者的意图进行工作。</p><p>有三种技巧可以缩短过长的参数列表。第一种是把一个方法分解成多个方法，每个方法只需要这些参数的一个子集。如果不小心，这样做会导致方法过多。但是通过提升它们的正交性，还可以减少方法的数目。例如，考虑 java.util.List 接口。它并没有提供在子列表中查找元素的第一个索引和最后一个索引的方法，这两个方法都需要三个参数。相反，它提供了 subList 方法，这个方法带有两个参数，并返回子列表的一个视图。这个方法可以与 indexOf 或者 lastIndexOf 方法结合起来，获得期望的功能，而这两个方法都分别只有一个参数。而且，subList 方法也可以与其他任何“针对 List 实例进行操作”的方法结合起来，在子列表上执行任意的计算。这样得到的 API 就有很高的功能 - 权重比。</p><p>缩短长参数列表的第二种技巧是创建辅助类，用来保存参数的分组。这些辅助类一般为静态成员类。如果一个频繁出现的参数序列可以被看作是代表了某个独特的实体，则建议使用这种方法。例如，假设你正在编写一个表示纸牌游戏的类，你会发现经常要传递一个双参数的序列来表示纸牌的点数和花色。如果增加辅助类来表示一张纸牌，并且把每个参数序列都换成这个辅助类的单个参数，那么这个纸牌游戏类的 API 以及它的内部表示都可能会得到改进。</p><p>结合了前两种技巧特征的第三种技巧是，从对象构建到方法调用都釆用 Builder 模式。如果方法带有多个参数，尤其是当它们中有些是可选的时候，最好定义一个对象来表示所有参数，并允许客户端在这个对象上进行多次&quot;setter”调用，每次调用都设置一个参数，或者设置一个较小的相关的集合。一旦设置了需要的参数，客户端就调用对象的“执行“方法，它对参数进行最终的有效性检查，并执行实际的计算。</p><p>对于参数类型，要优先使用接口而不是类。只要有适当的接口可用来定义参数，就优先使用这个接口，而不是使用实现该接口的类。例如，没有理由在编写方法时使用 HashMap 类来作为输入，相反应当使用 Map 接口作为参数。这使你可以传入一个 Hashtable、HashMap、TreeMap、TreeMap 的子映射表，或者任何有待于将来编写的 Map 实现。如果使用的是类而不是接口，则限制了客户端只能传入特定的实现，如果碰巧输入的数据是以其他的形式存在，就会导致不必要的、可能非常昂贵的拷贝操作。</p><p>对于 boolean 参数，要优先使用两个元素的枚举类型。它使代码更易于阅读和编写，尤其是当你在使用支持自动完成功能的 IDE 时。它也使以后更易于添加其他的选项。例如，你可能会有一个 Thermometer 类型，它带有一个静态工厂方法，而这个静态工厂方法的签名需要带有这个枚举的值：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">TemperatureScale</span> <span class="token punctuation">{</span>
    FAHRENHEIT<span class="token punctuation">,</span> CELSIUS
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Thermometer.newInstance(TemperatureScale.CELSIUS) 不仅比 Thermometer.newInstance(true) 更有用，而且你还可以在未来的发行版本中将 KELVIN 添加到 TemperatureScale 中，无须为 Thermometer 添加新的静态工厂。你还可以将温度范围的依赖重构到枚举常量的方法中。例如，每个范围常量都可以有一个方法，它带有一个 double 值，并将它规格化成摄氏度。</p><h2 id="第-52-条-慎用重载" tabindex="-1"><a class="header-anchor" href="#第-52-条-慎用重载" aria-hidden="true">#</a> 第 52 条：慎用重载</h2><p>下面这个程序的意图是好的，它试图根据一个集合是 Set、List，还是其他的集合类型，来对它进行分类：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Broken! - what does this program print?</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionClassifier</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Set&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;List&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Unknown Collection&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> collections <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">:</span> collections<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">classify</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能期望这个程序会打印出 Set，紧接着是 List，以及 Unknown Collection，但实际上不是这样。它打印了三次 Unknown Collection。为什么会这样呢？因为 classify 方法被重载了，而要调用哪个重载方法是在编译时做出决定的。对于 for 循环中的全部三次迭代，参数的编译时类型都是相同的：Collection&lt;?&gt;。每次迭代的运行时类型都是不同的，但这并不影响对重载方法的选择。因为该参数的编译时类型为 Collection&lt;?&gt;，所以，唯一合适的重载方法是 classify(Collection&lt;?&gt;)，在循环的每次迭代中，都会调用这个重载方法。</p><p>这个程序的行为有悖常理，因为对于重载方法的选择是静态的，而对于被覆盖的方法的选择则是动态的。选择被覆盖的方法的正确版本是在运行时进行的，选择的依据是被调用方法所在对象的运行时类型。这里重新说明一下，当一个子类包含的方法声明与其祖先类中的方法声明具有同样的签名时，方法就被覆盖了。如果实例方法在子类中被覆盖了，并且这个方法是在该子类的实例上被调用的，那么子类中的覆盖方法将会执行，而不管该子类实例的编译时类型到底是什么。为了进行更具体的说明，以下面的程序为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Wine</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;wine&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SparklingWine</span> <span class="token keyword">extends</span> <span class="token class-name">Wine</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;sparkling wine&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Champagne</span> <span class="token keyword">extends</span> <span class="token class-name">Wine</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Champagne&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Overriding</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Wine</span><span class="token punctuation">&gt;</span></span> wineList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Wine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SparklingWine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Champagne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Wine</span> wine <span class="token operator">:</span> wineList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>wine<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>name 方法是在类 Wine 中被声明的，但是在类 SparklingWine 和 Champagne 中被覆盖。正如你所预期的那样，这个程序打印出 wine、sparkling wine 和 champagne，尽管在循环的每次迭代中，实例的编译时类型都为 Wine。当调用被覆盖的方法时，对象的编译时类型不会影响到哪个方法将被执行；“最为具体的“那个覆盖版本总是会得到执行。这与重载的情形相比，对象的运行时类型并不影响“哪个重载版本将被执行”；选择工作是在编译时进行的，完全基于参数的编译时类型。</p><p>在 CollectionClassifier 示例中，该程序的意图是：期望编译器根据参数的运行时类型自动将调用分发给适当的重载方法，以此来识别出参数的类型，就好像 Wine 的例子中的 name 方法所做的那样。方法重载机制完全没有提供这样的功能。假设需要有个静态方法，这个程序的最佳修正方案是，用单个方法来替换这三个重载的 classify 方法，并在这个方法中做一个显式的 instanceof 测试：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">classify</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> c <span class="token keyword">instanceof</span> <span class="token class-name">Set</span> <span class="token operator">?</span> <span class="token string">&quot;Set&quot;</span> <span class="token operator">:</span> c <span class="token keyword">instanceof</span> <span class="token class-name">List</span> <span class="token operator">?</span> <span class="token string">&quot;List&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;Unknown Collection&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为覆盖机制是标准规范，而重载机制是例外，所以，覆盖机制满足了人们对于方法调用行为的期望。正如 CollectionClassifier 例子所示，重载机制很容易使这些期望落空。如果编写出来的代码的行为可能使程序员感到困惑，那么它就是很糟糕的实践。对于 API 来说尤其如此。如果 API 的普通用户根本不知道“对于一组给定的参数，其中的哪个重载方法将会被调用”，那么使用这样的 API 就很可能导致错误。这些错误要等到运行时发生了怪异的行为之后才会显现出来，导致许多程序员无法诊断出这样的错误。因此，应该避免胡乱地使用重载机制。</p><p>到底是什么造成胡乱使用重载机制呢？这个问题仍有争议。安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，除第 53 条中所述的情形之外，保守的策略是根本不要重载它。如果你遵守这些限制，程序员永远也不会陷入“对于任何一组实际的参数，哪个重载方法才是适用的”这样的疑问中。这项限制并不麻烦，因为你始终可以给方法起不同的名称，而不使用重载机制。</p><p>例如，以 ObjectOutputStream 类为例。对于每个基本类型，以及几种引用类型，它的 write 方法都有一种变形。这些变形方法并不是重载 write 方法，而是具有诸如 writeBoolean(boolean)、writelnt(int) 和 writeLong(long) 这样的签名。与重载方案相比较，这种命名模式带来的好处是，可以提供相应名称的读方法，比如 readBoolean()、readln() 和 readLong()。实际上，ObjectInputStream 类正是提供了这样的读方法。</p><p>对于构造器，你没有选择使用不同名称的机会；一个类的多个构造器总是重载的。在许多情况下，可以选择导出静态工厂，而不是构造器。对于构造器，还不用担心重载和覆盖的相互影响，因为构造器不可能被覆盖。或许你有可能导出多个具有相同参数数目的构造器，所以有必要了解一下如何安全地做到这一点。</p><p>如果对于“任何一组给定的实际参数将应用于哪个重载方法上”始终非常清楚，那么导出多个具有相同参数数目的重载方法就不可能使程序员感到混淆。对于每一对重载方法，至少有一个对应的参数在两个重载方法中具有“根本不同”的类型，就属于这种不会感到混淆的情形了。如果显然不可能把一种类型的实例转换为另一种类型，这两种类型就是根本不同的。在这种情况下，一组给定的实际参数应用于哪个重载方法上就完全由参数的运行时类型来决定，不可能受到其编译时类型的影响，所以主要的混淆根源就消除了。例如，ArrayList 有一个构造器带一个 int 参数，另一个构造器带一个 Collection 参数。难以想象在任何情况下，这两个构造器被调用时哪一个会产生混淆。</p><p>在 Java 5 发行版本之前，所有的基本类型都根本不同于所有的引用类型，但是当自动装箱出现之后，就不再如此了，它会导致真正的麻烦。以下面这个程序为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SetList</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，程序将 -3 至 2 之间的整数添加到了排好序的集合和列表中，然后在集合和列表中都进行 3 次相同的 remove 调用。如果像大多数人一样，希望程序从集合和列表中去除非整数值（0、1 和 2），并打印出 [-3, -2, -1] [-3, -2, -1]。事实上，程序从集合中去除了非整数，还从列表中去除了奇数值，打印出 [-3, -2, -1] [-2, 0, 2]。我们将这种行为称之为混乱，已是保守的说法。</p><p>实际发生的情况是：set.remove(i) 调用选择重载方法 remove(E)，这里的 E 是集合的元素类型，将 i 从 int 自动装箱到 Integer 中。这是你所期待的行为，因此程序不会从集合中去除正值。另一方面，list.remove(i) 调用选择重载方法 remove(int i)，它从列表的指定位置上去除元素。如果从列表 [-3, -2, -1, 0, 1, 2] 开始，去除第零个元素，接着去除第一个、第二个，得到的是 [-2, 0, 2]，这个秘密被揭开了。为了解决这个问题，要将 list.remove 的参数转换成 Integer，迫使选择正确的重载方法。另一种方法是调用 Integer.valueOf(i)，并将结果传给 list.remove。这两种方法都如我们所料，打印出 [-3, -2, -1] [-3, -2, -1]：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// or remove(Integer.valueOf(i))</span>
  list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前一个范例中所示的混乱行为在这里也出现了，因为 List&lt;E&gt; 接口有两个重载的 remove 方法：remove(E) 和 remove(int)。当它在 Java 5 发行版本中被泛型化之前，List 接口有一个 remove(Object) 而不是 remove(E)，相应的参数类型：Object 和 int，则根本不同。但是自从有了泛型和自动装箱之后，这两种参数类型就不再根本不同了。换句话说，Java 语言中添加了泛型和自动装箱之后，破坏了 List 接口。幸运的是，Java 类库中几乎再没有 API 受到同样的破坏，但是这种情形清楚地说明了，自动装箱和泛型成了 Java 语言的组成部分之后，谨慎重载显得更加重要了。</p><p>在 Java 8 中增加了 lambda 和方法引用之后，进一步增加了重载造成混淆的可能。比如，以下面这两个代码片段为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Thread 构造器调用和 submit 方法调用看起来很相似，但前者会进行编译，而后者不会。参数都是一样的（System.out::println），构造器和方法都有一个带有 Runnable 的重载。这里发生了什么呢？令人感到意外的是：submit 方法有一个带有 Callable&lt;T&gt; 的重载，而 Thread 构造器则没有。也许你会认为这应该没什么区别，因为所有的 println 重载都返回 void，因此这个方法引用或许不会是一个 Callable。这种想法是完美的，但重载方案的算法却不是这么做的。也许同样令人感到惊奇的是，如果 println 方法也没有被重载，submit 方法调用则是合法的。这是被引用的方法（println）的重载，与被调用方法（submit）的结合，阻止了重载方案算法按你预期的方式完成。</p><p>从技术的角度来看，问题在于，System.out::println 是一个不精确的方法引用，而且“某些包含隐式类型 lambda 表达式或者不精确方法引用的参数表达式会被可用性测试忽略，因为它们的含义要到选择好目标类型之后才能确定“。如果你不理解这段话的意思也没关系，这是针对编译器作者而言的。重点是在同一个参数位置，重载带有不同函数接口的方法或者构造器会造成混淆。因此，不要在相同的参数位置调用带有不同函数接口的方法。按照本条目的说法，不同的函数接口并非根本不同。如果传入命令行参数：-XIint:overloads，Java 编译器会对这种有问题的重载发出警告。</p><p>数组类型和 Object 之外的类截然不同。数组类型和 Serializable 与 Cloneable 之外的接口也截然不同。如果两个类都不是对方的后代，这两个独特的类就是不相关的。例如，String 和 Throwable 就是不相关的。任何对象都不可能是两个不相关的类的实例，因此不相关的类也是根本不同的。</p><p>还有其他一些“类型对”的例子也是不能相互转换的，但是，一旦超出了上述这些简单的情形，大多数程序员要想搞清楚“一组实际的参数应用于哪个重载方法上”就会非常困难。确定选择哪个重载方法的规则是非常复杂的，这些规则在每个发行版本中都变得越来越复杂。很少有程序员能够理解其中的所有微妙之处。</p><p>有时候，尤其在更新现有类的时候，可能会被迫违反本条目的指导原则。例如，自从 Java 4 发行版本以来，String 类就已经有一个 contentEquals(StringBuffer) 方法。在 Java 5 发行版本中，新增了一个称作 CharSequence 的接口，用来为 StringBuffer、StringBuilder、String、CharBuffer 以及其他类似的类型提供公共接口。在 Java 平台中增加 CharSequence 的同时，String 也配备了重载的 contentEquals 方法，即 contentEquals(CharSequence) 方法。</p><p>尽管这样的重载显然违反了本条目的指导原则，但是只要当这两个重载方法在同样的参数上被调用时，它们执行的是相同的功能，重载就不会带来危害。程序员可能并不知道哪个重载函数会被调用，但只要这两个方法返回相同的结果就行。确保这种行为的标准做法是，让更具体化的重载方法把调用转发给更一般化的重载方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Ensuring that 2 methods have identical behavior by forwarding</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contentEquals</span><span class="token punctuation">(</span><span class="token class-name">StringBuffer</span> sb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">contentEquals</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span><span class="token punctuation">)</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 Java 平台类库很大程度上遵循了本条目中的建议，但是也有诸多的类违背了。例如，String 类导出两个重载的静态工厂方法：valueOf(char []) 和 valueOf(Object)，当这两个方法被传递了同样的对象引用时，它们所做的事情完全不同。没有正当的理由可以解释这一点，它应该被看作是一种反常行为，有可能会造成真正的混淆。</p><p>简而言之，“能够重载方法”并不意味着就“应该重载方法”。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。在某些情况下，特别是涉及构造器的时候，要遵循这条建议也许是不可能的。在这种情况下，至少应该避免这样的情形：同一组参数只需经过类型转换就可以被传递给不同的重载方法。如果不能避免这种情形，例如，因为正在改造一个现有的类以实现新的接口，就应该保证：当传递同样的参数时，所有重载方法的行为必须一致。如果不能做到这一点，程序员就很难有效地使用被重载的方法或者构造器，同时也不能理解它为什么不能正常地工作。</p><h2 id="第-53-条-慎用可变参数" tabindex="-1"><a class="header-anchor" href="#第-53-条-慎用可变参数" aria-hidden="true">#</a> 第 53 条：慎用可变参数</h2><p>可变参数方法一般称作 variable arity method（可匹配不同长度的变量的方法），它接受 0 个或者多个指定类型的参数。可变参数机制首先会创建一个数组，数组的大小为在调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。</p><p>例如，下面就是一个可变参数方法，带有 int 参数的一个序列，并返回它们的总和。正如你所期望的，sum(1, 2, 3) 的值为 6，sum() 的值为 0：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Simple use of varargs</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	sum <span class="token operator">+=</span> arg<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有时候，必须编写需要一个或者多个某种类型参数的方法，而不是需要 0 个或者多个。例如，假设想要编写一个函数来计算多个参数的最小值。如果客户端没有传递参数，那么这个函数的定义就不太好了。你可以在运行时检查数组长度：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The WRONG way to use varargs to pass one or more arguments!</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token number">1</span>ength <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Too few arguments&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> min <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      min <span class="token operator">=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种解决方案有几个问题。其中最严重的问题是，如果客户端调用这个方法时，并没有传递参数进去，它就会在运行时而不是编译时发生失败。另一个问题是，这段代码很不美观。你必须在 args 中包含显式的有效性检查，除非将 min 初始化为 Integer.MAX_VALUE，否则将无法使用 for-each 循环，这样的代码也不美观。</p><p>幸运的是，有一种更好的方法可以实现想要的效果。声明该方法带有两个参数，一个是指定类型的正常参数，另一个是这种类型的可变参数。这种解决方案解决了前一个示例中的所有不足：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The right way to use varargs to pass one or more arguments</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstArg<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> remainingArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> min <span class="token operator">=</span> firstArg<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> arg <span class="token operator">:</span> remaniningArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arg <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      min <span class="token operator">=</span> arg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，当你真正需要让一个方法带有不定数量的参数时，可变参数就非常有效。可变参数是为 printf 而设计的，该方法是与可变参数同时添加到 Java 平台中的，为了核心的反射机制（详见第 65 条），被改造成利用可变参数。printf 和反射机制都从可变参数中获得了极大的益处。</p><p>如你所见，当你真正需要让一个方法带有不定数量的参数时，可变参数就非常有效。可变参数是为 printf 而设计的，该方法是与可变参数同时添加到 Java 平台中的，为了核心的反射机制，被改造成利用可变参数。printf 和反射机制都从可变参数中获得了极大的益处。</p><p>在重视性能的情况下，使用可变参数机制要特别小心。每次调用可变参数方法都会导致一次数组分配和初始化。如果凭经验确定无法承受这一成本，但又需要可变参数的灵活性，还有一种模式可以让你如愿以偿。假设确定对某个方法 95% 的调用会有 3 个或者更少的参数，就声明该方法的 5 个重载，每个重载方法带有 0 至 3 个普通参数，当参数的数目超过 3 个时，就使用一个可变参数方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在你知道了，当参数的数目超过 3 个时，所有调用中只有 5% 需要创建数组。就像大多数的性能优化一样，这种方法通常不太恰当，但是一旦真正需要它时，它可就帮上大忙了。</p><p>EnumSet 类对它的静态工厂使用了这种方法，最大限度地减少创建枚举集合的成本。当时这么做是有必要的，因为枚举集合为位域提供了在性能方面有竞争力的替代方法，这是很重要的。</p><p>简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式。在使用可变参数之前，要先包含所有必要的参数，并且要关注使用可变参数所带来的性能影响。</p><h2 id="第-54-条-返回零长度的数组或者集合-而不是-null" tabindex="-1"><a class="header-anchor" href="#第-54-条-返回零长度的数组或者集合-而不是-null" aria-hidden="true">#</a> 第 54 条：返回零长度的数组或者集合，而不是 null</h2><p>像下面这样的方法并不少见：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Returns null to indicate an empty collection. Don&#39;t do this!</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cheese</span><span class="token punctuation">&gt;</span></span> cheesesInStock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@return</span> a list containing all of the cheeses in the shop.
 *    or null if no chesses are available for purchase.
 */</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cheese</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> cheesesInStock<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cheesesInStock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把没有奶酪可买的情况当作是一种特例，这是不合常理的。这样做会要求客户端中必须有额外的代码来处理 null 返回值，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cheese</span><span class="token punctuation">&gt;</span></span> cheeses <span class="token operator">=</span> shop<span class="token punctuation">.</span><span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>cheeses <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cheeses<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Cheese</span><span class="token punctuation">.</span>STILTON<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Jolly good, just the thing.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一个返回 null 而不是零长度数组或者集合的方法，几乎每次用到该方法时都需要这种曲折的处理方式。这样做很容易出错，因为编写客户端程序的程序员可能会忘记写这种专门的代码来处理 null 返回值。这样的错误也许几年都不会被注意到，因为这样的方法通常返回一个或者多个对象。返回 null 而不是零长度的容器，也会使返回该容器的方法实现代码变得更加复杂。</p><p>有时候会有人认为：null 返回值比零长度集合或者数组更好，因为它避免了分配零长度的容器所需要的开销。这种观点是站不住脚的，原因有两点。第一，在这个级别上担心性能问题是不明智的，除非分析表明这个方法正是造成性能问题的真正源头。第二，不需要分配零长度的集合或者数组，也可以返回它们。下面是返回可能的零长度集合的一段典型代码。一般情况下，这些都是必须的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//The right way to return a possibly empty collection</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cheese</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cheesesInStock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>万一有证据表示分配零长度的集合损害了程序的性能，可以通过重复返回同一个不可变的零长度集合，避免了分配的执行，因为不可变对象可以被自由共享。下面的代码正是这么做的，它使用了 Collections.emptyList 方法。如果返回的是集合，最好使用 Collections.emptySet；如果返回的是映射，最好使用 Collections.emptyMap。但是要记住，这是一个优化，并且几乎用不上。如果你认为确实需要，必须在行动前后分别测试测量性能，确保这么做确实是有帮助的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Optimization - avoids allocating empty collections</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cheese</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> cheesesInStock<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cheesesInStock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组的情形与集合的情形一样，它永远不会返回 null，而是返回零长度的数组。一般来说，应该只返回一个正确长度的数组，这个长度可以为零。注意，我们将一个零长度的数组传递给了 toArray 方法，以指明所期望的返回类型，即 Cheese []：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The right way to return a possibly empty array</span>
<span class="token keyword">public</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
	<span class="token keyword">return</span> cheesesInStock<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果确信分配零长度的数组会伤害性能，可以重复返回同一个零长度的数组，因为所有零长度的数组都是不可变的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Optimization - avoids allocating empty arrays</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_CHEESE_ARRAY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getCheeses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> cheesesInStock<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>EMPTY_CHEESE_ARRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在优化性能的版本中，我们将同一个零长度的数组传进了每一次的 toArray 调用，每当 cheesesInStock 为空时，就会从 getCheese 返回这个数组。千万不要指望通过预先分配传入 toArray 的数组来提升性能。研究表明，这样只会适得其反：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Don&#39;t do this - preallocating the array harms performance!</span>
<span class="token keyword">return</span> cheesesInStock<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cheese</span><span class="token punctuation">[</span>cheesesInStock<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简而言之，永远不要返回 null，而不返回一个零长度的数组或者集合。如果返回 null，那样会使 API 更难以使用，也更容易出错，而且没有任何性能优势。</p><h2 id="第-55-条-谨慎返回-optinal" tabindex="-1"><a class="header-anchor" href="#第-55-条-谨慎返回-optinal" aria-hidden="true">#</a> 第 55 条：谨慎返回 optinal</h2><p>在 Java 8 之前，要编写一个在特定环境下无法返回任何值的方法时，有两种方法：要么抛出异常，要么返回 null（假设返回类型是一个对象引用类型）。但这两种方法都不够完美。异常应该根据异常条件保留起来。由于创建异常时会捕捉整个堆栈轨迹，因此抛出异常的开销很高。返回 null 没有这些缺点，但它有自身的不足。如果方法返回 null，客户端就必须包含特殊的代码来处理返回 null 的可能性，除非程序员能证明不可能返回 null。如果客户端疏忽了，没有检查 null 返回值，并将 null 返回值保存在某个数据结构中，那么未来在与这个问题毫不相关的某处代码中，随时有可能发生 NullPointerException 异常。</p><p>在 Java 8 中，还有第三种方法可以编写不能返回值的方法。Optinal&lt;T&gt; 类代表的是一个不可变的容器，它可以存放单个非 null 的 T 引用，或者什么内容都没有。不包含任何内容的 optional 称为空。非空的 optional 中的值称作存在。optional 本质上是一个不可变的集合，最多只能存放一个元素。Optional&lt;T&gt; 没有实现 Collection&lt;T&gt; 接口，但原则上是可以的。</p><p>理论上能返回 T 的方法，实践中也可能无法返回，因此在某些特定的条件下，可以改为声明返回 Optional&lt;T&gt;。它允许方法返回空的结果，表明无法返回有效的结果。返回 Optional 的方法比抛出异常的方法使用起来更灵活，也更容易，并且比返回 null 的方法更不容易出错。</p><p>在第 30 条展示过下面这个方法，用来根据元素的自然顺序，计算集合中的最大值。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Returns max value in a collection - throw exception if empty</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">E</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Empty collection&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> e<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果指定的集合为空，这个方法就会抛出 IllegalArgumentException。在第 30 条中说过，更好的替代方法是返回 Optional&lt;E&gt;。下面就是修改之后的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Returns maximum value in collection as an Optional&lt;E&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> e<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，返回 optional 是很简单的事。只要用适当的静态工厂创建 optional 即可。在这个程序中，我们使用了两个 optional：Optional.empty() 返回一个空的 optional，Optional.of(value) 返回一个包含了指定非 null 值的 optional。将 null 传入 Optional.of(value) 是一个编程错误。如果这么做，该方法将会抛出 NullPointerException。Optional.ofNullable(value) 方法接受可能为 null 的值，当传入 null 值时就返回一个空的 optional。永远不要通过返回 Optional 的方法返回 null：因为它彻底违背了 optional 的本意。</p><p>Stream 的许多终止操作都返回 optional。如果重新用 stream 编写 max 方法，让 stream 的 max 操作替我们完成产生 optional 的工作（虽然还是需要传入一个显式的比较器）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Returns max val in collection as Optional&lt;E&gt; - uses stream</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">naturalOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，如何选择是返回 optional，还是返回 null，或是抛出异常呢？Optional 本质上与受检异常相类似，因为它们强迫 API 用户面对没有返回值的现实。抛出未受检的异常，或者返回 null，都允许用户忽略这种可能性，从而可能带来灾难性的后果。但是，抛出受检异常需要在客户端添加额外的样板代码。</p><p>如果方法返回 optional，客户端必须做出选择：如果该方法不能返回值时应该釆取什么动作。你可以指定一个缺省值：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using an optional to provide a chosen default value</span>
<span class="token class-name">String</span> lastWordInLexicon <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;No words...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者抛出任何适当的异常。注意此处传入的是一个异常工厂，而不是真正的异常。这避免了创建异常的开销，除非它真正抛出异常：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using an optional to throw a chosen exception</span>
<span class="token class-name">Toy</span> myToy <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>toys<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token class-name">TemperTantrumException</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你能够证明 optional 为非空，就不必指定如果 optional 为空要采取什么动作，直接从 optional 获得值即可；但是如果你的判断错了，代码就会抛出一个 NoSuchElementException：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using optional when you know there&#39;s a return value</span>
<span class="token class-name">Element</span> lastNobleGas <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Elements</span><span class="token punctuation">.</span>NOBLE_GASES<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有时候，获取缺省值的开销可能很高，除非十分必要，否则还是希望能够避免这一开销。对于这类情况，Optional 提供了一个带有 Supplier&lt;T&gt; 的方法，只在必要的时候才调用它。这个方法叫 orElseGet，但或许应该叫 orElseCompute，因为它与三个名称以 compute 开头的 Map 方法密切相关。有几个 Optional 方法可以用来处理更加特殊用例的情况：filter、map、flatMap 和 ifPresent。Java 9 又在其中新增了两个方法 or 和 ifPresentOrElse。如果上述基本方法不适用，可以查看文档寻找更高级的方法，看看它们是否能够完成你所需的任务。</p><p>万一这些方法都无法满足需求，Optional 还提供了 isPresent() 方法，它可以被当作是一个安全阀。当 optional 中包含一个值时，它返回 true；当 optional 为空时，返回 false。该方法可用于对 optional 结果执行任意的处理，但要确保正确使用。isPresent 的许多用法都可以用上述任意一种方法取代。这样得到的代码一般会更加简短、清晰，也更符合习惯用法。</p><p>例如，以下代码片段用于打印出一个进程的父进程 ID，当该进程没有父进程时打印 N/A。这里使用了在 Java 9 中引入的 ProcessHand 类：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ProcessHandle</span><span class="token punctuation">&gt;</span></span> parentProcess <span class="token operator">=</span> ph<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Parent PID: &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>parentProcess<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                     <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>parentProcess<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">&quot;N/A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码片段可以用以下的代码代替，这里使用了 Optional 的 map 函数：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Parent PID: &quot;</span> <span class="token operator">+</span> ph<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>h <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;N/A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当用 Stream 编程时，经常会遇到 Stream&lt;Optional&lt;T&gt;&gt;，为了推动进程还需要一个包含了非空 optional 中所有元素的 Stream&lt;T&gt;。如果使用的是 Java 8 版本，可以像这样弥补差距：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>streamOfOptionals
  <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">isPresent</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 9 中，Optional 还配有一个 stream() 方法。这个方法是一个适配器，如果 optional 中有一个值，它就将 Optional 变成包含一个元素的 Stream；如果 optional 为空，则其中不包含任何元素。这个方法结合 Stream 的 flatMap 方法，可以简洁地取代上述代码片段，如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>streamOfOptionals<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">stream</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是并非所有的返回类型都受益于 optional 的处理方法。容器类型包括集合、映射、Stream、数组和 optional，都不应该被包装在 Optional 中。不要返回空的 Optional&lt;List&lt;T&gt;&gt;，而应该只返回一个空的 List&lt;T&gt;。返回空的容器可以让客户端免于处理一个 optional。ProcessHandle 类确实有 arguments 方法，它返回 Optional&lt;String [] &gt;，但是应该把这个方法看作是一个不该被模仿的异常。</p><p>那么何时应该声明一个方法来返回 Optional&lt;T&gt; 而不是返回 T 呢？规则是：如果无法返回结果并且当没有返回结果时客户端必须执行特殊的处理，那么就应该声明该方法返回 Optional&lt;T&gt;。也就是说，返回 Optional&lt;T&gt; 并非不需要任何成本。</p><p>Optional 是一个必须进行分配和初始化的对象，从 optional 读取值时需要额外的开销。这使得 optional 不适用于一些注重性能的情况。一个特殊的方法是否属于此类，只能通过仔细的测量来确定才行。</p><p>返回一个包含了基本包装类型的 optional，比返回一个基本类型的开销更高，因为 optional 有两级包装，不是 0 级。因此，类库设计师认为必须为基本类型 int、long 和 double 提供类似 Optional&lt;T&gt; 的方法。这些 optional 类型为：OptionalInt、OptionalLong 和 OptionalDouble。这些包含了 Optional&lt;T&gt; 中大部分但并非全部的方法。因此，永远不应该返回基本包装类型的 optional，“小型的基本类型“（Boolean、Byte、Character、Short 和 Float）除外。</p><p>到目前为止，我们已经讨论了返回 optional，以及返回之后对它们的处理方法。之所以还没有讨论到其他可能的用途，是因为 optional 的大部分其他用途都还受到质疑。例如，永远不应该用 optional 作为映射值。如果这么做，有两种方式来表达一个键的逻辑缺失：要么这个键可以不出现在映射中，要么它可以存在，并映射到一个空的 optional。这些既增加了无谓的复杂度，并极有可能造成混淆和出错。更通俗地说，几乎永远都不适合用 optional 作为键、值，或者集合或数组中的元素。</p><p>这里留下了一个尚未解答的问题：适合将 optional 保存在实例域中吗？这个答案散发着“恶臭的气息”：它建议使用包含 optional 域的子类。不过有时候它又是有道理的。以第 2 条中的 NutritionFacts 类为例，NutritionFacts 实例中包含了许多不必要的域。你不可能给这些域中每一个可能的合并都提供一个子类。而且，这些域有基本类型，导致不方便直接描述这种缺失。NutritionFacts 最好的 API 会从 get 方法处为每个 optional 域获得一个 optional，因此将那些 optional 作为域保存在对象中的做法会变得很有意义。</p><p>与返回 optional 相关的真实的性能影响；对于注重性能的方法，最好是返回一个 null，或者抛出异常。最后，尽量不要将 optional 用作返回值以外的任何其他用途。</p><h2 id="第-56-条-为所有导出的-api-元素编写文档注释" tabindex="-1"><a class="header-anchor" href="#第-56-条-为所有导出的-api-元素编写文档注释" aria-hidden="true">#</a> 第 56 条：为所有导出的 API 元素编写文档注释</h2><p>如果要想使一个 API 真正可用，就必须为其编写文档。传统意义上的 API 文档是手工生成的，所以保持文档与代码同步是一件很烦琐的事情。Java 编程环境提供了一种被称为 Javadoc 的实用工具，从而使这项任务变得很容易。Javadoc 利用特殊格式的文档注释，根据源代码自动产生 API 文档。</p><p>虽然文档注释还没有正式成为 Java 编程语言的一部分，但它们已经构成了每个程序员都应该知道的事实 API。这些规范的内容在如何编写文档注释的网页上进行了说明。虽然这个网页在 Java 4 发行版本之后还没有进行更新，但它仍然是个很有价值的资源。在 Java 9 中新增了一个重要的文档标签：{ @index }；在 Java 8 中增加了一个文档标签：{ @implSpec }；在 Java 5 中新增了两个文档标签：{ @ literal }和 {@code }。这些标签在之前提到过的网页上已经没有了，但会在本条目中讨论到。</p><p>为了正确地编写 API 文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。如果类是可序列化的，也应该对它的序列化形式编写文档。如果没有文档注释，Javadoc 所能够做的也就是重新生成该声明，作为受影响的 API 元素的唯一文档。使用没有文档注释的 API 是非常痛苦的，也很容易出错。公有的类不能使用缺省构造器，因为无法为它们提供文档注释。为了编写出可维护的代码，还应该为那些没有被导出的类、接口、构造器、方法和域编写文档注释。</p><p>方法的文档注释应该简洁地描述出它和客户端之间的约定。除了专门为继承而设计的类中的方法之外，这个约定应该说明这个方法做了什么，而不是说明它是如何完成这项工作的。文档注释应该列举出这个方法的所有前提条件和后置条件，所谓前提条件是指为了使客户能够调用这个方法，而必须要满足的条件；所谓后置条件是指在调用成功完成之后，哪些条件必须要满足。一般情况下，前提条件是由 @throws 标签针对未受检的异常所隐含描述的；每个未受检的异常都对应一个前提违例。同样地，也可以在一些受影响的参数的 @param 标记中指定前提条件。</p><p>除了前提条件和后置条件之外，每个方法还应该在文档中描述它的副作用。所谓副作用是指系统状态中可以观察到的变化，它不是为了获得后置条件而明确要求的变化。例如，如果方法启动了后台线程，文档中就应该说明这一点。</p><p>为了完整地描述方法的约定，方法的文档注释应该让每个参数都有一个 @param 标签，以及一个 @return 标签（除非这个方法的返回类型为 void），以及对于该方法抛出的每个异常，无论是受检的还是未受检的都应有一个 @throws 标签。如果 @return 标签中的文本与方法的描述一致，就允许省略，具体取决于你所遵循的编码标准。</p><p>按照惯例，跟在 @param 标签或者 @return 标签后面的文字应该是一个名词短语，描述了这个参数或者返回值所表示的值。在极少数情况下，也会用算术表达式来代替名词短语，详情请参考 BigInteger 的例子。跟在 @throws 标签之后的文字应该包含单词&quot;if”（如果），紧接着是一个名词短语，它描述了这个异常将在什么样的条件下抛出。按照惯例，@param、@return 或者 @throws 标签后面的短语或者子句都不用句点来结束。下面这个简短的文档注释演示了所有这些习惯做法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Returns the element at the specified position in this list.
 *
 * <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This method is <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">&gt;</span></span>not<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span> guaranteed to run in constant
 * time. In some implementations it may run in time proportional
 * to the element position.
 *
 * <span class="token keyword">@param</span>  <span class="token parameter">index</span> index of element to return; must be
 *         non-negative and less than the size of this list
 * <span class="token keyword">@return</span> the element at the specified position in this list
 * <span class="token keyword">@throws</span> <span class="token reference"><span class="token class-name">IndexOutOfBoundsException</span></span> if the index is out of range
 *         (<span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token punctuation">}</span>)
 */</span>
<span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，这份文档注释中使用了 HTML 标签（&lt;p &gt; 和 &lt;i&gt;）。Javadoc 工具会把文档注释翻译成 HTML，文档注释中包含的任意 HTML 元素都会出现在结果 HTML 文档中。有时程序员还会把 HTML 表格嵌入到它们的文档注释中，但是这种做法并不多见。</p><p>还要注意，@throws 子句的代码片段中到处使用了 Javadoc 的 { @code } 标签。它有两个作用：造成该代码片段以 code font（代码字体）呈现，并限制 HTML 标记和嵌套的 Javadoc 标签在代码片段中进行处理。后一种属性正是允许我们在代码片段中使用小于号（&lt;），虽然它是一个 HTML 元字符。为了将一个多行的代码示例包含在文档注释中，要使用包在 HTML 的 &lt;pre&gt; 标签里面的 Javadoc 标签 { @code }。换句话说，是先在多行的代码示例前使用字符 &lt;pre&gt;{ @code，然后代码后面加上 }&lt;/pre&gt;。这样就可以在代码中保留换行，不需要对 HTML 元字符进行转义，但 @ 符号并非如此，如果代码使用了注释就必须进行转义。</p><p>最后，要注意这个文档注释中用到了词语&quot;this list”。按惯例，当&quot;this” 一词被用在实例方法的文档注释中时，它应该始终是指方法调用所在的对象。</p><p>如第 15 条所述，在专门为了继承设计类时，必须在文档中注释它的自用模式，便于程序员了解覆盖其方法的语义。这些自用模式应该利用 Java 8 中增加的 @implSpec 标签进行文档注释。回顾一下，普通的文档注释是描述方法及其客户端之间的约定；相反，@implSpec 注释则是描述方法及其子类之间的约定，如果子类继承了该方法，或者通过 super 调用了方法，则允许子类依赖实现行为。下面是具体的用法范例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Returns true if this collection is empty.
 *
 * <span class="token keyword">@implSpec</span> 
 * This implementation returns <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span></span></span><span class="token punctuation">}</span>.
 *
 * <span class="token keyword">@return</span> true if this collection is empty
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Java 9 开始，Javadoc 工具仍然忽略 @implSpec 标签，除非传入命令行参数：<code>-tag &quot;implSpec:a:Implementation Requirements:&quot;</code>。希望这一点能在后续的发行版本中得到改进。</p><p>不要忘记，为了产生包含 HTML 元字符的文档，比如小于号（＜）、大于号（&gt;）以及“与”号（&amp;），必须釆取特殊的动作。让这些字符出现在文档中的最佳办法是用 { @literal } 标签将它们包围起来，这样就限制了 HTML 标记和嵌套的 Javadoc 标签的处理。除了它不以代码字体渲染文本之外，其他方面都和 { @code } 标签一样。例如，这个 Javadoc 片段：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">*</span> <span class="token class-name">A</span> geometric series converges <span class="token keyword">if</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@literal</span> <span class="token operator">|</span>r<span class="token operator">|</span> ＜ <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它产生了文档&quot;A geometric series converges if |r| ＜ 1.” { @literal } 标签也可以只是括住小于号，而不是整个不等式，所产生的文档是一样的，但是在源代码中见到的文档注释的可读性就会更差。这说明了一条通则：文档注释在源代码和产生的文档中都应该是易于阅读的。如果无法让两者都易读，产生的文档的可读性要优先于源代码的可读性。</p><p>每个文档注释的第一句话（如下所示）成了该注释所在元素的概要描述。例如，本条目之前的文档注释中的概要描述为“返回这个列表中指定位置上的元素”。概要描述必须独立地描述目标元素的功能。为了避免混淆，同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述。特别要注意重载的情形，在这种情况下，往往很自然地在描述中使用同样的第一句话（但在文档注释中这是不可接受的）。</p><p>注意所期待的概要描述中是否包括句点，因为句点会过早地终止这个描述。例如，一个以&quot;A college degree, such as B.S., M.S. or Ph.D.”开头的文档注释，会产生这样的概要描述：”A college degree, such as B.S, M.S.“问题在于，概要描述会在后面紧接着的空格、跳格或者行终结符的第一个句点处（或者在第一个块标签处）结束。此处，缩写&quot;M.S.”中的第二个句点后面紧接着用了一个空格。最好的解决方法是，用 { @literal } 标签将讨厌的句点以及所有关联的文本都包起来，使得源代码中的句点后面不再是空格：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * A college degree, such as B.S., <span class="token punctuation">{</span><span class="token keyword">@literal</span> M.S.<span class="token punctuation">}</span> or Ph.D.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Degree</span> <span class="token punctuation">{</span> 
  <span class="token comment">//... </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说概要描述是文档注释中的第一个句子，这似乎有点误导人。规范指出，概要描述很少是个完整的句子。对于方法和构造器而言，概要描述应该是个完整的动词短语（包含任何对象），它描述了该方法所执行的动作。例如：</p><ul><li>ArrayList(int initialCapacity)：用指定的初始容量构造一个空的列表。</li><li>Collection.size()：返回该集合中元素的数目。</li></ul><p>如这些示例所示，使用第三人称时态比使用第二人称更加确切。</p><p>对于类、接口和域，概要描述应该是一个名词短语，它描述了该类或者接口的实例，或者域本身所代表的事物。例如：</p><ul><li>Instant：时间轴上的一个瞬时点。</li><li>Math.PI：非常接近于 PI（圆周长度与直径的比值）的 double 值。</li></ul><p>Java 9 在 Javadoc 生成的 HTML 中添加了客户端索引。这个索引简化了在大型 API 文档集中进行搜索的任务，它采用了页面右上角的搜索框的形式。当你在搜索框中输入时，会出现一个下拉菜单，上面显示出相匹配的页面。像类、方法和域这类 API 元素，会被自动索引。有时候，会想要索引一些对于 API 比较重要的其他条件。为此，增加了 { @index } 标签。如果要索引文档注释中出现的某一个条件，只需将它包在这个标签中即可，如下面这个代码片段所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">*</span> <span class="token class-name">This</span> method complies <span class="token keyword">with</span> <span class="token namespace">the</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@index</span> <span class="token class-name">IEEE</span> <span class="token number">754</span><span class="token punctuation">)</span> standard<span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要特别小心文档注释中的泛型、枚举和注解。当为泛型或者方法编写文档时，确保要在文档中说明所有的类型参数。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * An object that maps keys to values. A map cannot contain
 * duplicate keys; each key can map to at most one value.
 *
 * (Remainder omitted)
 *
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">&lt;</span>K<span class="token punctuation">&gt;</span></span> the type of keys maintained by this map
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">&lt;</span>V<span class="token punctuation">&gt;</span></span> the type of mapped values
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span> 
  <span class="token comment">//... </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当为枚举类型编写文档时，要确保在文档中说明常量，以及类型，还有任何公有的方法。注意，如果文档注释很简短，可以将整个注释放在一行上：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
* An instrument section of a symphony orchestra.
*/</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">OrchestraSection</span> <span class="token punctuation">{</span>
  <span class="token doc-comment comment">/** Woodwinds, such as flute, clarinet, and oboe. */</span>
  WOODWIND<span class="token punctuation">,</span>

  <span class="token doc-comment comment">/** Brass instruments, such as french horn and trumpet. */</span>
  BRASS<span class="token punctuation">,</span>

  <span class="token doc-comment comment">/** Percussion instruments, such as timpani and cymbals. */</span>
  PERCUSSION<span class="token punctuation">,</span>

  <span class="token doc-comment comment">/** Stringed instruments, such as violin and cello. */</span>
  STRING<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为注解类型编写文档时，要确保在文档中说明所有成员，以及类型本身。带有名词短语的文档成员，就当成域一样对待。对于该类型的概要描述，要使用一个动词短语，说明当程序元素具有这种类型的注解时它表示什么意思：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Indicates that the annotated method is a test method that
 * must throw the designated exception to pass.
 */</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTest</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * The exception that the annotated test method must throw
     * in order to pass. (The test is permitted to throw any
     * subtype of the type described by this class object.)
     */</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>包级私有的文档注释应该放在一个称作 package-info.java 的文件中。除了这些注释之外，package-info.java 中还必须包含包声明，还可以包含这个声明中的注解。同样地，如果选择使用模块系统，应该将模块级的注释放在 module-info.java 文件中。</p><p>API 有两个特征在文档中经常被忽视，即线程安全性和可序列化性。类或者静态方法是否线程安全，应该在文档中对它的线程安全级别进行说明。如果类是可序列化的，就应该在文档中说明它的序列化形式。</p><p>Javadoc 具有“继承”方法注释的能力。如果一个 API 元素没有文档注释，Javadoc 将会搜索最为适用的文档注释，接口的文档注释将优先于超类的文档注释。也可以利用 { @inheritDoc } 标签从超类型中继承文档注释的部分内容。这意味着类还可以重用它所实现的接口的文档注释，而不需要拷贝这些注释。这项机制有可能减轻维护多个几乎相同的文档注释的负担，但使用它需要一些小技巧，并具有一些局限性。</p><p>关于文档注释有一点需要特别注意。虽然为所有导出的 API 元素提供文档注释是必要的，但是这样做并非一劳永逸。对于由多个相互关联的类组成的复杂 API，通常有必要用一个外部文档来描述该 API 的总体结构，对文档注释进行补充。如果有这样的文档，相关的类或者包文档注释就应该包含一个对这个外部文档的链接。</p><p>Javadoc 遵循本条目提出的许多建议进行自动检测。在 Java 7 中，需要用命令行参数 -Xdoclint 实现这种行为。在 Java 8 和 Java 9 中，检测功能是默认打开的。像 checkstyle 这样的 IDE 插件，会进一步根据这些建议完成检测。通过运行一个 HTML 有效性检查器来检测由 Javadoc 产生的 HTML 文件，也可以降低文档注释中出错的可能性。这样可以检测出 HTML 标签的许多不正确用法，以及应该被转义的 HTML 元字符。Internet 上有几个这类检查器可供下载，并且也可以利用 W3C Markup Validation Service 来进行在线检验 HTML。在验证产生的 HTML 时，要记住，从 Java 9 开始，Javadoc 都可以生成 HTML 5，以及 HTML 4.01，虽然它默认是生成 HTML 4.01。如果要用 Javadoc 生成 HTML 5，可以使用命令行参数 -html5。</p><p>本条目中所述的内容涵盖了基本的惯例。虽然到目前为止，已经过去了 15 年，编写文档注解最权威的指导仍然是《How to Write Doc Comments》。</p><p>如果遵循本条目中的指导，生成的文档应该能够清晰地描述你的 API。但唯一确定了解的方式，就是去阅读由 Javadoc 工具生成的网页。每一个将被其他人使用的 API 都值得你这么做。正如测试程序几乎无疑会导致对代码做出修改一样，阅读文档一般至少也会导致对文档注释进行些许的修改。</p><p>简而言之，要为 API 编写文档，文档注释是最好、最有效的途径。对于所有可导出的 API 元素来说，使用文档注释应该被看作是强制性的要求。要采用一致的风格来遵循标准的约定。记住，在文档注释内部出现任何 HTML 标签都是允许的，但是 HTML 元字符必须要经过转义。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Effective Java/第8章 方法.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link prev" aria-label="第 7 章 Lambda 和 Stream"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 7 章 Lambda 和 Stream</div></a><a href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html" class="nav-link next" aria-label="第 9 章通用编程"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 9 章通用编程<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
