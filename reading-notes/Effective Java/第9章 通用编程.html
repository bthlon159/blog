<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 9 章通用编程"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 9 章通用编程 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link active" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Effective Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC2%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 创建和销毁对象"><!---->第 2 章 创建和销毁对象<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC3%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对于所有对象都通用的方法"><!---->第 3 章 对于所有对象都通用的方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类和接口"><!---->第 4 章 类和接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 泛型"><!---->第 5 章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 枚举和注解"><!---->第 6 章 枚举和注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 Lambda 和 Stream"><!---->第 7 章 Lambda 和 Stream<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章方法"><!---->第 8 章方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 9 章通用编程"><!---->第 9 章通用编程<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-57-条-将局部变量的作用域最小化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 57 条：将局部变量的作用域最小化"><!---->第 57 条：将局部变量的作用域最小化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-58-条-for-each-循环优先于传统的-for-循环" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 58 条：for-each 循环优先于传统的 for 循环"><!---->第 58 条：for-each 循环优先于传统的 for 循环<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-59-条-了解和使用类库" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 59 条：了解和使用类库"><!---->第 59 条：了解和使用类库<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-60-条-如果需要精确的答案-请避免使用-float-和-double" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 60 条：如果需要精确的答案，请避免使用 float 和 double"><!---->第 60 条：如果需要精确的答案，请避免使用 float 和 double<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-61-条-基本类型优先于装箱基本类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 61 条：基本类型优先于装箱基本类型"><!---->第 61 条：基本类型优先于装箱基本类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-62-条-如果其他类型更适合-则尽量避免使用字符串" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 62 条：如果其他类型更适合，则尽量避免使用字符串"><!---->第 62 条：如果其他类型更适合，则尽量避免使用字符串<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-63-条-了解字符串连接的性能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 63 条：了解字符串连接的性能"><!---->第 63 条：了解字符串连接的性能<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-64-条-通过接口引用对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 64 条：通过接口引用对象"><!---->第 64 条：通过接口引用对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-65-条-接口优先于反射机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 65 条：接口优先于反射机制"><!---->第 65 条：接口优先于反射机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-66-条-谨慎地使用本地方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 66 条：谨慎地使用本地方法"><!---->第 66 条：谨慎地使用本地方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-67-条-谨慎地进行优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 67 条：谨慎地进行优化"><!---->第 67 条：谨慎地进行优化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-68-条-遵守普遍接受的命名惯例" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 68 条：遵守普遍接受的命名惯例"><!---->第 68 条：遵守普遍接受的命名惯例<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC10%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章异常"><!---->第 10 章异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章并发"><!---->第 11 章并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC12%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章序列化"><!---->第 12 章序列化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 9 章通用编程</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月16日</span><meta property="datePublished" content="2022-06-16T01:04:26.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 62 分钟</span><meta property="timeRequired" content="PT62M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 18479 字</span><meta property="wordCount" content="18479"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-57-条-将局部变量的作用域最小化" class="router-link-active router-link-exact-active toc-link level2">第 57 条：将局部变量的作用域最小化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-58-条-for-each-循环优先于传统的-for-循环" class="router-link-active router-link-exact-active toc-link level2">第 58 条：for-each 循环优先于传统的 for 循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-59-条-了解和使用类库" class="router-link-active router-link-exact-active toc-link level2">第 59 条：了解和使用类库</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-60-条-如果需要精确的答案-请避免使用-float-和-double" class="router-link-active router-link-exact-active toc-link level2">第 60 条：如果需要精确的答案，请避免使用 float 和 double</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-61-条-基本类型优先于装箱基本类型" class="router-link-active router-link-exact-active toc-link level2">第 61 条：基本类型优先于装箱基本类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-62-条-如果其他类型更适合-则尽量避免使用字符串" class="router-link-active router-link-exact-active toc-link level2">第 62 条：如果其他类型更适合，则尽量避免使用字符串</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-63-条-了解字符串连接的性能" class="router-link-active router-link-exact-active toc-link level2">第 63 条：了解字符串连接的性能</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-64-条-通过接口引用对象" class="router-link-active router-link-exact-active toc-link level2">第 64 条：通过接口引用对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-65-条-接口优先于反射机制" class="router-link-active router-link-exact-active toc-link level2">第 65 条：接口优先于反射机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-66-条-谨慎地使用本地方法" class="router-link-active router-link-exact-active toc-link level2">第 66 条：谨慎地使用本地方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-67-条-谨慎地进行优化" class="router-link-active router-link-exact-active toc-link level2">第 67 条：谨慎地进行优化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html#第-68-条-遵守普遍接受的命名惯例" class="router-link-active router-link-exact-active toc-link level2">第 68 条：遵守普遍接受的命名惯例</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-9-章通用编程" tabindex="-1"><a class="header-anchor" href="#第-9-章通用编程" aria-hidden="true">#</a> 第 9 章通用编程</h1><p>本章主要讨论 Java 语言的细枝末节，包含局部变量的处理、控制结构、类库的用法、各种数据类型的用法，以及两种不是由语言本身提供的机制（反射机制和本地方法）的用法。最后讨论了优化和命名惯例。</p><h2 id="第-57-条-将局部变量的作用域最小化" tabindex="-1"><a class="header-anchor" href="#第-57-条-将局部变量的作用域最小化" aria-hidden="true">#</a> 第 57 条：将局部变量的作用域最小化</h2><p>本条目与第 15 条本质上是类似的。将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p><p>较早的编程语言（如 C 语言）要求局部变量必须在代码块的开头进行声明，出于习惯，有些程序员目前还是继续这样做。这个习惯应该改正。在此提醒，Java 允许你在任何可以出现语句的地方声明变量。</p><p>要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明。如果变量在使用之前进行声明，这只会造成混乱——对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等要用到该变量时，读者可能已经记不起该变量的类型或者初始值了。</p><p>过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得过晚。局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束处。如果变量是在“使用它的块”之外被声明的，当程序退出该块之后，该变量仍是可见的。如果变量在它的目标使用区域之前或者之后被意外地使用，后果将可能是灾难性的。</p><p>几乎每一个局部变量的声明都应该包含一个初始化表达式。如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与 try-catch 语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检异常，该变量就必须在 try 块的内部被初始化。如果变量的值必须在 try 块的外部用到，它就必须在 try 块之前被声明，但是在 try 块之前，它还不能被“有意义地初始化”。</p><p>循环中提供了特殊的机会来将变量的作用域最小化。无论是传统的 for 循环，还是 for-each 形式的 for 循环，都允许声明循环变量，它们的作用域被限定在正好需要的范围之内（这个范围包括循环体，以及循环体之前的初始化、测试、更新部分）。因此，如果在循环终止之后不再需要循环变量的内容，for 循环就优先于 while 循环。</p><p>例如，下面是一种遍历集合的首选做法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Preferred idiom for iterating over a collection or array</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Element</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... Do Something with e</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要访问迭代器，可能要调用它的 remove 方法，首选做法是利用传统的 for 循环代替 for-each 循环：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Idiom for iterating when you need the iterator</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Element</span> e <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ... Do something with e and i</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了弄清楚为什么这些 for 循环比 while 循环更好，请参考下面的代码片段，它包含两个 while 循环，以及一个 Bug：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
  <span class="token function">doSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i2 <span class="token operator">=</span> c2<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// BUG!</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">doSomethingElse</span><span class="token punctuation">(</span>i2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个循环中包含一个“剪切 - 粘贴”错误：本来是要初始化一个新的循环变量 i2，却使用了旧的循环变量 i，遗憾的是，这时 i 仍然还在有效范围之内。结果代码仍然可以通过编译，运行的时候也不会抛出异常，但是它所做的事情却是错误的。第二个循环并没有在 c2 上迭代，而是立即终止，造成 c2 为空的假象。因为这个程序的错误是悄然发生的，所以可能在很长时间内都不会被发现。</p><p>如果类似的“剪切 - 粘贴”错误发生在前面任何一种 for 循环中，结果代码根本就不能通过编译。在第二个循环开始之前，第一个循环的元素（或者迭代器）变量已经不在它的作用域范围之内了。下面就是一个传统 for 循环的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Element</span> e <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ... Do something with e and i</span>
<span class="token punctuation">}</span>

<span class="token comment">// Compile-time error - cannot find symbol i</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i2 <span class="token operator">=</span> c2<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Element</span> e2 <span class="token operator">=</span> i2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ... Do something with e2 and i2</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用 for 循环，犯这种“剪切 - 粘贴”错误的可能性就会大大降低，因为通常没有必要在两个循环中使用不同的变量名。循环是完全独立的，所以重用元素（或者迭代器）变量的名称不会有任何危害。实际上，这也是很流行的做法。</p><p>使用 for 循环与使用 while 循环相比还有另外一个优势：更简短，从而增强了可读性。下面是另外一种对局部变量的作用域进行最小化的循环做法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token function">expensiveComputation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... Do something with i;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于这种做法要关注的重点是，它具有两个循环变量 i 和 n，二者具有完全相同的作用域。第二个变量 n 被用来保存第一个变量的极限值，从而避免在每次迭代中执行冗余计算。通常，如果循环测试中涉及方法调用，并且可以保证在每次迭代中都会返回同样的结果，就应该使用这种做法。</p><p>最后一种“将局部变量的作用域最小化”的方法是使方法小而集中。如果把两个操作合并到同一个方法中，与其中一个操作相关的局部变量就有可能会出现在执行另一个操作的代码范围之内。为了防止这种情况发生，只需将这个方法分成两个：每个操作用一个方法来完成。</p><h2 id="第-58-条-for-each-循环优先于传统的-for-循环" tabindex="-1"><a class="header-anchor" href="#第-58-条-for-each-循环优先于传统的-for-循环" aria-hidden="true">#</a> 第 58 条：for-each 循环优先于传统的 for 循环</h2><p>如第 45 条所述，有些任务最好结合 Stream 来完成，有些最好结合迭代完成。下面是用一个传统的 for 循环遍历集合的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Not the best way to iterate over a collection!</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Element</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Element</span> e <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//... Do something with e</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用传统的 for 循环遍历数组的做法如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Not the best way to iterate over an array!</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... Do something with a[i]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些做法都比 while 循环更好，但是它们并不完美。迭代器和索引变量都会造成一些混乱——而你需要的只是元素而已。而且，它们也代表着出错的可能。迭代器在每个循环中出现三次，索引变量在每个循环中出现四次，其中有两次让你很容易出错。一旦出错，就无法保证编译器能够发现错误。最后一点是，这两个循环是截然不同的，容器的类型转移了不必要的注意力，并且为修改该类型增加了一些困难。</p><p>for-each 循环（官方称之为“增强的 for 语句”）解决了所有问题。通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。这种模式同样适用于集合和数组，同时简化了将容器的实现类型从一种转换到另一种的过程：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The preferred idiom for iterating over collections and arrays</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Element</span> e <span class="token operator">:</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... Do someth!ng with e</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当见到冒号（:）时，可以把它读作“在……里面”。因此上面的循环可以读作“对于元素 elements 中的每一个元素 e”。注意，利用 for-each 循环不会有性能损失，甚至用于数组也一样：它们产生的代码本质上与手工编写的一样。</p><p>对于嵌套式迭代，for-each 循环相对于传统 for 循环的优势还会更加明显。下面就是人们在试图对两个集合进行嵌套迭代时经常会犯的错误：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Can you spot the bug?</span>
<span class="token keyword">enum</span> <span class="token class-name">Suit</span> <span class="token punctuation">{</span> CLUB<span class="token punctuation">,</span> DIAMOND<span class="token punctuation">,</span> HEART<span class="token punctuation">,</span> SPADE <span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token class-name">Rank</span> <span class="token punctuation">{</span> ACE<span class="token punctuation">,</span> DEUCE<span class="token punctuation">,</span> THREE<span class="token punctuation">,</span> FOUR<span class="token punctuation">,</span> FIVE<span class="token punctuation">,</span> SIX<span class="token punctuation">,</span> SEVEN<span class="token punctuation">,</span> EIGHT<span class="token punctuation">,</span> NINE<span class="token punctuation">,</span> TEN<span class="token punctuation">,</span> JACK<span class="token punctuation">,</span> QUEEN<span class="token punctuation">,</span> KING <span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token keyword">static</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Suit</span><span class="token punctuation">&gt;</span></span> suits <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">Suit</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Rank</span><span class="token punctuation">&gt;</span></span> ranks <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token class-name">Rank</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Card</span><span class="token punctuation">&gt;</span></span> deck <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Suit</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> suits<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Rank</span><span class="token punctuation">&gt;</span></span> j <span class="token operator">=</span> ranks<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    deck<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Card</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果之前没有发现这个 Bug 也不必难过。许多专家级的程序员偶尔也会犯这样的错误。问题在于，在迭代器上对外部的集合（suits）调用了太多次 next 方法。它应该从外部的循环进行调用，以便每种花色调用一次，但它却是从内部循环调用，因此每张牌调用一次。在用完所有花色之后，循环就会抛出 NoSuchElementException 异常。</p><p>如果真的那么不幸，并且外部集合的大小是内部集合大小的几倍（可能因为它们是相同的集合），循环就会正常终止，但是不会完成你想要的工作。例如，下面就是一个考虑不周的尝试，想要打印一对骰子的所有可能的滚法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Same bug, different symptom!</span>
<span class="token keyword">enum</span> <span class="token class-name">Face</span> <span class="token punctuation">{</span> ONE<span class="token punctuation">,</span> TWO<span class="token punctuation">,</span> THREE<span class="token punctuation">,</span> FOUR<span class="token punctuation">,</span> FIVE<span class="token punctuation">,</span> SIX <span class="token punctuation">}</span>
<span class="token comment">// ...</span>
<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Face</span><span class="token punctuation">&gt;</span></span> faces <span class="token operator">=</span> <span class="token class-name">EnumSet</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span><span class="token class-name">Face</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Face</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> faces<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Face</span><span class="token punctuation">&gt;</span></span> j <span class="token operator">=</span> faces<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> j<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序不会抛出异常，而是只打印 6 个重复的词（从 &quot;ONE ONE” 到 &quot;SIX SIX”），而不是预计的那 36 种组合。</p><p>为了修正这些示例中的 Bug，必须在外部循环的作用域中添加一个变量来保存外部元素：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Fixed, but ugly - you can do better!</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Suit</span><span class="token punctuation">&gt;</span></span> i <span class="token operator">=</span> suits<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Suit</span> suit <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Rank</span><span class="token punctuation">&gt;</span></span> j <span class="token operator">=</span> ranks<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    deck<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Card</span><span class="token punctuation">(</span>suit<span class="token punctuation">,</span> j<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用的是嵌套式 for-each 循环，这个问题就会完全消失。产生的代码将如你所希望的那样简洁：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Preferred idiom for nested iteration on collections and arrays</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Suit</span> suit <span class="token operator">:</span> suits<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Rank</span> rank <span class="token operator">:</span> ranks<span class="token punctuation">)</span><span class="token punctuation">{</span>
    deck<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Card</span><span class="token punctuation">(</span>suit<span class="token punctuation">,</span> rank<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遗憾的是，有三种常见的情况无法使用 for-each 循环：</p><ul><li>解构过滤——如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的 remove 方法。使用 Java 8 中增加的 Collection 的 removeIf 方法，常常可以避免显式的遍历。</li><li>转换——如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。</li><li>平行迭代——如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进。</li></ul><p>如果你发现自己处于以上任何一种情况之下，就要使用普通的 for 循环，并且要警惕本条目中提到的陷阱。</p><p>for-each 循环不仅能遍历集合和数组，还能遍历实现 Iterable 接口的任何对象，该接口中只包含单个方法，具体如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">// Returns an iterator over the elements in this iterable </span>
  <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">1terator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不得不从头开始编写自己的 Iterator 实现，其中还是有些技巧的，但是如果编写的是表示一组元素的类型，则应该坚决考虑让它实现 Iterable 接口，甚至可以选择让它不要实现 Collection 接口。这样，你的用户就可以利用 for-each 循环遍历类型，他们会永远心怀感激的。</p><p>总而言之，与传统的 for 循环相比，for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。因此，当可以选择的时候，for-each 循环应该优先于 for 循环。</p><h2 id="第-59-条-了解和使用类库" tabindex="-1"><a class="header-anchor" href="#第-59-条-了解和使用类库" aria-hidden="true">#</a> 第 59 条：了解和使用类库</h2><p>假设你希望产生位于 0 和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写出如下所示的方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Common but deeply flawed!</span>
<span class="token keyword">static</span> <span class="token class-name">Random</span> rnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法看起来可能不错，但是却有三个缺点。第一个缺点是，如果 n 是一个比较小的 2 的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点是，如果 n 不是 2 的乘方，那么平均起来，有些数会比其他的数出现得更为频繁。如果 n 比较大，这个缺点就会非常明显。这可以通过下面的程序直观地体现出来，它会产生 100 万个经过精心指定的范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		low<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span>ow<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 random 方法工作正常，这个程序打印出来的数将接近于 100 万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于 666666。由 random 方法产生的数字有三分之二落在随机数取值范围的前半部分。</p><p>random 方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，因为会返回个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用 Math.abs，将 rnd.nextInt() 返回的值映射为一个非负整数 int。如果 nextInt() 返回 Integer.MIN_VALUE，那么 Math.abs 也会返回 Integer.MIN_VALUE，假设 n 不是 2 的乘方，那么取模操作符（%）将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。</p><p>为了编写能修正这三个缺点的 random 方法，有必要了解关于同余伪随机数生成器、数论和 2 的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作——已经有现成的成果可以为你所用。这一成果被称作 Random.nextlnt(int)。你无须关心 nextlnt(int) 的实现细节（如果你有强烈的好奇心，可以研究它的文档或者源代码）。具有算法背景的高级工程师已经花了大量的时间来设计、实现和测试这个方法，然后经过这个领域中的专家的审查，以确保它的正确性。之后，标准类库经过了 Beta 测试并正式发行，几年之间已经有成千上万的程序员在使用它。在这个方法中还没有发现过缺陷，但是，如果将来发现有缺陷，在下一个发行版本中就会修正这些缺陷。通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验。</p><p>从 Java 7 开始，就不应该再使用 Random 了。现在选择随机数生成器时，大多使用 ThreadLocalRandom。它会产生更高质量的随机数，并且速度非常快。在我的机器上，比 Random 快了 3.6 倍。对于 Fork Join Pool 和并行 Stream，则使用 SplittableRandom。</p><p>使用标准类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。</p><p>使用标准类库的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无须你做任何努力。因为许多人在使用它们，并且是当作工业标准在使用，所以提供这些标准类库的组织有强烈的动机要使它们运行得更快。这些年来，许多 Java 平台类库已经被重新编写了，有时候是重复编写，从而在性能上有了显著的提高。</p><p>使用标准类库的第四个好处是，它们会随着时间的推移而增加新的功能。如果类库中漏掉了某些功能，开发者社区就会把这些缺点公示出来，漏掉的功能就会添加到后续的发行版本中。</p><p>使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读、更易维护、更易被大多数的开发人员重用。</p><p>既然有那么多的优点，使用标准类库机制而不选择专门的实现，这显然是符合逻辑的，然而还是有相当一部分的程序员没有这样做。为什么呢？可能他们并不知道有这些类库机制的存在。在每个重要的发行版本中，都会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的。每当 Java 平台有重要的发行时，都会发布一个网页来说明新的特性。这些网页值得好好读一读。举个例子，假设想要编写一个程序，用它打印出命令行中指定的一条 URL 的内容（Linux 中 curl 命令的作用大体如此）。在 Java 9 之前，这些代码有点烦琐，但是 Java 9 在 InputStream 中增加了 transferTo 方法。下面就是利用这个新方法完成这项任务的完整程序：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// printlng the contents of a URL with transferTo, added in Java 9</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">(</span> 
  <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Inputstream</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    in<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些标准类库太庞大了，以至于不可能学完所有的文档，但是每个程序员都应该熟悉 java.lang、java.util、<a href="http://java.io" target="_blank" rel="noopener noreferrer">java.io<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 及其子包中的内容。关于其他类库的知识可以根据需要随时学习。总结类库中的机制超出了本条目的范围，几年来它们已经发展得十分庞大了。</p><p>其中有几个类库值得一提。Collections Framework（集合框架）和 Stream 类库应该成为每一位程序员基本工具箱中的一部分，同样也应该成为 java.util.concurrent 中并发机制的组成部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。</p><p>在某些情况下，一个类库工具并不能满足你的需要。你的需求越是特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准类库，但是，如果你在观察了它们在某些领域所提供的功能之后，确定它不能满足需要，你就得使用其他的实现。任何一组类库所提供的功能总是难免会有遗漏。如果你在 Java 类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中去寻找，比如 Google 优秀的开源 Guava 类库。如果在所有相应的类库中都无法找到你所需的功能，就只能自己实现这些功能了。</p><p>总而言之，不要重复发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移而不断改进。这并不是在质疑你作为一个程序员的能力。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能给予的投入。</p><h2 id="第-60-条-如果需要精确的答案-请避免使用-float-和-double" tabindex="-1"><a class="header-anchor" href="#第-60-条-如果需要精确的答案-请避免使用-float-和-double" aria-hidden="true">#</a> 第 60 条：如果需要精确的答案，请避免使用 float 和 double</h2><p>float 和 double 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。float 和 double 类型尤其不适合用于货币计算，因为要让一个 float 或者 double 精确地表示 0.1（或者 10 的任何其他负数次方值）是不可能的。</p><p>例如，假设你的口袋中有 $1.03，花掉了 42￠ 之后还剩下多少钱呢？下面这个很简单的程序片段试图回答这个问题：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1.03</span> <span class="token operator">-</span> <span class="token number">0.42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>遗憾的是，它输出的结果是 0.6100000000000001。这并不是个别的例子。假设你的口袋里有 $1，你买了 9 个垫圈，每个为 10￠。那么应该找回多少零头呢？</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1.00</span> <span class="token operator">-</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token number">0.10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据上述程序片段，你得到的是 $0.09999999999999998。</p><p>你可能会认为，只要在打印之前将结果做一下舍入就可以解决这个问题，但遗憾的是，这种做法并不总是可行的。例如，假设你的口袋里有 $1，你看到货架上有一排美味的糖果，标价分别为 10￠、20￠、30￠，等等，一直到 $1。你打算从标价为 10￠的糖果开始，每种买 1 颗，一直到不能支付货架上下一种价格的糖果为止，那么你可以买多少颗糖果？还会找回多少零头？下面是一个简单的程序，用来解决这个问题：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Broken - uses floating point for monetary calculation!</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> vold <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">double</span> funds <span class="token operator">=</span> <span class="token number">1.00</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> itemsBought <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> price <span class="token operator">=</span> <span class="token number">0.10</span><span class="token punctuation">;</span> funds <span class="token operator">&gt;=</span> price<span class="token punctuation">;</span> price <span class="token operator">+=</span> <span class="token number">0.10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    funds <span class="token operator">-=</span> price<span class="token punctuation">;</span>
    itemsBought<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>itemsBought <span class="token operator">+</span> <span class="token string">&quot; items bought.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Change: $&quot;</span> <span class="token operator">+</span> funds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果真正运行这个程序，你会发现可以支付 3 颗糖果，并且还剩下 $0.3999999999999999。这个答案是不正确的！解决这个问题的正确方法是使用 BigDecimal、int 或者 long 进行货币计算。</p><p>下面的程序是上一个程序的简单翻版，它使用 BigDecimal 类型代替 double。注意，它使用了 BigDecimal 的 String 构造器，而不是用 double 构造器。为了避免将不正确的值引入到计算中，这是必需的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> vold <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">BigDecimal</span> TEN_CENTS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">&quot;.10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> itemsBought <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token class-name">BigDecimal</span> funds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">&quot;1.00&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BigDecimal</span> price <span class="token operator">=</span> TEN_CENTS<span class="token punctuation">;</span> funds<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> price <span class="token operator">=</span> price<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>TEN_CENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    funds <span class="token operator">=</span> funds<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    itemsBought<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>itemsBought <span class="token operator">+</span> <span class="token string">&quot; items bought.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Money left over: $&quot;</span> <span class="token operator">+</span> funds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果运行这个修改过的程序，会发现可以支付 4 颗糖果，还剩下 $0.00。这才是正确的答案。</p><p>然而，使用 BigDecimal 有两个缺点：与使用基本运算类型相比，这样做很不方便，而且速度很慢。对于解决这样一个简单的问题，后一种缺点并不要紧，但是前一种缺点可能会让你很不舒服。</p><p>除了使用 BigDecimal 之外，还有一种办法是使用 int 或者 long，到底选用 int 还是 long 要取决于所涉及数值的大小，同时要自己处理十进制小数点。在这个示例中，最明显的做法是以分为单位进行计算，而不是以元为单位。下面是这个例子的简单翻版，展示了这种做法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> itemsBought <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> funds <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> funds <span class="token operator">&gt;=</span> price<span class="token punctuation">;</span> price <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    funds <span class="token operator">-=</span> price<span class="token punctuation">;</span>
    itemBought<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>itemsBought <span class="token operator">+</span> <span class="token string">&quot; items bought.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Cash left over: &quot;</span> <span class="token operator">+</span> funds <span class="token operator">+</span> <span class="token string">&quot; cents&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总而言之，对于任何需要精确答案的计算任务，请不要使用 float 或者 double。如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用 BigDecimal。使用 BigDecimal 还有一些额外的好处，它允许你完全控制舍入，每当一个操作涉及舍入的时候，你都可以从 8 种舍入模式中选择其一。如果你正通过合法强制的舍入行为进行商务计算，使用 BigDecimal 是非常方便的。如果性能非常关键，并且你又不介意自己处理十进制小数点，而且所涉及的数值又不太大，就可以使用 int 或者 long。如果数值范围没有超过 9 位十进制数字，就可以使用 int；如果不超过 18 位数字，就可以使用 long。如果数值可能超过 18 位数字，就必须使用 BigDecimal。</p><h2 id="第-61-条-基本类型优先于装箱基本类型" tabindex="-1"><a class="header-anchor" href="#第-61-条-基本类型优先于装箱基本类型" aria-hidden="true">#</a> 第 61 条：基本类型优先于装箱基本类型</h2><p>Java 有一个类型系统由两部分组成，它包含基本类型，如 int、double 和 boolean，以及引用类型，如 String 和 List。每个基本类型都有一个对应的引用类型，称作装箱基本类型。装箱基本类型中对应于 int、double 和 boolean 的分别是 Integer、Double 和 Boolean。</p><p>自动装箱和自动拆箱模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别。这两种类型之间真正是有差别的，要很清楚在使用的是哪种类型，并且要对这两种类型进行谨慎的选择，这些都非常重要。</p><p>在基本类型和装箱基本类型之间有三个主要区别。第一，基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。第二，基本类型只有函数值，而每个装箱基本类型则都有一个非函数值，除了它对应基本类型的所有函数值之外，还有个 null。最后一点区别是，基本类型通常比装箱基本类型更节省时间和空间。如果不小心，这三点区别都会让你陷入麻烦之中。</p><p>以下面这个比较器为例，它被设计用来表示 Integer 值的递增数字顺序（回想一下，比较器的 compare 方法返回的数值到底为负数、零还是正数，要取决于它的第一个参数是小于、等于还是大于它的第二个参数）。在实践中并不需要你编写这个在 Integer 中实现自然顺序的比较器，因为这是不需要比较器就可以得到的，但它展示了一个有趣的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Broken comparator - can you spot the flaw?</span>
<span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> naturalOrder <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个比较器表面看起来似乎不错，它可以通过许多测试。例如，它可以通过 Collections.sort 正确地给一个有 100 万个元素的列表进行排序，无论这个列表中是否包含重复的元素。但是这个比较器有着严重的缺陷。如果你要让自己信服，只要打印 naturalOrder.Compare(new Integer(42), new Integer(42)) 的值便可以分晓。这两个 Integer 实例都表示相同的值（42），因此这个表达式的值应该为 0，但它输出的却是 1，这表明第一个 Integer 值大于第二个。</p><p>问题出在哪呢？naturalOrder 中的第一个测试工作得很好。对表达式 i &lt; j 执行计算会导致被 i 和 j 引用的 Integer 实例被自动拆箱；也就是说，它提取了它们的基本类型值。计算动作要检查产生的第一个 int 值是否小于第二个。但是假设答案是否定的。下一个测试就是执行计算表达式 i == j，它在两个对象引用上执行同一性比较。如果 i 和 j 引用表示同一个 int 值的不同的 Integer 实例，这个比较操作就会返回 false，比较器会错误地返回 1，表示第一个 Integer 值大于第二个。对装箱基本类型运用 == 操作符几乎总是错误的。</p><p>事实上，如果需要用比较器描述一个类型的自然顺序，只要调用 Comparator.naturalOrder() 即可，如果自己编写比较器，则应该使用比较器构造方法，或者在基本类型上使用静态比较方法。也就是说，修正这个问题的做法是添加两个局部变量，来保存对应于装箱 Integer 参数的基本类型 int 值，并在这些变量上执行所有的比较操作。这样可以避免大量的同一性比较：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> naturalOrder <span class="token operator">=</span> <span class="token punctuation">(</span>iBoxed<span class="token punctuation">,</span> jBoxed<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Auto-unboxing</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> iBoxed<span class="token punctuation">,</span> j <span class="token operator">=</span> jBoxed<span class="token punctuation">;</span> 
  <span class="token keyword">return</span> i <span class="token operator">&lt;</span> j <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span>；
<span class="token punctuation">}</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，看看下面这个小程序：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Unbelievable</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token class-name">Integer</span> i<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Unbelievable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它不会打印出 Unbelievable——但是它的行为也是很奇怪的。它在计算表达式（i == 42）的时候抛出 NullPointerException 异常。问题在于，i 是个 Integer，而不是 int，就像所有的对象引用域一样，它的初始值为 null。当程序计算表达式（i == 42）时，它会将 Integer 与 int 进行比较。几乎在任何一种情况下，当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，这种情况无一例外。如果 null 对象引用被自动拆箱，就会抛出一个 NullPointerException 异常。就如这个程序所示，它几乎可以在任何位置发生。修正这个问题很简单，声明 i 是个 int 而不是 Integer 即可。</p><p>最后，以第 6 条中的这个程序为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Hideously slow program! Can you spot the object creation?</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Long</span> sum <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量（sum）声明为是装箱基本类型 Long，而不是基本类型 long。程序编译起来没有错误或者警告，变量被反复地装箱和拆箱，导致明显的性能下降。</p><p>在本条目中所讨论的这三个程序中，问题是一样的：程序员忽略了基本类型和装箱基本类型之间的区别，并尝到了苦头。在前两个程序中，其结果是彻底的失败；在第三个程序中，则有严重的性能问题。</p><p>那么什么时候应该使用装箱基本类型呢？它们有几个合理的用处。第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更通用的特例。在参数化类型和方法中，必须使用装箱基本类型作为类型参数，因为 Java 不允许使用基本类型。例如，你不能将变量声明为 ThreadLocal&lt;int&gt; 类型，因此必须使用 ThreadLocal&lt;Integer&gt; 代替。最后，在进行反射的方法调用时，必须使用装箱基本类型。</p><p>总而言之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险。当程序用 == 操作符比较两个装箱基本类型时，它做了个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出 NullPointerException 异常。最后，当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。</p><h2 id="第-62-条-如果其他类型更适合-则尽量避免使用字符串" tabindex="-1"><a class="header-anchor" href="#第-62-条-如果其他类型更适合-则尽量避免使用字符串" aria-hidden="true">#</a> 第 62 条：如果其他类型更适合，则尽量避免使用字符串</h2><p>字符串被用来表示文本，它在这方面也确实做得很好。因为字符串很通用，并且 Java 语言也支持得很好，所以自然就会有这样一种倾向：即使在不适合使用字符串的场合，人们往往也会使用字符串。本条目就是讨论一些不应该使用字符串的情形。</p><p>字符串不适合代替其他的值类型。当一段数据从文件、网络，或者键盘设备，进入程序之后，它通常以字符串的形式存在。有一种自然的倾向是让它继续保留这种形式，但是，只有当这段数据本质上确实是文本信息时，这种想法才是合理的。如果它是数值，就应该被转换为适当的数值类型，比如 int、float 或者 BigInteger 类型。如果它是个“是 - 或 - 否”这种问题的答案，就应该被转换为 boolean 类型。如果存在适当的值类型，不管是基本类型，还是对象引用，大多应该使用这种类型；如果不存在这样的类型，就应该编写一个类型。虽然这条建议是显而易见的，但通常未能得到遵守。</p><p>字符串不适合代替枚举类型。正如第 34 条中所讨论的，枚举类型比字符串更加适合用来表示枚举类型的常量。</p><p>字符串不适合代替聚合类型。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。例如，下面这行代码来自于真实的系统一标识符的名称已经被修改了，以免发生纠纷：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Inappropriate use of string as aggregate type</span>
<span class="token class-name">String</span> compoundKey <span class="token operator">=</span> className <span class="token operator">+</span> <span class="token string">&quot;#&quot;</span>	<span class="token operator">+</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法有许多缺点。如果用来分隔域的字符也出现在某个域中，结果就会出现混乱。为了访问单独的域，必须解析该字符申，这个过程非常慢，也很烦琐，还容易出错。你无法提供 equals、toString 或者 compareTo 方法，只好被迫接受 String 提供的行为。更好的做法是，简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类。</p><p>字符串也不适合代替能力表。有时候，字符串被用于对某种功能进行授权访问。例如，考虑设计一个提供线程局部变量的机制。这个机制提供的变量在每个线程中都有自己的值。自 Java 1.2 发行版本以来，Java 类库就有提供线程局部变量的机制，但在那之前，程序员必须自己完成。几年前，面对这样的设计任务时，有些人提出了同样的设计方案：利用客户提供的字符串键对每个线程局部变量的内容进行访问授权：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Broken - inappropriate use of string as capability!</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>
    <span class="token comment">// Noninstantiable</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Sets the current thread&#39;s value for the named variable.</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">// Returns the current thread * s value for the named variable.</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法的问题在于，这些字符串键代表了一个共享的全局命名空间。要使这种方法可行，客户端提供的字符串键必须是唯一的：如果两个客户端各自决定为它们的线程局部变量使用同样的名称，它们实际上就无意中共享了这个变量，这样往往会导致两个客户端都失败，而且安全性也很差。恶意的客户端可能有意地使用与另一个客户端相同的键，以便非法地访问其他客户端的数据。</p><p>要修正这个 API 并不难，只要用一个不可伪造的键（有时被称为能力）来代替字符串即可：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>
    <span class="token comment">// Noninstantiable</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// (Capability)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token punctuation">{</span>
        <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Generates a unique, unforgeable key</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Key</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样虽然解决了基于字符串的 API 的两个问题，但是你还可以做得更好。你实际上不再需要静态方法，它们可以被代之以键（Key）中的实例方法，这样这个键就不再是键，而是线程局部变量了。此时，这个不可被实例化的顶层类也不再做任何实质性的工作，因此可以删除这个顶层类，并将嵌套类命名为 ThreadLocal：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 API 不是类型安全的，因为当你从线程局部变量得到它时，必须将值从 Object 转换成它实际的值。不可能使原始的基于 String 的 API 为类型安全的，要使基于 Key 的 API 为类型安全的也很困难，但是通过将 ThreadLocal 类泛型化，使这个 API 变成类型安全的就是很简单的事情了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>粗略地讲，这正是 java.lang.ThreadLocal 提供的 API。除了解决了基于字符串的 API 的问题之外，与前面的两个基于键的 API 相比，它还更快速、更美观。</p><p>总而言之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚合类型。</p><h2 id="第-63-条-了解字符串连接的性能" tabindex="-1"><a class="header-anchor" href="#第-63-条-了解字符串连接的性能" aria-hidden="true">#</a> 第 63 条：了解字符串连接的性能</h2><p>字符串连接操作符（+）是把多个字符串合并为一个字符串的便利途径。要想产生单独一行的输出，或者构造一个字符串来表示一个较小的、大小固定的对象，使用连接操作符是非常合适的，但是它不适合运用在大规模的场景中。为连接 n 个字符串而重复地使用字符串连接操作符，需要 n 的平方级的时间。这是由于字符串不可变而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Inappropriate use of string concatenation - Performs poorly!</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">statement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
  <span class="token class-name">String</span> result <span class="token operator">=</span>	<span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">numItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// String concatenation</span>
  	result <span class="token operator">+=</span> <span class="token function">lineForItem</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果项目的数量巨大，这个方法的执行时间就难以估算。为了获得可以接受的性能，请用 StringBuilder 代替 String，来存储构造过程中的账单声明：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">statement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">StringBuilder</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token function">numItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> LINE_WIDTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token function">numItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	b<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">lineForItem</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Java 6 以来，已经做了大量的工作使字符串连接变得更加快速，但是上述两种做法的性能差别还是很大：如果 numItems 返回 100，并且 lineForltem 返回一个固定长度为 80 个字符的字符串，在我的机器上，第二种做法比第一种做法要快 6.5 倍。因为第一种做法的开销随项目数量而呈平方级增加，项目的数量越大，性能的差别就会越明显。注意，第二种做法预先分配了一个 StringBuilder，使它大到足以容纳整个结果字符串，因此不需要自动扩展。即使使用了默认大小的 StringBuilder，它也仍然比第一种做法快 5.5 倍。</p><p>原则很简单：不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要。否则，应该使用 StringBuilder 的 append 方法。另一种做法是使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。</p><h2 id="第-64-条-通过接口引用对象" tabindex="-1"><a class="header-anchor" href="#第-64-条-通过接口引用对象" aria-hidden="true">#</a> 第 64 条：通过接口引用对象</h2><p>应该使用接口而不是类作为参数类型。更通俗来讲，应该优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。为了更具体地说明这一点，以 LinkedHashSet 的情形为例，它是 Set 接口的一个实现。在声明变量的时候应该养成这样的习惯：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Good - uses interface as type</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Son</span><span class="token punctuation">&gt;</span></span> sonSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而不是像这样的声明：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Bad - uses class as type</span>
<span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Son</span><span class="token punctuation">&gt;</span></span> sonSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果养成了用接口作为类型的习惯，程序将会更加灵活。当你决定更换实现时，所要做的就只是改变构造器中类的名称（或者使用一个不同的静态工厂）。例如，第一个声明可以被改变为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Son</span><span class="token punctuation">&gt;</span></span> sonSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>周围的所有代码都可以继续工作。周围的代码并不知道原来的实现类型，所以它们对于这种变化并不在意。</p><p>有一点值得注意：如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供同样的功能。例如，如果第一个声明周围的代码依赖于 LinkedHashSet 的同步策略，那么在声明中用 HashSet 代替 LinkedHashSet 就是不正确的，因为 HashSet 不能保证相关的迭代顺序。</p><p>为什么要改变实现类型呢？因为第二个实现提供了比第一个更好的性能，或者因为它提供了你所期待的而原来的实现缺乏的功能。比如，假设有一个域中包含了一个 HashMap 实例。如果将它改成 EnumMap，则可以提供更好的性能，并且迭代顺序与键的自然顺序一致，但是如果键的类型为枚举类型，你就只能使用 EnumMap。如果将 HashMap 改成 LinkedHashMap，则能提供可以预估的迭代顺序，以及可以与 HashMap 比拟的性能，对于键类型没有任何特殊的要求。</p><p>你可能会觉得，用变量的实现类型来声明变量，也是可以接受，因为可以同时改变声明类型和实现类型，但是不能确保修改后的程序可以编译。如果客户端代码使用了没有出现在新实现中的原始实现类型中的方法，或者客户端代码将该实例传到了需要原始实现类型的方法中，那么代码在完成这样的修改之后将不再进行编译。用接口类型声明变量要“保持诚实”。</p><p>如果没有合适的接口存在，完全可以用类而不是接口来引用对象。以值类为例，比如 String 和 BigInteger。记住，值类很少会用多个实现编写。它们经常是 final 的，并且很少有对应的接口。使用这种值类作为参数、变量、域或者返回类型是再合适不过的了。</p><p>不存在适当接口类型的第二种情形是，对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架，就应该用相关的基类（往往是抽象类）来引用这个对象，而不是用它的实现类。许多 <a href="http://java.io" target="_blank" rel="noopener noreferrer">java.io<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 类，比如 OutputStream 就属于这种情形。</p><p>不存在适当接口类型的最后一种情形是，类实现了接口但它也提供了接口中不存在的额外方法 例如 PriorityQueue 有一个没有出现在 Queue 接口中的 comparator 方法。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例，永远也不应该被用作参数类型。</p><p>以上这些例子并不全面，而只是代表了一些“适合于用类来引用对象”的情形。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活。如果没有适合的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象吧。</p><h2 id="第-65-条-接口优先于反射机制" tabindex="-1"><a class="header-anchor" href="#第-65-条-接口优先于反射机制" aria-hidden="true">#</a> 第 65 条：接口优先于反射机制</h2><p>核心反射机制，java.lang.reflect 包，提供了 “通过程序来访问任意类” 的能力。给定一个 Class 对象，可以获得 Constructor、Method 和 Field 实例，它们分别代表了该 Class 实例所表示的类的构造器、方法和域。这些对象提供了“通过程序来访问类的成员名称、域类型、方法签名等信息”的能力。</p><p>此外，Constructor、Method 和 Field 实例使你能够通过反射机制操作它们的底层对等体：通过调用 Constructor、Method 和 Field 实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的域。例如，Method.invoke 使你可以调用任何类的任何对象上的任何方法（遵从常规的安全限制）。反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在。然而，这种能力也要付出代价：</p><ul><li>损失了编译时类型检查的优势，包括异常检查。如果程序企图用反射方式调用不存在的或者不可访问的方法，在运行时它将会失败，除非釆取了特别的预防措施。</li><li>执行反射访问所需要的代码非常笨拙和冗长。编写这样的代码非常乏味，阅读起来也很困难。</li><li>性能损失。反射方法调用比普通方法调用慢了许多。具体慢了多少，这很难说，因为受到了多个因素的影响。在我的机器上，调用一个没有输入参数和 int 返回值的方法，用普通方法调用比用反射机制调用快了 11 倍。</li></ul><p>有一些复杂的应用程序需要使用反射机制。这些示例包括代码分析工具和依赖注入框架。不过最近以来，这类工具已经不再使用反射机制，因为它的缺点越来越明显。如果你怀疑自己的应用程序是否也需要反射机制，它很有可能是不需要的。</p><p>如果只是以非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处。许多程序必须用到的类在编译时是不可用的，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类。如果是这种情况，就可以用反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。</p><p>例如，下面的程序创建了一个 Set&lt;String&gt; 实例，它的类是由第一个命令行参数指定的。该程序把其余的命令行参数插入到这个集合中，然后打印该集合。不管第一个参数是什么，程序都会打印出余下的命令行参数，其中重复的参数会被消除掉。这些参数的打印顺序取决于第一个参数中指定的类。如果指定 java.util.HashSet，显然这些参数就会以随机的顺序打印出来；如果指定 java.util.TreeSet，则会按照字母顺序打印，因为 TreeSet 中的元素是排好序的。相应的代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Reflective instantiation with interface access</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">(</span>
  <span class="token comment">// Translate the class name into a Class object</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> cl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// Unchecked cast!</span>
    cl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;Class not found.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

	<span class="token comment">// Get the constructor</span>
	<span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> cons <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    cons <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;No parameterless constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Instantiate the set</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    s <span class="token operator">=</span> cons<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;Constructor not accessible&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;Class not instantiable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;Constructor threw &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span> <span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassCastException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;Class doesn&#39;t implement Set&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Exercise the set</span>
	s<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> args<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管这只是一个试验程序，但是它所演示的方法是非常强大的。这个试验程序可以很容易地变成一个通用的集合测试器，通过侵入式地操作一个或者多个集合实例，并检查是否遵守 Set 接口的约定，以此来验证指定的 Set 实现。同样地，它也可以变成一个通用的集合性能分析工具。实际上，它所演示的这种方法足以实现一个成熟的服务提供者框架。绝大多数情况下，使用反射机制时需要的也正是这种方法。</p><p>这个示例演示了反射机制的两个缺点。第一，这个例子会产生 6 个运行时异常，如果不使用反射方式的实例化，这 6 个错误都会成为编译时错误。第二，根据类名生成其实例需要 25 行冗长的代码，而调用一个构造器则可以非常简洁地只用一行代码。程序的长度可以通过捕捉 ReflectiveOperationException 异常来减少，这是在 Java 7 中引入的各种反射异常的一个超类。这两个缺点都局限于实例化对象的那部分代码。一旦对象被实例化，它与其他的 Set 实例就难以区分了。在实际的程序中，通过这种限定使用反射的方法，绝大部分代码可以不受影响。</p><p>如果试着编译这个程序，会得到一条未受检的转换警告。这条警告是合法的，因此转换 Class&lt;? extends Set&lt;String&gt;&gt; 会成功，即使具名类不是一个 Set 实现，在这种情况下，程序在实例化这个类时就会抛出一个 ClassCastException 异常。要了解禁止这种警告的最佳方法。</p><p>类对于在运行时可能不存在的其他类、方法或者域的依赖性，用反射法进行管理是合理的，但是很少使用。如果要编写一个包，并且它运行的时候就必须依赖其他某个包的多个版本，这种做法可能就非常有用。具体做法就是，在支持包所需要的最小环境下对它进行编译，通常是最老的版本，然后以反射方式访问任何更加新的类或者方法。如果企图访问的新类或者新方法在运行时不存在，为了使这种方法有效你还必须采取适当的动作。所谓适当的动作，可能包括使用某种其他可替换的办法来达到同样的目的，或者使用简化的功能进行处理。</p><p>总而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类。</p><h2 id="第-66-条-谨慎地使用本地方法" tabindex="-1"><a class="header-anchor" href="#第-66-条-谨慎地使用本地方法" aria-hidden="true">#</a> 第 66 条：谨慎地使用本地方法</h2><p>Java Native Interface（JNI）允许 Java 应用程序调用本地方法，所谓本地方法是指用本地编程语言（比如 C 或者 C++）来编写的方法。它们提供了“访问特定于平台的机制”的能力，比如访问注册表。它们还提供了访问本地遗留代码库的能力，从而可以访问遗留数据。最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。</p><p>使用本地方法来访问特定于平台的机制是合法的，但是几乎没有必要：因为随着 Java 平台的不断成熟，它提供了越来越多以前只有在宿主平台上才拥有的特性。例如，Java 9 增加的进程 API，提供了访问操作系统进程的能力。当 Java 中没有相当的类库可用时，使用本地方法来使用遗留代码库也是合法的。</p><p>使用本地方法来提高性能的做法不值得提倡。在早期的发行版本中（Java 3 发行版本之前），这样做往往是很有必要的，但是从那以后，JVM 实现变得越来越快了。对于大多数任务，现在用 Java 就可以获得与之相当的性能。举例来说，当 Java 1.1 发行版本中增加了 java.math 时，BigInteger 是在一个用 C 编写的快速多精度运算库的基础上实现的。</p><p>这个故事有一个悲伤的尾声：从那时起，BigInteger 几乎没怎么改变，但在 Java 8 中，大整数却以更快的乘积速度在发展。当时，遗留代码库的工作还在持续快速地发展中，著名的有 GNU 高精度算术运算库。对于需要真正高性能的高精度算术运算的 Java 程序员，现在通过本地方法来使用 GMP 也是无可厚非的。</p><p>使用本地方法有一些严重的缺陷。因为本地语言不是安全的，所以使用本地方法的应用程序也不再能免受内存毁坏错误的影响。因为本地语言是与平台相关的，使用本地方法的应用程序也不再是可自由移植的。使用本地方法的应用程序也更难调试。如果不小心，本地方法还可能降低性能，因为回收垃圾器不是自动的，甚至无法追踪本机内存使用情况，而且在进入和退出本地代码时，还需要相关的开销。最后一点，需要“胶合代码”的本地方法编写起来单调乏味，并且难以阅读。</p><p>总而言之，在使用本地方法之前务必三思。只有在极少数情况下需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。本地代码中只要有一个 Bug 都可能破坏整个应用程序。</p><h2 id="第-67-条-谨慎地进行优化" tabindex="-1"><a class="header-anchor" href="#第-67-条-谨慎地进行优化" aria-hidden="true">#</a> 第 67 条：谨慎地进行优化</h2><p>有三条与优化有关的格言是每个人都应该知道的：</p><blockquote><p>很多计算上的过失都被归咎于效率（没有达到必要的效率），而不是任何其他的原因——甚至包括盲目地做傻事。</p></blockquote><blockquote><p>不要去计较效率上的一些小小的得失，在 97% 的情况下，不成熟的优化才是一切问题的根源。</p></blockquote><blockquote><p>在优化方面，我们应该遵守两条规则：</p><p>规则 1：不要进行优化。</p><p>规则 2（仅针对专家）：还是不要进行优化——也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化。</p></blockquote><p>所有这些格言都比 Java 程序设计语言的出现早了 20 年。它们讲述了一个关于优化的深刻真理：优化的弊大于利，特别是不成熟的优化。在优化过程中，产生的软件可能既不快速，也不正确，而且还不容易修正。</p><p>不要为了性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。如果好的程序不够快，它的结构将使它可以得到优化。好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策集中在单个模块中，因此可以改变单个决策，而不会影响到系统的其他部分。</p><p>这并不意味着，在完成程序之前就可以忽略性能问题。实现上的问题可以通过后期的优化而得到修正，但是，遍布全局并且限制性能的结构缺陷几乎是不可能被改正的，除非重新编写系统。在系统完成之后再改变设计的某个基本方面，会破坏系统的结构，从而难以维护和改进。因此，必须在设计过程中考虑到性能问题。</p><p>要努力避免那些限制性能的设计决策。当一个系统设计完成之后，其中最难以更改的组件是那些指定了模块之间交互关系以及模块与外界交互关系的组件。在这些设计组件之中，最主要的是 API、交互层协议以及永久数据格式。这些设计组件不仅在事后难以甚至不可能改变，而且它们都有可能对系统本该达到的性能产生严重的限制。</p><p>要考虑 API 设计决策的性能后果。使公有的类型成为可变的，这可能会导致大量不必要的保护性拷贝。同样地，在适合使用复合模式的公有类中使用继承，会把这个类与它的超类永远地束缚在一起，从而人为地限制了子类的性能。最后一个例子，在 API 中使用实现类型而不是接口，会把你束缚在一个具体的实现上，即使将来出现更快的实现你也无法使用。</p><p>API 设计对于性能的影响是非常实际的。以 java.awt.Component 类中的 getSize 方法为例。决定就是，这个注重性能的方法将返回 Dimension 实例，与此密切相关的决定是，Dimension 实例是可变的，迫使这个方法的任何实现都必须为每个调用分配一个新的 Dimension 实例。尽管在现代 VM 上分配小对象的开销并不大，但是分配数百万个不必要的对象仍然会严重地损害性能。</p><p>在这种情况下，有几种可供选择的替换方案。理想情况下，Dimension 应该是不可变的；另一种方案是，用两个方法来替换 getSize 方法，它们分别返回 Dimension 对象的单个基本组件。实际上，在 Java 2 发行版本中，出于性能方面的原因，有两个这样的方法被加入到 Component API 中。然而，原先的客户端代码仍然可以使用 getSize 方法，并且仍然要承受原始 API 设计决策所带来的性能影响。</p><p>幸运的是，一般而言，好的 API 设计也会带来好的性能。为获得好的性能而对 API 进行包装，这是一种非常不好的想法。导致你对 API 进行包装的性能因素可能会在平台未来的发行版本中，或者在将来的底层软件中不复存在，但是被包装的 API 以及由它引起的问题将永远困扰着你。</p><p>一旦精心地设计了程序，并且产生了一个清晰、简明、结构良好的实现，那么就到了该考虑优化的时候了，假定此时你对于程序的性能还不满意。</p><p>回想一下 Jackson 提出的两条优化原则：“不要优化”以及&quot;（仅针对专家）还是不要优化”。他可以再增加一条：在每次试图做优化之前和之后，要对性能进行测量。你可能会惊讶于自己的发现。试图做的优化通常对于性能并没有明显的影响，有时候甚至会使性能变得更差。主要原因在于，要猜出程序把时间花在哪些地方并不容易。你认为程序慢的地方可能并没有问题，这种情况下实际上是在浪费时间去尝试优化。大多数人认为：程序把 90% 的时间花在 10% 的代码上了。</p><p>性能剖析工具有助于决定应该把优化的重心放在哪里。这些工具可以为你提供运行时的信息，比如每个方法大致上花费了多少时间、它被调用多少次。除了确定优化的重点之外，它还可以警告你是否需要改变算法。如果一个平方级（或更差）的算法潜藏在程序中，无论怎么调整和优化都很难解决问题。你必须用更有效的算法来替换原来的算法。系统中的代码越多，使用性能剖析器就显得越发重要。这就好像要在一堆干草中寻找一根针：这堆干草越大，使用金属探测器就越有用。值得特别提及的另一种工具是 jmh，它不是一个性能剖析器，而是微基准测试框架，它提供了非并行地可见 Java 代码性能详情的能力。</p><p>在 Java 平台上对优化的结果进行测量，比在其他的传统平台（如 C 和 C++）上更有必要，因为 Java 程序设计语言没有很强的性能模型：各种基本操作的相对开销也没有明确定义。程序员所编写的代码与 CPU 执行的代码之间存在“语义沟”，而且这条语义沟比传统编译语言中的更大，这使得要想可靠地预测出任何优化的性能结果都非常困难。大量流传的关于性能的说法最终都被证明为半真半假，或者根本就不正确。</p><p>不仅 Java 的性能模型未得到很好的定义，而且在不同的 JVM 实现，不同的发行版本，以及不同的处理器中，也都各不相同。如果将要在多个 JVM 实现和多种硬件平台上运行程序，很重要的一点是，需要在每个 Java 实现上测量优化效果。有时候，还必须在从不同 JVM 实现或者硬件平台上得到的性能结果之中进行权衡。</p><p>自从本条目开始编写以来的近二十年，Java 软件堆栈的每一个组件都变得更加复杂，从管理器到虚拟机，再到类库，运行 Java 的各种硬件也得到了迅猛的发展。这些因素结合起来导致现在 Java 程序的性能比 2001 年时更难以预测了，因此对测量性能的需求也相应地增加了。</p><p>总而言之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。但在设计系统的时候，特别是在设计 API、交互层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它足够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的低层优化也无法弥补算法的选择不当。必要时重复这个过程，在每一次修改之后都要测量性能，直到满意为止。</p><h2 id="第-68-条-遵守普遍接受的命名惯例" tabindex="-1"><a class="header-anchor" href="#第-68-条-遵守普遍接受的命名惯例" aria-hidden="true">#</a> 第 68 条：遵守普遍接受的命名惯例</h2><p>Java 平台建立了一整套很好的命名惯例，其中有许多命名惯例包含在了《The Java Language Specification》中。不严格地讲，这些命名惯例分为两大类：字面的和语法的。</p><p>字面的命名惯例比较少，但也涉及包、类、接口、方法、域和类型变量。应该尽量不违反这些惯例，不到万不得已，千万不要违反。如果 API 违反了这些惯例，使用起来可能会很困难。如果实现违反了它们，可能会难以维护。在这两种情况下，违反惯例都会潜在地给使用这些代码的其他程序员带来困惑和苦恼，并且使他们做出错误的假设，造成程序出错。本条目将对这些惯例做简要的介绍。</p><p>包和模块的名称应该是层次状的，用句号分隔每个部分。每个部分都包括小写字母，极少数情况下还有数字。任何将在你的组织之外使用的包，其名称都应该以你的组织的 Internet 域名开头，并且顶级域名要放在前面，例如 edu.cmu、com.google、org.eff。标准类库和一些可选的包，其名称以 java 和 javax 开头，它们属于这一规则的例外。用户创建的包的名称绝不能以 java 和 javax 开头。关于将 Internet 域名转换为包名称前缀的详细规则，请参见《The Java Language Specification》。</p><p>包名称的其余部分应该包括一个或者多个描述该包的组成部分。这些组成部分应该比较简短，通常不超过 8 个字符。鼓励使用有意义的缩写形式，例如，使用 util 而不是 utilities。只取首字母的缩写形式也是可以接受的，例如 awt。每个组成部分通常都应该由一个单词或者一个缩写词组成。</p><p>许多包的名称中都只有一个组成部分再加上 Internet 域名。比较大的名称使用附加部分是正确的，它们的规模要求它们要被分割成一个非正式的层次结构。例如，javax.util 包有着非常丰富的包层次，如 javax.util.concurrent.atomic。这样的包通常被称为子包，尽管 Java 语言并没有提供对包层次的支持。</p><p>类和接口的名称，包括枚举和注解类型的名称，都应该包括一个或者多个单词，每个单词的首字母大写，例如 List 和 FutureTask。应该尽量避免用缩写，除非是一些首字母缩写和一些通用的缩写，比如 max 和 min。对于首字母缩写，到底应该全部大写还是只有首字母大写，没有统一的说法。虽然有些程序员仍然采用全部大写的形式，但还是有人强烈支持只首字母大写：即使连续出现多个首字母缩写的形式，你仍然可以区分出一个单词的起始处和结束处。比如类名 HTTPURL 和 HttpUrl 你更愿意看到哪一个？</p><p>方法和域的名称与类和接口的名称一样，都遵守相同的字面惯例，只不过方法或者域的名称的第一个字母应该小写，例如 remove、ensureCapacity。如果由首字母缩写组成的单词是一个方法或者域名称的第一个单词，它就应该是小写形式。</p><p>上述规则的唯一例外是“常量域”，它的名称应该包含一个或者多个大写的单词，中间用下划线符号隔开，例如 VALUES 或 NEGATIVE_INFINITY。常量域是个静态 final 域，它的值是不可变的。如果静态 final 域有基本类型，或者有不可变的引用类型，它就是个常量域。例如，枚举常量是常量域。如果静态 final 域有个可变的引用类型，若被引用的对象是不可变的，它也仍然可以是个常量域。注意，常量域是唯一推荐使用下划线的情形。</p><p>局部变量名称的字面命名惯例与成员名称类似，只不过它也允许缩写，单个字符和短字符序列的意义取决于局部变量所在的上下文环境，例如 i、denom 和 houseNum。输入参数是一种特殊的局部变量。它们的命名应该比普通的局部变量更加小心，因为它们的名称是其方法文档的一个组成部分。</p><p>类型参数名称通常由单个字母组成。这个字母通常是以下五种类型之一：T 表示任意的类型，E 表示集合的元素类型，K 和 V 表示映射的键和值类型，X 表示异常。函数的返回类型通常是 R。任何类型的序列可以是 T、U、V 或者 T1、T2、T3。</p><p>为了快速查阅，下表列出了字面惯例的例子。</p><table><thead><tr><th>标识符类型</th><th>示例</th></tr></thead><tbody><tr><td>包或者模块</td><td>org.junit.jupite.api, com.google.common.collect</td></tr><tr><td>类或者接口</td><td>Stream, FutureTask, LinkedHashMap, HttpClient</td></tr><tr><td>方法或者域</td><td>remove, groupingBy, getCrc</td></tr><tr><td>常量域</td><td>MIN_VALUE, NEGATIVE_INFINITY</td></tr><tr><td>局部变量</td><td>i, denom, houseNum</td></tr><tr><td>类型参数</td><td>T, E, K, V, X, R, U, V, T1, T2</td></tr></tbody></table><p>语法命名惯例比字面惯例更加灵活，也更有争议。对于包而言，没有语法命名惯例。可被实例化的类（包括枚举类型）通常用一个名词或者名词短语命名，例如 Thread、PriorityQueue 或者 ChessPiece。不可实例化的工具类经常用复数名词命名，如 Collectors 或者 Collections。接口的命名与类相似，例如 Collection 或 Comparator，或者用一个以 able 或 ible 结尾的形容词来命名，例如 Runnable、Iterable 或者 Accessible。由于注解类型有这么多用处，因此没有单独安排词类。名词、动词、介词和形容词都很常用，例如 BindingAnnotation、Inject、ImplementedBy 或者 Singleton。</p><p>执行某个动作的方法通常用动词或者动词短语（包括对象）来命名，例如 append 或 drawlmage。对于返回 boolean 值的方法，其名称往往以单词 is 开头，很少用 has，后面跟名词或名词短语，或者任何具有形容词功能的单词或短语，例如 isDigit、isProbablePrime、isEmpty、isEnabled 或者 hasSiblings。</p><p>如果方法返回被调用对象的一个非 boolean 的函数或者属性，它通常用名词、名词短语，或者以动词 get 开头的动词短语来命名，例如 size、hashCode 或者 getTime。有一个组织声称只有第三种形式（以 get 开头）才可以接受，但是这种声明没有得到支持。前两种形式往往会产生可读性更好的代码，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>car<span class="token punctuation">.</span>speedO <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">*</span> SPEED_LIMIT<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">generateAudibleAlert</span><span class="token punctuation">(</span><span class="token string">&quot;Watch out for cops!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以 get 开头的形式主要出现在被废弃的 Java Beans 规范中，它形成了早期的可重用组件架构的基础。有些现代工具继续依赖 Beans 命名惯例，你大可放心地在那些需要结合这些工具一起使用的代码中使用。如果类中包含了用于相同属性的 setter 方法和 getter 方法，也强烈建议釆用这种命名形式。在这种情况下，这两种方法应该分别被命名为 get<em>Attribute</em>和 set<em>Attribute</em>。</p><p>有些方法的名称值得专门提及。转换对象类型的实例方法，它们返回不同类型的独立对象的方法，经常被称 to<em>Type</em>，例如 toString 或者 toArray。返回视图（view，视图的类型不同于接收对象的类型）的方法经常被称为 as<em>Type</em> 例如 asList。返回一个与被调用对象同值的基本类型的方法，经常被称为 <em>type</em>Value，例如 intValue。静态工厂的常用名称包括 from、of、valueOf、instance、getInstance、newInstance、get<em>Type</em> 和 new<em>Type</em>。</p><p>域名称的语法惯例没有很好地建立起来，它们也没有类、接口和方法名称那么重要，因为设计良好的 API 很少会包含暴露出来的域。boolean 类型的域命名与 boolean 类型的访问方法很类似，但是省去了初始的 is，例如 initialized 和 composite。其他类型的域通常用名词或者名词短语来命名，比如 height、digits 或 bodyStyle。局部变量的语法惯例类似于域的语法惯例，但是更弱一些。</p><p>总而言之，把标准的命名惯例当作一种内在的机制来看待，并且学着用它们作为第二特性。字面惯例是非常直接和明确的；语法惯例则更复杂，也更松散。下面这句话引自《The Java Language Specification》：“如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。”请使用大家公认的做法。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Effective Java/第9章 通用编程.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html" class="nav-link prev" aria-label="第 8 章方法"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 8 章方法</div></a><a href="/reading-notes/Effective%20Java/%E7%AC%AC10%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link next" aria-label="第 10 章异常"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 10 章异常<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
