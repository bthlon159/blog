<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 5 章 泛型"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 5 章 泛型 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link active" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Effective Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC2%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 创建和销毁对象"><!---->第 2 章 创建和销毁对象<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC3%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对于所有对象都通用的方法"><!---->第 3 章 对于所有对象都通用的方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类和接口"><!---->第 4 章 类和接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 5 章 泛型"><!---->第 5 章 泛型<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-26-条-请不要使用原生态类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 26 条：请不要使用原生态类型"><!---->第 26 条：请不要使用原生态类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-27-条-消除非受检的警告" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 27 条：消除非受检的警告"><!---->第 27 条：消除非受检的警告<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-28-条-列表优于数组" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 28 条：列表优于数组"><!---->第 28 条：列表优于数组<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-29-条-优先考虑泛型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 29 条：优先考虑泛型"><!---->第 29 条：优先考虑泛型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-30-条-优先考虑泛型方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 30 条：优先考虑泛型方法"><!---->第 30 条：优先考虑泛型方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-31-条-利用有限制通配符来提升-api-的灵活性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 31 条：利用有限制通配符来提升 API 的灵活性"><!---->第 31 条：利用有限制通配符来提升 API 的灵活性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-32-条-谨慎并用泛型和可变参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 32 条：谨慎并用泛型和可变参数"><!---->第 32 条：谨慎并用泛型和可变参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-33-条-优先考虑类型安全的异构容器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 33 条：优先考虑类型安全的异构容器"><!---->第 33 条：优先考虑类型安全的异构容器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 枚举和注解"><!---->第 6 章 枚举和注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 Lambda 和 Stream"><!---->第 7 章 Lambda 和 Stream<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章方法"><!---->第 8 章方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章通用编程"><!---->第 9 章通用编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC10%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章异常"><!---->第 10 章异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章并发"><!---->第 11 章并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC12%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章序列化"><!---->第 12 章序列化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 5 章 泛型</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月16日</span><meta property="datePublished" content="2022-06-16T01:04:26.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 63 分钟</span><meta property="timeRequired" content="PT63M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 18993 字</span><meta property="wordCount" content="18993"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-26-条-请不要使用原生态类型" class="router-link-active router-link-exact-active toc-link level2">第 26 条：请不要使用原生态类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-27-条-消除非受检的警告" class="router-link-active router-link-exact-active toc-link level2">第 27 条：消除非受检的警告</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-28-条-列表优于数组" class="router-link-active router-link-exact-active toc-link level2">第 28 条：列表优于数组</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-29-条-优先考虑泛型" class="router-link-active router-link-exact-active toc-link level2">第 29 条：优先考虑泛型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-30-条-优先考虑泛型方法" class="router-link-active router-link-exact-active toc-link level2">第 30 条：优先考虑泛型方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-31-条-利用有限制通配符来提升-api-的灵活性" class="router-link-active router-link-exact-active toc-link level2">第 31 条：利用有限制通配符来提升 API 的灵活性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-32-条-谨慎并用泛型和可变参数" class="router-link-active router-link-exact-active toc-link level2">第 32 条：谨慎并用泛型和可变参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html#第-33-条-优先考虑类型安全的异构容器" class="router-link-active router-link-exact-active toc-link level2">第 33 条：优先考虑类型安全的异构容器</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-5-章-泛型" tabindex="-1"><a class="header-anchor" href="#第-5-章-泛型" aria-hidden="true">#</a> 第 5 章 泛型</h1><p>从 Java 5 开始，泛型已经成了 Java 编程语言的一部分。在没有泛型之前，从集合中读取到的每一个对象都必须进行转换。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，你可以告诉编译器每个集合中接受哪些对象类型。编译器自动为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以使程序更加安全，也更加清楚，但是要享有这些优势（不限于集合）有一定的难度。本章就是教你如何最大限度地享有这些优势，又能使整个过程尽可能简单化。</p><h2 id="第-26-条-请不要使用原生态类型" tabindex="-1"><a class="header-anchor" href="#第-26-条-请不要使用原生态类型" aria-hidden="true">#</a> 第 26 条：请不要使用原生态类型</h2><p>首先介绍一些术语。声明中具有一个或者多个类型参数的类或者接口，就是泛型类或者接口。例如，List 接口就只有单个类型参数 E，表示列表的元素类型。这个接口的全称是 List&lt;E&gt;（读作“E 的列表”），但是人们经常把它简称为 List。泛型类和接口统称为泛型。</p><p>每一种泛型定义一组参数化的类型，构成格式为：先是类或者接口的名称，接着用尖括号（&lt;&gt;）把对应于泛型形式类型参数的实际类型参数列表括起来。例如，List&lt;String&gt;（读作&quot;字符串列表”）是一个参数化的类型，表示元素类型为 String 的列表（String 是与形式的类型参数 E 相对应的实际类型参数）。</p><p>最后一点，每一种泛型都定义一个原生态类型，即不带任何实际类型参数的泛型名称。例如，与 List&lt;E&gt; 相对应的原生态类型是 List。原生态类型就像从类型声明中删除了所有泛型信息一样。它们的存在主要是为了与泛型出现之前的代码相兼容。</p><p>在 Java 增加泛型之前，下面这个集合声明是值得参考的。从 Java 9 开始，它依然合法，但是已经没什么参考价值了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Raw collection type - don&#39;t do this!</span>
<span class="token comment">// My stamp collection. Contains only Stamp instances.</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Collection</span> stamps <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果现在使用这条声明，并且不小心将一个 coin 放进了 stamp 集合中，这一错误的插入照样得以编译和运行，不会出错（不过编译器确实会发出一条模糊的警告信息）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Erroneous insertion of coin into stamp collection</span>
<span class="token comment">// Emits &quot;unchecked call&quot; warning</span>
stamps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coin</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直到从 stamp 集合中获取 coin 时才会收到一条错误提示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Raw iterator type - don&#39;t do this!</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span> i <span class="token operator">=</span> stamps<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Throws ClassCastException stamp.cancel();</span>
	<span class="token class-name">Stamp</span> stamp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Stamp</span><span class="token punctuation">)</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如本书中经常提到的，出错之后应该尽快发现，最好是编译时就发现。在本例中，直到运行时才发现错误，已经出错很久了，而且它在代码中所处的位置，距离包含错误的这部分代码已经很远了。一旦发现 ClassCastException，就必须搜索代码，查找将 coin 放进 stamp 集合的方法调用。此时编译器帮不上忙，因为它无法理解这种注释：“ Contains only Stamp instances“（只包含 Stamp 实例）。</p><p>有了泛型之后，类型声明中可以包含以下信息，而不是注释：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Parameterized collection type - typesafe</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Stamp</span><span class="token punctuation">&gt;</span></span> stamps <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这条声明，编译器知道 stamps 应该只包含 Stamp 实例，并给予保证，假设整个代码库在编译过程中都没有发出（或者隐瞒）任何警告。当 stamps 利用一个参数化的类型进行声明时，错误的插入会产生一条编译时的错误消息，告诉你具体是哪里出错了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Test</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">Coin</span> cannot be converted <span class="token keyword">to</span> <span class="token class-name">Stamp</span>
c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Coin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从集合中检索元素时，编译器会替你插入隐式的转换，并确保它们不会失败（依然假设所有代码都没有产生或者隐瞒任何编译警告）。假设不小心将 coin 插入 stamp 集合，这显得有点牵强，但这类问题却是真实的。例如，很容易想象有人会不小心将一个 BigInteger 实例放进一个原本只包含 BigDecimal 实例的集合中。</p><p>如上所述，使用原生态类型（没有类型参数的泛型）是合法的，但是永远不应该这么做。如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势。既然不应该使用原生态类型，为什么 Java 语言的设计者还要允许使用它们呢？这是为了提供兼容性。因为泛型出现的时候，Java 平台即将进入它的第二个十年，已经存在大量没有使用泛型的 Java 代码。人们认为让所有这些代码保持合法，并且能够与使用泛型的新代码互用，这一点很重要。它必须合法才能将参数化类型的实例传递给那些被设计成使用普通类型的方法，反之亦然。这种需求被称作移植兼容性，促成了支持原生态类型，以及利用擦除实现泛型的决定。</p><p>虽然不应该在新代码中使用像 List 这样的原生态类型，使用参数化的类型以允许插入任意对象（比如 List&lt;Object&gt;）是可行的。原生态类型 List 和参数化的类型 List&lt;Object&gt; 之间到底有什么区别呢？不严格地说，前者逃避了泛型检查，后者则明确告知编译器，它能够持有任意类型的对象。虽然可以将 List&lt;String&gt; 传递给类型 List 的参数，但是不能将它传给类型 List&lt;Object&gt; 的参数。泛型有子类型化的规则，List&lt;String&gt; 是原生态类型 List 的一个子类型，而不是参数化类型 List&lt;Object&gt; 的子类型。因此，如果使用像 List 这样的原生态类型，就会失掉类型安全性，但是如果使用像 List&lt;Object&gt; 这样的参数化类型，则不会。</p><p>为了更具体地进行说明，请参考下面的程序：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Fails at runtime - unsafeAdd method uses a raw type (List)!</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">unsafeAdd</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Has compiler-generated cast</span>
	<span class="token class-name">String</span> s <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unsafeAdd</span><span class="token punctuation">(</span><span class="token class-name">List</span> list<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段程序可以进行编译，但是因为它使用了原生态类型 List，你会收到一条警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Test</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">10</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked call <span class="token keyword">to</span> <span class="token namespace">add</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> as a member of the raw type <span class="token class-name">List</span> 
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，如果运行这段程序，在程序试图将 strings.get(0) 的调用结果 Integer 转换成 String 时，你会收到一个 ClassCastException 异常。这是一个编译器生成的转换，因此一般保证会成功，但是我们在这个例子中忽略了一条编译器警告，为此付出了代价。</p><p>如果在 unsafeAdd 声明中用参数化类型 List&lt;Object&gt; 代替原生态类型 List，并试着重新编译这段程序，会发现它无法再进行编译了，并发出以下错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Test</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cannot be converted <span class="token keyword">to</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span>
<span class="token function">unsafeAdd</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在不确定或者不在乎集合中的元素类型的情况下，你也许会使用原生态类型。例如，假设想要编写一个方法，它有两个集合，并从中返回它们共有元素的数量。如果你对泛型还不熟悉，可以参考以下方式来编写这种方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Use of raw type for unknown element type - don&#39;t do this!</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numElementsInCommon</span><span class="token punctuation">(</span><span class="token class-name">Set</span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> o1 <span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ol<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法可行，但它使用了原生态类型，这是很危险的。安全的替代做法是使用无限制的通配符类型。如果要使用泛型，但不确定或者不关心实际的类型参数，就可以用一个问号代替。例如，泛型 Set&lt;E&gt; 的无限制通配符类型为 Set&lt;?&gt;（读作“某个类型的集合”）。这是最普通的参数化 Set 类型，可以持有任何集合。下面是 numElementsInCommon 方法使用了无限制通配符类型时的情形：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Uses unbounded wildcard type - typesafe and flexible</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numElementsInCommon</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无限制通配类型 Set&lt;?&gt; 和原生态类型 Set 之间有什么区别呢？这个问号真正起到作用了吗？这一点不需要赘述，但通配符类型是安全的，原生态类型则不安全。由于可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件（如之前范例中所示的 unsafeAdd 方法）；但不能将任何元素（除了 null 之外）放到 Collection&lt;?&gt; 中。如果尝试这么做，将会产生一条像这样的编译时错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Wildcard</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">String</span> cannot be converted <span class="token keyword">to</span> CAP#<span class="token number">1</span>
c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;verboten&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">^</span>
where CAP#<span class="token number">1</span> is a fresh type<span class="token operator">-</span>variable<span class="token operator">:</span> CAP#<span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> from capture of <span class="token operator">?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的错误消息显然无法令人满意，但是编译器已经尽到了它的职责，防止你破坏集合的类型约束条件。你不仅无法将任何元素（除了 null 之外）放进 Collection&lt;?&gt; 中，而且根本无法猜测你会得到哪种类型的对象。要是无法接受这些限制，就可以使用泛型方法或者有限制的通配符类型。</p><p>不要使用原生态类型，这条规则有几个小小的例外。必须在类文字中使用原生态类型。规范不允许使用参数化类型（虽然允许数组类型和基本类型）。换句话说，List.class、String[ ].class 和 int.class 都合法，但是 List&lt;String&gt;.class 和 List&lt;?&gt;.class 则不合法。</p><p>这条规则的第二个例外与 instanceof 操作符有关。由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用 instanceof 操作符是非法的。用无限制通配符类型代替原生态类型，对 instanceof 操作符的行为不会产生任何影响。在这种情况下，尖括号和问号就显得多余了。下面是利用泛型来使用 instanceof 操作符的首选方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Legitimate use of raw type - instanceof operator</span>
<span class="token comment">// Raw type</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Set</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Wildcard type</span>
	<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，一旦确定这个 o 是个 Set，就必须将它转换成通配符类型 Set&lt;?&gt;，而不是转换成原生态类型 Set。这是个受检的转换，因此不会导致编译时警告。</p><p>总而言之，使用原生态类型会在运行时导致异常，因此不要使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。让我们做个快速的回顾：Set&lt;Object&gt; 是个参数化类型，表示可以包含任何对象类型的一个集合；Set&lt;?&gt; 则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；Set 是一个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。</p><p>为便于参考，在下表中概括了本条目中所介绍的术语（及本章后续条目中将要介绍的一些术语）：</p><table><thead><tr><th>术语</th><th>范例</th><th>条目</th></tr></thead><tbody><tr><td>参数化的类型</td><td>List&lt;String&gt;</td><td>第 26 条</td></tr><tr><td>实际类型参数</td><td>String</td><td>第 26 条</td></tr><tr><td>泛型</td><td>List&lt;E&gt;</td><td>第 26 条和第 29 条</td></tr><tr><td>形式类型参数</td><td>E</td><td>第 26 条</td></tr><tr><td>无限制通配符类型</td><td>List&lt;?&gt;</td><td>第 26 条</td></tr><tr><td>原生态类型</td><td>List</td><td>第 26 条</td></tr><tr><td>有限制类型参数</td><td>&lt;E extends Number&gt;</td><td>第 29 条</td></tr><tr><td>递归类型限制</td><td>&lt;T extends Comparable&lt;T&gt;&gt;</td><td>第 30 条</td></tr><tr><td>有限制通配符类型</td><td>List&lt;? extends Number&gt;</td><td>第 31 条</td></tr><tr><td>泛型方法</td><td>static &lt;E&gt; List &lt;E&gt; asList(E [ ] a)</td><td>第 30 条</td></tr><tr><td>类型令牌</td><td>String.class</td><td>第 33 条</td></tr></tbody></table><h2 id="第-27-条-消除非受检的警告" tabindex="-1"><a class="header-anchor" href="#第-27-条-消除非受检的警告" aria-hidden="true">#</a> 第 27 条：消除非受检的警告</h2><p>用泛型编程时会遇到许多编译器警告：非受检转换警告。非受检方法调用警告、非受检参数化可变参数类型警告，以及非受检转换警告。当你越来越熟悉泛型之后，遇到的警告也会越来越少，但是不要期待一开始用泛型编写代码就可以正确地进行编译。</p><p>有许多非受检警告很容易消除。例如，假设意外地编写了这样一个声明：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lark</span><span class="token punctuation">&gt;</span></span> exaltation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译器会细致地提醒你哪里出错了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Venery</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked conversion
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lark</span><span class="token punctuation">&gt;</span></span> exaltation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token operator">^</span>
required<span class="token operator">:</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Lark</span><span class="token punctuation">&gt;</span></span>
found<span class="token operator">:</span>    <span class="token class-name">HashSet</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你就可以纠正所显示的错误，消除警告。注意，不必真正去指定类型参数，只需要用在 Java 7 中开始引入的菱形操作符（&lt;&gt;）将它括起来即可。随后编译器就会推测出正确的实际类型参数（在本例中是 Lark）：</p><p><code>Set&lt;Lark&gt; exaltation = new HashSet&lt;&gt;();</code></p><p>有些警告非常难以消除。本章主要介绍这种警告示例。当你遇到需要进行一番思考的警告时，要坚持住！要尽可能地消除每一个非受检警告。如果消除了所有警告，就可以确保代码是类型安全的，这是一件很好的事情。这意味着不会在运行时出现 ClassCastException 异常，你会更加自信自己的程序可以实现预期的功能。</p><p>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下）才可以用一个 @SuppressWarnings( &#39;&#39;unchecked&quot;) 注解来禁止这条警告。如果在禁止警告之前没有先证实代码是类型安全的，那就只是给你自己一种错误的安全感而已。代码在编译的时候可能没有出现任何警告，但它在运行时仍然会抛出 ClassCastException 异常。但是如果忽略（而不是禁止）明知道是安全的非受检警告，那么当新出现一条真正有问题的警告时，你也不会注意到。新出现的警告就会淹没在所有的错误警告声当中。</p><p>SuppressWarnings 注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围内使用 SuppressWarnings 注解。它通常是个变量声明，或是非常简短的方法或构造器。永远不要在整个类上使用 SuppressWarnings，这么做可能会掩盖重要的警告。</p><p>如果你发现自己在长度不止一行的方法或者构造器中使用了 SuppressWarnings 注解，可以将它移到一个局部变量的声明中。虽然你必须声明一个新的局部变量，不过这么做还是值得的。例如，看看 ArrayList 类当中的 toArray 方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果编译 ArrayList，该方法就会产生成这条警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">305</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked cast
<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                          <span class="token operator">^</span>
required<span class="token operator">:</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
found<span class="token operator">:</span>	  <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 SuppressWarnings 注解放在 return 语句中是合法的，因为它不是声明。你可以试着将注解放在整个方法上，但是在实践中千万不要这么做，而是应该声明一个局部变量来保存返回值，并注解其声明，像这样：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Adding local variable to reduce scope of @SuppressWarnings</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This cast is correct because the array we&#39;re creating</span>
    <span class="token comment">// is of the same type as the one passed in, which is T[].</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span> 
    <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法可以正确地编译，禁止非受检警告的范围也会减到最小。</p><p>每当使用 SuppressWarnings(&quot;unchecked&quot;) 注解时，都要添加一条注释，说明为什么这么做是安全的。这样可以帮助其他人理解代码，更重要的是，可以尽量减少其他人修改代码后导致计算不安全的概率。如果你觉得这种注释很难编写，就要多加思考。最终你会发现非受检操作是非常不安全的。</p><p>总而言之，非受检警告很重要，不要忽略它们。每一条警告都表示可能在运行时抛出 ClassCastException 异常。要尽最大的努力消除这些警告。如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的，就可以在尽可能小的范围内使用 SuppressWarnings(&quot;unchecked&quot;) 注解禁止该警告。要用注释把禁止该警告的原因记录下来。</p><h2 id="第-28-条-列表优于数组" tabindex="-1"><a class="header-anchor" href="#第-28-条-列表优于数组" aria-hidden="true">#</a> 第 28 条：列表优于数组</h2><p>数组与泛型相比，有两个重要的不同点。首先，数组是协变的。这个词听起来有点吓人，其实只是表示如果 Sub 为 Super 的子类型，那么数组类型 Sub [] 就是 Super [] 的子类型。相反，泛型则是可变的：对于任意两个不同的类型 Type1 和 Type2，List&lt;Type1&gt; 既不是 List&lt;Type2&gt; 的子类型，也不是 List&lt;Type2&gt; 的超类型。你可能认为，这意味着泛型是有缺陷的，但实际上可以说数组才是有缺陷的。下面的代码片段是合法的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Fails at runtime!</span>
<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objectArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// Throws ArrayStoreException</span>
objectArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;I don&#39;t fit in&quot;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但下面这段代码则不合法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Won&#39;t compile!</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> o1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// Incompatible types</span>
o1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;I don&#39;t fit in&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这其中无论哪一种方法，都不能将 String 放进 Long 容器中，但是利用数组，你会在运行时才发现所犯的错误；而利用列表，则可以在编译时就发现错误。我们当然希望在编译时就发现错误。</p><p>数组与泛型之间的第二大区别在于，数组是具体化的。因此数组会在运行时知道和强化它们的元素类型。如上所述，如果企图将 String 保存到 Long 数组中，就会得到一个 ArrayStoreException 异常。相比之下，泛型则是通过擦除来实现的。这意味着，泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用，以确保在 Java 5 中平滑过渡到泛型。</p><p>由于上述这些根本的区别，因此数组和泛型不能很好地混合使用。例如，创建泛型、参数化类型或者类型参数的数组是非法的。这些数组创建表达式没有一个是合法的：new List&lt;E&gt; []、new List&lt;String&gt; [] 和 new E []。这些在编译时都会导致一个泛型数组创建错误。</p><p>为什么创建泛型数组是非法的？因为它不是类型安全的。要是它合法，编译器在其他正确的程序中发生的转换就会在运行时失败，并出现一个 ClassCastException 异常。这就违背了泛型系统提供的基本保证。</p><p>为了更具体地对此进行说明，以下面的代码片段为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Why generic array creation is illegal - won&#39;t compile!</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringLists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// (1) </span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	             <span class="token comment">// (2)</span>
<span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects <span class="token operator">=</span> stringLists<span class="token punctuation">;</span>	                   <span class="token comment">// (3)</span>
objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> intList<span class="token punctuation">;</span>	                             <span class="token comment">// (4)</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> stringLists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	                 <span class="token comment">// (5)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们假设第 1 行是合法的，它创建了一个泛型数组。第 2 行创建并初始化了一个包含单个元素的 List&lt;Integer&gt;。第 3 行将 List&lt;String&gt; 数组保存到一个 Object 数组变量中，这是合法的，因为数组是协变的。第 4 行将 List&lt;Integer&gt; 保存到 Object 数组里唯一的元素中，这是可以的，因为泛型是通过擦除实现的：List&lt;Integer&gt; 实例的运行时类型只是 List，List&lt;String&gt; [] 实例的运行时类型则是 List []，因此这种安排不会产生 ArrayStoreException 异常。但现在我们有麻烦了。我们将一个 List&lt;Integer&gt; 实例保存到了原本声明只包含 List&lt;String&gt; 实例的数组中。在第 5 行中，我们从这个数组里唯一的列表中获取了唯一的元素。编译器自动地将获取到的元素转换成 String，但它是一个 Integer，因此，我们在运行时得到了一个 ClassCastException 异常。为了防止出现这种情况，（创建泛型数组的）第 1 行必须产生一条编译时错误。</p><p>从技术的角度来说，像 E、List&lt;E&gt; 和 List&lt;String&gt; 这样的类型应称作不可具体化的类型。直观地说，不可具体化的类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具体化的参数化类型是无限制的通配符类型，如 List&lt;?&gt; 和 Map&lt;?, ?&gt;。虽然不常用，但是创建无限制通配类型的数组是合法的。</p><p>禁止创建泛型数组可能有点讨厌。例如，这表明泛型一般不可能返回它的元素类型数组。这也意味着在结合使用可变参数方法和泛型时会出现令人费解的警告。这是由于每当调用可变参数方法时，就会创建一个数组来存放 varargs 参数。如果这个数组的元素类型不是可具体化的，就会得到一条警告。利用 SafeVarargs 注解可以解决这个问题。</p><p>当你得到泛型数组创建错误时，最好的解决办法通常是优先使用集合类型 List&lt;E&gt;，而不是数组类型 E[]。这样可能会损失一些性能或者简洁性，但是换回的却是更高的类型安全性和互用性。</p><p>例如，假设要通过构造器编写一个带有集合的 Chooser 类和一个方法，并用该方法返回在集合中随机选择的一个元素。根据传给构造器的集合类型，可以用 chooser 充当游戏用的色子、魔术 8 球（一种卡片棋牌类游戏），或者一个蒙特卡罗模拟的数据源。下面是一个没有使用泛型的简单实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Chooser - a class badly in need of generics!</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Chooser</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> choiceArray<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Chooser</span><span class="token punctuation">(</span><span class="token class-name">Collection</span> choices<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>choiceArray <span class="token operator">=</span> choices<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Random</span> rnd <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> choiceArray<span class="token punctuation">[</span>rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>choiceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要使用这个类，必须将 choose 方法的返回值，从 Object 转换成每次调用该方法时想要的类型，如果搞错类型，转换就会在运行时失败。努力将 Chooser 修改成泛型，修改部分如粗体所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// A first cut at making Chooser generic - won&#39;t compile</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Chooser</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> choiceArray<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Chooser</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> choices<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	choiceArray <span class="token operator">=</span> choices<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// choose method unchanged</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果试着编译这个类，将会得到以下错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Chooser</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cannot be converted <span class="token keyword">to</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
choiceArray <span class="token operator">=</span> choices<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                             <span class="token operator">^</span>
where <span class="token class-name">T</span> is a type<span class="token operator">-</span>variable<span class="token operator">:</span> <span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> declared in <span class="token keyword">class</span> <span class="token class-name">Chooser</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会说：这没什么大不了的，我可以把 Object 数组转换成 T 数组：</p><p><code>choiceArray = (T[]) choices.toArray();</code></p><p>这样做的确消除了错误消息，但是现在得到了一条警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Chooser</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked cast
choiceArray <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> choices<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                   <span class="token operator">^</span>

required<span class="token operator">:</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
found<span class="token operator">:</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
where <span class="token class-name">T</span> is a type<span class="token operator">-</span>variable<span class="token operator">:</span> <span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> declared in <span class="token keyword">class</span> <span class="token class-name">Chooser</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器告诉你，它无法在运行时检查转换的安全性，因为程序在运行时还不知道 T 是什么——记住，元素类型信息会在运行时从泛型中被擦除。这段程序可以运行吗？可以，但是编译器无法证明这一点。你可以亲自证明，只要将证据放在注释中，用一条注解禁止警告，但是最好能消除造成警告的根源。</p><p>要消除未受检的转换警告，必须选择用列表代替数组。下面是编译时没有出错或者警告的 Chooser 类版本：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// List-based Chooser - typesafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Chooser</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> choiceList<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Chooser</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> choices<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>choiceList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>choices<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Random</span> rnd <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> choiceList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>choiceList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个版本的代码稍微冗长一点，运行速度可能也会慢一点，但是在运行时不会得到 ClassCastException 异常，为此也值了。</p><p>总而言之，数组和泛型有着截然不同的类型规则。数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好地混合使用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表代替数组。</p><h2 id="第-29-条-优先考虑泛型" tabindex="-1"><a class="header-anchor" href="#第-29-条-优先考虑泛型" aria-hidden="true">#</a> 第 29 条：优先考虑泛型</h2><p>一般来说，将集合声明参数化，以及使用 JDK 所提供的泛型方法，这些都不太困难。编写自己的泛型会比较困难一些，但是值得花些时间去学习如何编写。</p><p>以简单的（玩具）堆栈实现为例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Object-based collection - a prime candidate for generics</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Object</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
      	<span class="token comment">// Eliminate obsolete reference</span>
        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span>length <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            elements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个类应该先被参数化，但是它没有，我们可以在后面将它泛型化。换句话说，可以将它参数化，而又不破坏原来非参数化版本的客户端代码。也就是说，客户端必须转换从堆栈里弹出的对象，以及可能在运行时失败的那些转换。将类泛型化的第一步是在它的声明中添加一个或者多个类型参数。在这个例子中有一个类型参数，它表示堆栈的元素类型，这个参数的名称通常为 E。</p><p>下一步是用相应的类型参数替换所有的 Object 类型，然后试着编译最终的程序：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Initial attempt to generify Stack - won&#39;t compile!</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack2</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Stack2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Object</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">E</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// Eliminate obsolete reference</span>
        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... no changes in isEmpty or ensureCapacity</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常，你将至少得到一个错误提示或警告，这个类也不例外。幸运的是，这个类只产生一个错误，内容如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">8</span><span class="token operator">:</span> generic array creation
elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">E</span><span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
           <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你不能创建不可具体化的类型的数组，如 E。每当编写用数组支持的泛型时，都会出现这个问题。解决这个问题有两种方法。第一种，直接绕过创建泛型数组的禁令：创建一个 Object 的数组，并将它转换成泛型数组类型。现在错误是消除了，但是编译器会产生一条警告。这种用法是合法的，但（整体上而言）不是类型安全的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">8</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked cast
elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
               <span class="token operator">^</span>
required<span class="token operator">:</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
found<span class="token operator">:</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器不可能证明你的程序是类型安全的，但是你可以。你自己必须确保未受检的转换不会危及程序的类型安全性。相关的数组（即 elements 变量）保存在一个私有的域中，永远不会被返回到客户端，或者传给任何其他方法。这个数组中保存的唯一元素，是传给 push 方法的那些元素，它们的类型为 E，因此未受检的转换不会有任何危害。</p><p>一旦你证明了未受检的转换是安全的，就要在尽可能小的范围中禁止警告。在这种情况下，构造器只包含未受检的数组创建，因此可以在整个构造器中禁止这条警告。通过增加一条注解 @SuppressWarnings 来完成禁止，Stack 能够正确无误地进行编译，你就可以使用它了，无须显式的转换，也无须担心会出现 ClassCastException 异常：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The elements array will contain only E instances from push(E).</span>
<span class="token comment">// This is sufficient to ensure type safety, but the runtime</span>
<span class="token comment">// type of the array won&#39;t be E[]; it will always be Object[]!</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消除 Stack 中泛型数组创建错误的第二种方法是，将 elements 域的类型从 E[] 改为 Object[]。这么做会得到一条不同的错误：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token operator">:</span> incompatible types
<span class="token class-name">E</span> result <span class="token operator">=</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
                   <span class="token operator">^</span> 
required<span class="token operator">:</span> <span class="token class-name">E</span>
found<span class="token operator">:</span> <span class="token class-name">Object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过把从数组中获取到的元素由 Object 转换成 E，可以将这条错误变成一条警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked cast
<span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
                       <span class="token operator">^</span> 
required<span class="token operator">:</span> <span class="token class-name">E</span>
found<span class="token operator">:</span> <span class="token class-name">Object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 E 是一个不可具体化的类型，编译器无法在运行时检验转换。你还是可以自己证实未受检的转换是安全的，因此可以禁止该警告。我们只要在包含未受检转换的任务上禁止警告，而不是在整个 pop 方法上禁止就可以了，方法如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Appropriate suppression of unchecked warning</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyStackException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// push requires elements to be of type E, so cast is correct </span>
  <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
  <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elements<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// Eliminate obsolete reference return result;</span>
  elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种消除泛型数组创建的方法，各有所长。第一种方法的可读性更强：数组被声明为 E[] 类型清楚地表明它只包含 E 实例。它也更加简洁：在一个典型的泛型类中，可以在代码中的多个地方读取到该数组；第一种方法只需要转换一次（创建数组的时候），而第二种方法则是每次读取一个数组元素时都需要转换一次。因此，第一种方法优先，在实践中也更常用。但是，它会导致堆污染：数组的运行时类型与它的编译时类型不匹配（除非 E 正好是 Object）。这使得有些程序员会觉得很不舒服，因而选择第二种方案，虽然堆污染在这种情况下并没有什么危害。</p><p>下面的程序示范了泛型 Stack 类的使用方法。程序以倒序的方式打印出它的命令行参数，并转换成大写字母。如果要在从堆栈中弹出的元素上调用 String 的 toUpperCase 方法，并不需要显式的转换，并且确保自动生成的转换会成功：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Little program to exercise our generic Stack</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> vold <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
		stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看来上述的示例与第 28 条相矛盾了，第 28 条鼓励优先使用列表而非数组。实际上不可能总是或者总想在泛型中使用列表。Java 并不是生来就支持列表，因此有些泛型如 ArrayList，必须在数组上实现。为了提升性能，其他泛型如 HashMap 也在数组上实现。绝大多数泛型就像我们的 Stack 示例一样，因为它们的类型参数没有限制：你可以创建 Stack&lt;Object&gt;、Stac&lt;int [ ]&gt;、Stack&lt;List&lt;String&gt;&gt;，或者任何其他对象引用类型的 Stack。注意不能创建基本类型的 Stack：企图创建 Stack&lt;int&gt; 或者 Stack&lt;double&gt; 会产生一个编译时错误。这是 Java 泛型系统的一个基本局限性。你可以通过使用基本包装类型来避开这条限制。</p><p>有一些泛型限制了可允许的类型参数值。例如，以 java.util.concurrent.DelayQueue 例，其声明内容如下：</p><p><code>class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;</code></p><p>类型参数列表要求实际的类型参数 E 必须是 java.util.concurrent.Delayed 的一个子类型。它允许 DelayQueue 实现及其客户端在 DelayQueue 的元素上利用 Delayed 方法，无须显式的转换，也没有出现 ClassCastException 的风险。类型参数 E 被称作有限制的类型参数。注意，子类型关系确定了，每个类型都是它自身的子类型，因此创建 DelayQueue&lt;Delayed&gt; 是合法的。</p><p>总而言之，使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的。只要时间允许，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。</p><h2 id="第-30-条-优先考虑泛型方法" tabindex="-1"><a class="header-anchor" href="#第-30-条-优先考虑泛型方法" aria-hidden="true">#</a> 第 30 条：优先考虑泛型方法</h2><p>正如类可以从泛型中受益一般，方法也一样。静态工具方法尤其适合于泛型化。Collections 中的所有“算法”方法（例如 binarySearch 和 sort）都泛型化了。</p><p>编写泛型方法与编写泛型类型相类似。例如下面这个方法，它返回两个集合的联合：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Uses raw types - unacceptable! </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Set</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Set</span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Set</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">addAl1</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法可以编译，但是有两条警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Union</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked call <span class="token keyword">to</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> as a member of raw type <span class="token class-name">HashSet</span>

<span class="token class-name">Set</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token operator">^</span>

<span class="token class-name">Union</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">6</span><span class="token operator">:</span> warning<span class="token operator">:</span> <span class="token punctuation">[</span>unchecked<span class="token punctuation">]</span> unchecked call <span class="token keyword">to</span> <span class="token namespace">addAl1</span><span class="token punctuation">(</span><span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> as a member of raw type <span class="token class-name">Set</span>

result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了修正这些警告，使方法变成是类型安全的，要将方法声明修改为声明一个类型参数，表示这三个集合的元素类型（两个参数和一个返回值），并在方法中使用类型参数。声明类型参数的类型参数列表，处在方法的修饰符及其返回值之间。在这个示例中，类型参数列表为 &lt;E&gt;，返回类型为 Set&lt;E&gt;。类型参数的命名惯例与泛型方法以及泛型的相同：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Generic method</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s1<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至少对于简单的泛型方法而言，就是这么回事了。现在该方法编译时不会产生任何警告，并提供了类型安全性，也更容易使用。以下是一个执行该方法的简单程序。程序中不包含转换，编译时不会有错误或者警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Simple program to exercise generic method</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> guys <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;Tom&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Dick&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stooges <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;Larry&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Moe&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Curly&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> aflCio <span class="token operator">=</span> <span class="token function">union</span><span class="token punctuation">(</span>guys<span class="token punctuation">,</span> stooges<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aflCio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行这段程序时，会打印出 [Moe, Harry, Tom, Curly, Larry, Dick]（元素的输出顺序是独立于实现的）。</p><p>union 方法的局限性在于三个集合的类型（两个输入参数和一个返回值）必须完全相同。利用有限制的通配符类型可以使方法变得更加灵活。</p><p>有时可能需要创建一个不可变但又适用于许多不同类型的对象。由于泛型是通过擦除实现的，可以给所有必要的类型参数使用单个对象，但是需要编写一个静态工厂方法，让它重复地给每个必要的类型参数分发对象。这种模式称作泛型单例工厂，常用于函数对象，如 Collections.reverseOrder，有时也用于像 Collections.emptySet 这样的集合。</p><p>假设要编写一个恒等函数分发器。类库中提供了 Function.identity，因此不需要自己编写，但是自己编写也很有意义。如果在每次需要的时候都重新创建一个，这样会很浪费，因为它是无状态的。如果 Java 泛型被具体化了，每个类型都需要一个恒等函数，但是它们被擦除后，就只需要 T 泛型单例。请看以下示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Generic singleton factory pattern</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> IDENTITY_FN <span class="token operator">=</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> t<span class="token punctuation">;</span>

<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">identityFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> IDENTITY_FN<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IDENTITY_FN 转换成（UnaryFunction&lt;T&gt;），产生了一条未受检的转换警告，因为 UnaryFunction&lt;Object&gt; 对于每个 T 来说并非都是个 UnaryFunction&lt;T&gt;。但是恒等函数很特殊：它返回未被修改的参数，因此我们知道无论 T 的值是什么，用它作为 UnaryFunction&lt;T&gt; 都是类型安全的。因此，我们可以放心地禁止由这个转换所产生的未受检转换警告。一旦禁止，代码在编译时就不会出现任何错误或者警告。</p><p>下面是一个范例程序，它利用泛型单例作为 UnaryFunction&lt;String&gt; 和 UnaryFunction&lt;Number&gt;。像往常一样，它不包含转换，编译时没有出现错误或者警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Sample program to exercise generic singleton</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;jute&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hemp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;nylon&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sameString <span class="token operator">=</span> <span class="token function">identityFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sameString<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">Number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3L</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> sameNumber <span class="token operator">=</span> <span class="token class-name">IdentityFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Number</span> n <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sameNumber<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然相对少见，但是通过某个包含该类型参数本身的表达式来限制类型参数是允许的。这就是递归类型限制。递归类型限制最普遍的用途与 Comparable 接口有关，它定义类型的自然顺序。这个接口的内容如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类型参数 T 定义的类型，可以与实现 Comparable&lt;T&gt; 的类型的元素进行比较。实际上，几乎所有的类型都只能与它们自身的类型的元素相比较。例如 String 实现 Comparable&lt;String&gt;，Integer 实现 Comparable&lt;Integer&gt;，等等。</p><p>有许多方法都带有一个实现 Comparable 接口的元素列表，为了对列表进行排序，并在其中进行搜索，计算出它的最小值或者最大值，等等。要完成这其中的任何一项操作，都要求列表中的每个元素能够与列表中的每个其他元素相比较，换句话说，列表的元素可以互相比较。下面是如何表达这种约束条件的一个示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using a recursive type bound to express mutual comparability</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">E</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>类型限制&lt;E extends Comparable&lt;E&gt;&gt;，可以读作“针对可以与自身进行比较的每个类型 E”，这与互比性的概念或多或少有些一致。</p><p>下面的方法就带有上述声明。它根据元素的自然顺序计算列表的最大值，编译时没有出现错误或者警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Returns max value in a collection - uses recursive type bound</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">E</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Empty collection&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">E</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> e<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果列表为空，这个方法就会抛出 IllegalArgumentException 异常。更好的替代做法是返回一个 Optional&lt;E&gt;。</p><p>递归类型限制可能比这个要复杂得多，但幸运的是，这种情况并不经常发生。如果你理解了这种习惯用法和它的通配符变量，以及模拟自类型习惯用法，就能够处理在实践中遇到的许多递归类型限制了。</p><p>总而言之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也更加容易。就像类型一样，你应该确保方法不用转换就能使用，这通常意味着要将它们泛型化。并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会破坏现有的客户端。</p><h2 id="第-31-条-利用有限制通配符来提升-api-的灵活性" tabindex="-1"><a class="header-anchor" href="#第-31-条-利用有限制通配符来提升-api-的灵活性" aria-hidden="true">#</a> 第 31 条：利用有限制通配符来提升 API 的灵活性</h2><p>参数化类型是不变的。换句话说，对于任何两个截然不同的类型 Type1 和 Type2 而言，List&lt;Type1&gt; 既不是 List&lt;Type2&gt; 的子类型，也不是它的超类型。虽然 List&lt;String&gt; 不是 List&lt;Object&gt; 的子类型，这与直觉相悖，但是实际上很有意义。你可以将任何对象放进一个 List&lt;Object&gt; 中，却只能将字符串放进 List&lt;String&gt; 中。由于 List&lt;String&gt; 不能像 List&lt;Object&gt; 能做任何事情，它不是一个子类型。</p><p>有时候，我们需要的灵活性要比不变类型所能提供的更多。比如第 29 条中的堆栈。提醒一下，下面就是它的公共 API：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设我们想要增加一个方法，让它按顺序将一系列的元素全部放到堆栈中。第一次尝试如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// pushAll method without wildcard type - deficient!</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pushAl1</span><span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法编译时正确无误，但是并非尽如人意。如果 Iterable 的 src 元素类型与堆栈的完全匹配，就没有问题。但是假如有一个 Stack&lt;Number&gt;，并且调用了 push(intVal)，这里的 intVal 就是 Integer 类型。这是可以的，因为 Integer 是 Number 的一个子类型。因此从逻辑上来说，下面这个方法应该可行：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numberStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
numberStack<span class="token punctuation">.</span><span class="token function">pushAll</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果尝试这么做，就会得到下面的错误消息，因为参数化类型是不可变的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">StackTest</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">7</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> cannot be converted <span class="token keyword">to</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span>
numberStack<span class="token punctuation">.</span><span class="token function">pushAl1</span><span class="token punctuation">(</span>integers<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>幸运的是，有一种解决办法。Java 提供了一种特殊的参数化类型，称作有限制的通配符类型，它可以处理类似的情况。pushAll 的输入参数类型不应该为 “E 的 Iterable 接口”，而应该为 “E 的某个子类型的 Iterable 接口” 通配符类型 Iterable&lt;? extends E&gt; 正是这个意思（使用关键字 extends 有些误导：回忆一下第 29 条中的说法，确定了子类型后，每个类型便都是自身的子类型，即便它没有将自身扩展）。我们修改一下 pushAll 来使用这个类型：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Wildcard type for a parameter that serves as an E producer</span>
<span class="token keyword">public</span> vold pushAll <span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>；
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改之后，不仅 Stack 可以正确无误地编译，没有通过初始的 pushAll 声明进行编译的客户端代码也一样可以。因为 Stack 及其客户端正确无误地进行了编译，你就知道一切都是类型安全的了。</p><p>现在假设想要编写一个 popAll 方法，使之与 pushAll 方法相呼应。popAll 方法从堆栈中弹出每个元素，并将这些元素添加到指定的集合中。初次尝试编写的 popAll 方法可能像下面这样：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// popAll method without wildcard type - deficient!</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">popAl1</span><span class="token punctuation">(</span><span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
whi1e <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dst<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，如果目标集合的元素类型与堆栈的完全匹配，这段代码编译时还是会正确无误，并且运行良好。但是，也并不意味着尽如人意。假设你有一个 Stack&lt;Number&gt; 和 Object 类型的变量。如果从堆栈中弹出一个元素，并将它保存在该变量中，它的编译和运行都不会出错，那你为何不能也这么做呢？</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numberStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> objects <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
numberStack<span class="token punctuation">.</span><span class="token function">popAl1</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果试着用上述的 popAll 版本编译这段客户端代码，就会得到一个非常类似于第一次用 pushAll 时所得到的错误：Collection&lt;Object&gt; 不是 Collection&lt;Number&gt; 的子类型。这一次通配符类型同样提供了一种解决办法。popAll 的输入参数类型不应该为 “E 的集合”，而应该为 “E 的某种超类的集合”（这里的超类是确定的，因此 E 是它自身的一个超类型）。仍有一个通配符类型正符合此意：Collection&lt;? super E&gt;。让我们修改 popAll 来使用它：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Wildcard type for parameter that serves as an E consumer</span>
publ1c <span class="token keyword">void</span> popAll <span class="token punctuation">(</span><span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> dst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dst<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>做了这个变动之后，Stack 和客户端代码就都可以正确无误地编译了。</p><p>结论很明显：为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。如果某个输入参数既是生产者，又是消费者，那么通配符类型对你就没有什么好处了：因为你需要的是严格的类型匹配，这是不用任何通配符而得到的。</p><p>下面的助记符便于让你记住要使用哪种通配符类型：</p><p><strong>PECS 表示 producer-extends，consumer-super</strong>。</p><p>换句话说，如果参数化类型表示一个生产者 T，就使用 &lt;? extends T&gt;；如果它表示一个消费者 T，就使用 &lt;? super T&gt;。在我们的 Stack 示例中，pushAll 的 src 参数产生 E 实例供 Stack 使用，因此 src 相应的类型为 Iterable&lt;? extends E&gt;；popAll 的 dst 参数通过 Stack 消费 E 实例，因此 dst 相应的类型为 Collection&lt;? super E&gt;。PECS 这个助记符突出了使用通配符类型的基本原则。</p><p>记住这个助记符，下面我们来看一些之前的条目中提到过的方法声明。</p><p><code>public Chooser(Col1ection&lt;T&gt; choices)</code></p><p>这个构造器只用 choices 集合来生成类型 T 的值（并把它们保存起来供后续使用），因此它的声明应该使用一个 extends T 的通配符类型。得到的构造器声明如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Wildcard type for parameter that serves as an T producer</span>
<span class="token keyword">public</span> <span class="token class-name">Chooser</span><span class="token punctuation">(</span><span class="token class-name">Col1ection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> choices<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这一变化实际上有什么区别吗？事实上，的确有区别。假设你有一个 List&lt;Integer&gt;，想通过 Function&lt;Number&gt; 把它简化。它不能通过初始声明进行编译，但是一旦添加了有限制的通配符类型，就可以进行编译了。</p><p>现在让我们看看第 30 条中的 union 方法。声明如下：</p><p><code>public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</code></p><p>s1 和 s2 这两个参数都是生产者 E，因此根据 PECS 助记符，这个声明应该是：</p><p><code>public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,Set&lt;? extends E&gt; s2)</code></p><p>注意返回类型仍然是 Set&lt;E&gt;。不要用通配符类型作为返回类型。除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。修改了声明之后，这段代码就能正确编译了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> doubles <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">6.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token function">union</span><span class="token punctuation">(</span>integers<span class="token punctuation">,</span> doubles<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用得当，通配符类型对于类的用户来说几乎是无形的。它们使方法能够接受它们应该接受的参数，并拒绝那些应该拒绝的参数。如果类的用户必须考虑通配符类型，类的 API 或许就会出错。</p><p>在 Java 8 之前，类型推导规则还不够智能，它无法处理上述代码片段，还需要编译器使用通过上下文指定的返回类型（或者目标类型）来推断 E 的类型。前面出现过的 union 调用的目标类型是 Set&lt;Number&gt;。如果试着在较早的 Java 版本中编译这个代码片段（使用 Set.of 工厂相应的替代方法），将会得到一条像下面这样冗长、繁复的错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Union</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types

<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token function">union</span><span class="token punctuation">(</span>integers<span class="token punctuation">,</span> doubles<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           <span class="token operator">^</span>
required<span class="token operator">:</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span>
found<span class="token operator">:</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span>INT#l<span class="token operator">&gt;</span>
where INT#<span class="token number">1</span><span class="token punctuation">,</span>INT#<span class="token number">2</span> are intersection types<span class="token operator">:</span>
INT#<span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">INT</span>#<span class="token number">2</span><span class="token operator">&gt;</span>
INT#<span class="token number">2</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>幸运的是，有一种办法可以处理这种错误。如果编译器不能推断出正确的类型，始终可以通过一个显式的类型参数来告诉它要使用哪种类型。甚至在 Java 8 中引入目标类型之前，这种情况不经常发生，这是好事，因为显式的类型参数不太优雅。增加了这个显式的类型参数之后，这个代码片段在 Java 8 之前的版本中也能正确无误地进行编译了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Explicit type parameter - required prior to Java 8</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Union</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span><span class="token function">union</span><span class="token punctuation">(</span>integers<span class="token punctuation">,</span> doubles<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们把注意力转向 max 方法。以下是初始的声明：</p><p><code>public static &lt;T extends Comparable&lt;T&gt;&gt; T max (List&lt;T&gt; list)</code></p><p>下面是修改过的使用通配符类型的声明：</p><p><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)</code></p><p>为了从初始声明中得到修改后的版本，要应用 PECS 转换两次。最直接的是运用到参数 list。它产生 T 实例，因此将类型从 List&lt;T&gt; 改成 List&lt;? extends T&gt;。更灵活的是运用到类型参数 T。这是我么第一次见到将通配符运用到类型参数。最初 T 被指定用来扩展 Comparable&lt;T&gt;，但是 T 的 comparable 消费 T 实例（并产生表示顺序关系的整值）。因此，参数化类型 Comparable&lt;T&gt; 被有限制通配符类型 Comparable&lt;? super T&gt; 取代。comparable 始终是消费者，因此使用时始终应该是 Comparable&lt;? super T&gt; 优先于 Comparable&lt;T&gt;。对于 comparator 接口也是一样，因此使用时始终应该是 Comparator&lt;? super T&gt; 优先于 Comparator&lt;T&gt;。</p><p>修改过的 max 声明可能是整本书中最复杂的方法声明了。所增加的复杂代码真的起作用了么？是的，起作用了。下面是一个简单的列表示例，在初始的声明中不允许这样，修改过的版本则可以：</p><p><code>List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ...;</code></p><p>不能将初始方法声明运用到这个列表的原因在于，java.util.concurrent.ScheduledFuture 没有实现 Comparable&lt;ScheduledFuture&gt; 接口。相反，它是扩展 Comparable&lt;Delayed&gt; 接口的 Delayed 接口的子接口。换句话说，ScheduleFuture 实例并非只能与其他 ScheduledFuture 实例相比较；它可以与任何 Delayed 实例相比较，这就足以导致初始声明时就会被拒绝。更通俗地说，需要用通配符支持那些不直接实现 Comparable（或者 Comparator）而是扩展实现了该接口的类型。</p><p>还有一个与通配符有关的话题值得探讨。类型参数和通配符之间具有双重性，许多方法都可以利用其中一个或者另一个进行声明。例如，下面是可能的两种静态方法声明，来交换列表中的两个被索引的项目。第一个使用无限制的类型参数，第二个使用无限制的通配符：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Two possible declarations for the swap method</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你更喜欢这两种声明中的哪一种呢？为什么？在公共 API 中，第二种更好一些，因为它更简单。将它传到一个列表中（任何列表）方法就会交换被索引的元素。不用担心类型参数。一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它。如果是无限制的类型参数，就用无限制的通配符取代它；如果是有限制的类型参数，就用有限制的通配符取代它。</p><p>将第二种声明用于 swap 方法会有一个问题。下面这个简单的实现不能编译：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>试着编译时会产生这条没有什么用处的错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Swap</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> error<span class="token operator">:</span> incompatible types<span class="token operator">:</span> <span class="token class-name">Object</span> cannot be converted <span class="token keyword">to</span> CAP#<span class="token number">1</span>

list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token operator">^</span>
where CAP#<span class="token number">1</span> is a fresh type<span class="token operator">-</span>variable<span class="token operator">:</span> CAP#<span class="token number">1</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> from capture of <span class="token operator">?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不能将元素放回刚刚从中取出的列表中，这似乎不太对劲。问题在于 list 的类型为 List&lt;?&gt;，你不能把 null 之外的任何值放到 List&lt;?&gt; 中。幸运的是，有一种方式可以实现这个方法，无须求助于不安全的转换或者原生态类型。这种想法就是编写一个私有的辅助方法来捕捉通配符类型。为了捕捉类型，辅助方法必须是一个泛型方法。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>publ1c <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">swapHelper</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//  Private helper method for wildcard capture</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">swapHelper</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>swapHelper 方法知道 list 是一个 List&lt;E&gt;。因此，它知道从这个列表中取出的任何值均为 E 类型，并且知道将 E 类型的任何值放进列表都是安全的。swap 这个有些费解的实现编译起来却是正确无误的。它允许我们导出 swap 这个比较好的基于通配符的声明，同时在内部利用更加复杂的泛型方法。swap 方法的客户端不一定要面对更加复杂的 swapHelper 声明，但是它们的确从中受益。值得一提的是，辅助方法中拥有的签名，正是我们在公有方法中因为它过于复杂而抛弃的。</p><p>总而言之，在 API 中使用通配符类型虽然比较需要技巧，但是会使 API 变得灵活得多。如果编写的是将被广泛使用的类库，则一定要适当地利用通配符类型。记住基本的原则：producer-extends，consumer-super（PECS）。还要记住所有的 comparable 和 comparator 都是消费者。</p><h2 id="第-32-条-谨慎并用泛型和可变参数" tabindex="-1"><a class="header-anchor" href="#第-32-条-谨慎并用泛型和可变参数" aria-hidden="true">#</a> 第 32 条：谨慎并用泛型和可变参数</h2><p>可变参数方法和泛型都是在 Java 5 中就有了，因此你可能会期待它们可以良好地相互作用；遗憾的是，它们不能。可变参数的作用在于让客户端能够将可变数量的参数传给方法，但这是个技术露底：当调用一个可变参数方法时，会创建一个数组用来存放可变参数；这个数组应该是一个实现细节，它是可见的。因此，当可变参数有泛型或者参数化类型时，编译警告信息就会产生混乱。</p><p>非具体化类型是指其运行时代码信息比编译时少，并且显然所有的泛型和参数类型都是非具体化的。如果一个方法声明其可变参数为 non-reifiable 类型，编译器就会在声明中产生一条警告。如果方法是在类型为 non-reifiable 的可变参数上调用，编译器也会在调用时发出一条警告信息。这个警告信息类似于：</p><p><code>warning: [unchecked] Possible heap pollution from parameterized vararg type List&lt;String&gt;</code></p><p>当一个参数化类型的变量指向一个不是该类型的对象时，会产生堆污染。它导致编辑器的自动生成转换失败，破坏了泛型系统的基本保证。</p><p>举个例子。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Mixing generics and varargs can violate type safety!</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dangerous</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> stringLists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> intList <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects <span class="token operator">=</span> stringLists<span class="token punctuation">;</span>
  <span class="token comment">// Heap pollution</span>
  objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> intList<span class="token punctuation">;</span>
  <span class="token comment">// ClassCastException</span>
  <span class="token class-name">String</span> s <span class="token operator">=</span> stringLists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法没有可见的转换，但是在调用一个或者多个参数时会抛出 ClassCastException 异常。上述最后一行代码中有一个不可见的转换，这是由编译器生成的。这个转换失败证明类型安全已经受到了危及，因此将值保存在泛型可变参数数组参数中是不安全的。</p><p>这个例子引出了一个有趣的问题：为什么显式创建泛型数组是非法的，用泛型可变参数声明方法却是合法的呢？换句话说，为什么之前展示的方法只产生一条警告，而代码片段却产生一个错误呢？答案在于，带有泛型可变参数或者参数化类型的方法在实践中用处很大，因此 Java 语言的设计者选择容忍这一矛盾的存在。事实上，Java 类库导出了好几个这样的方法，包括 Arrays.asList(T ... a)、Collections.addAll(Collection&lt;? super T&gt; C, T . . . elements)，以及 EnumSet.of(E first, E. . . rest)。与前面提到的危险方法不一样，这些类库方法是类型安全的。</p><p>在 Java 7 之前，带泛型可变参数的方法的设计者，对于在调用处出错的警告信息一点办法也没有。这使得这些 API 使用起来非常不愉快。用户必须忍受这些警告，要么最好在每处调用点都通过 @SuppressWarnings (&#39;&#39;unchecked&quot;) 注解来消除警告。这么做过于烦琐，而且影响可读性，并且掩盖了反映实际问题的警告。</p><p>在 Java 7 中，增加了 SafeVarargs 注解，它让带泛型 vararg 参数的方法的设计者能够自动禁止客户端的警告。本质上，SafeVarargs 注解是通过方法的设计者做出承诺，声明这是类型安全的。作为对于该承诺的交换，编译器同意不再向该方法的用户发出警告说这些调用可能不安全。</p><p>重要的是，不要随意用 @SafeVarargs 对方法进行注解，除非它真正是安全的。那么它凭什么确保安全呢？回顾一下，泛型数组是在调用方法的时候创建的，用来保存可变参数。如果该方法没有在数组中保存任何值，也不允许对数组的引用转义（这可能导致不被信任的代码访问数组），那么它就是安全的。换句话说，如果可变参数数组只用来将数量可变的参数从调用程序传到方法（毕竟这才是可变参数的目的），那么该方法就是安全的。</p><p>值得注意的是，从来不在可变参数的数组中保存任何值，这可能破坏类型安全性。以下面的泛型可变参数方法为例，它返回了一个包含其参数的数组。乍看之下，这似乎是一个方便的小工具：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// UNSAFE - Exposes a reference to its generic parameter array!</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> args<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法只是返回其可变参数数组，看起来没什么危险，但它实际上很危险！这个数组的类型，是由传到方法的参数的编译时类型来决定的，编译器没有足够的信息去做准确的决定。因为该方法返回其可变参数数组，它会将堆污染传到调用堆栈上。</p><p>下面举个具体的例子。这是一个泛型方法，它带有三个类型为 T 的参数，并返回一个包含两个（随机选择的）参数的数组：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">pickTwo</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">,</span> <span class="token class-name">T</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextlnt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token function">toArray</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token function">toArray</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token function">toArray</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Can&#39;t get here</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法本身并没有危险，也不会产生警告，除非它调用了带有泛型可变参数的 toArray 方法。</p><p>在编译这个方法时，编译器会产生代码，创建一个可变参数数组，并将两个 T 实例传到 toArray。这些代码配置了一个类型为 Object[] 的数组，这是确保能够保存这些实例的最具体的类型，无论在调用时给 pickTwo 传递什么类型的对象都没问题。toArray 方法只是将这个数组返回给 pickTwo，反过来也将它返回给其调用程序，因此 pickTwo 始终都会返回一个类型为 Object[] 的数组。</p><p>现在以下面的 main 方法为例，练习一下 pickTwo 的用法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> attributes <span class="token operator">=</span> <span class="token function">pickTwo</span><span class="token punctuation">(</span><span class="token string">&quot;Good&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Fast&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Cheap&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法压根没有任何问题，因此编译时不会产生任何警告。但是在运行的时候，它会抛出一个 ClassCastException，虽然它看起来并没有包括任何的可见的转换。你看不到的是，编译器在 PickTwo 返回的值上产生了一个隐藏的 String [] 转换。但转换失败了，这是因为从实际导致堆污染（toArray）的方法处移除了两个级别，可变参数数组在实际的参数存入之后没有进行修改。</p><p>这个范例是为了告诉大家，允许另一个方法访问一个泛型可变参数数组是不安全的，有两种情况例外：将数组传给另一个用@SafeVarargs 正确注解过的可变参数方法是安全的，将数组传给只计算数组内容部分函数的非可变参数方法也是安全的。</p><p>这里有一个安全使用泛型可变参数的典型范例。这个方法中带有一个任意数量参数的列表，并按顺序返回包含输入清单中所有元素的唯一列表。由于该方法用 @SafeVarargs 注解过，因此在声明处或者调用处都不会产生任何警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Safe method with a generic varargs parameter</span>
<span class="token annotation punctuation">@SafeVarargs</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>确定何时应该使用 SafeVarargs 注解的规则很简单：对于每一个带有泛型可变参数或者参数化类型的方法，都要用 @SafeVarargs 进行注解，这样它的用户就不用承受那些无谓的、令人困惑的编译警报了。这意味着应该永远都不要编写像 dangerous 或者 toArray 这类不安全的可变参数方法。每当编译器警告你控制的某个带泛型可变参数的方法可能形成堆污染，就应该检査该方法是否安全。这里先提个醒，泛型可变参数方法在下列条件下是安全的：</p><ol><li>它没有在可变参数数组中保存任何值。</li><li>它没有对不被信任的代码开放该数组（或者其克隆程序）。</li></ol><p>以上两个条件只要有任何一条被破坏，就要立即修正它。</p><p>注意，SafeVarargs 注解只能用在无法被覆盖的方法上，因为它不能确保每个可能的覆盖方法都是安全的。在 Java 8 中，该注解只在静态方法和 final 实例方法中才是合法的；在 Java 9 中，它在私有的实例方法上也合法了。</p><p>如果不想使用 SafeVarargs 注解，也可以采用一个 List 参数代替可变参数（这是一个伪装数组）。下面举例说明这个办法在 flatten 方法上的运用。注意，此处只对参数声明做了修改：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// List as a typesafe al ternative to a generic varargs parameter</span>
<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">addAl1</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>随后，这个方法就可以结合静态工厂方法 List.of 一起使用了，允许使用数量可变的参数。注意，使用该方法的前提是用 @SafeVarargs 对 List.of 声明进行了注解：</p><p><code>audience = flatten(List.of(friends, romans, countrymen));</code></p><p>这种做法的优势在于编译器可以证明该方法是类型安全的。你不必再通过 SafeVarargs 注解来证明它的安全性，也不必担心自己是否错误地认定它是安全的。其缺点在于客户端代码有点烦琐，运行起来速度会慢一些。</p><p>这一技巧也适用于无法编写出安全的可变参数方法的情况，比如本条之前提到的 toArray 方法。其 List 对应的是 List.of 方法，因此我们不必编写；Java 类库的设计者已经替我们完成了。因此 pickTwo 方法就变成了下面这样：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">pickTwo</span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">,</span> <span class="token class-name">T</span> b<span class="token punctuation">,</span> <span class="token class-name">T</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>rnd<span class="token punctuation">.</span><span class="token function">nextlnt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>main 方法变成了下面这样：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> attributes <span class="token operator">=</span> <span class="token function">pickTwo</span><span class="token punctuation">(</span><span class="token string">&quot;Good&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Fast&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Cheap&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样得到的代码就是类型安全的，因为它只使用泛型，没有用到数组。</p><p>总而言之，可变参数和泛型不能良好地合作，这是因为可变参数设施是构建在顶级数组之上的一个技术露底，泛型数组有不同的类型规则。虽然泛型可变参数不是类型安全的，但它们是合法的。如果选择编写带有泛型（或者参数化）可变参数的方法，首先要确保该方法是类型安全的，然后用 @SafeVarargs 对它进行注解，这样使用起来就不会出现不愉快的情况了。</p><h2 id="第-33-条-优先考虑类型安全的异构容器" tabindex="-1"><a class="header-anchor" href="#第-33-条-优先考虑类型安全的异构容器" aria-hidden="true">#</a> 第 33 条：优先考虑类型安全的异构容器</h2><p>泛型最常用于集合，如 Set&lt;E&gt; 和 Map&lt;K, V&gt;，以及单个元素的容器，如 ThreadLocal&lt;T&gt; 和 AtomicReference&lt;T&gt;。在所有这些用法中，它都充当被参数化了的容器。这样就限制每个容器只能有固定数目的类型参数。一般来说，这种情况正是你想要的。一个 Set 只有一个类型参数，表示它的元素类型；一个 Map 有两个类型参数，表示它的键和值类型。</p><p>但是，有时候你会需要更多的灵活性。例如，数据库的行可以有任意数量的列，如果能以类型安全的方式访问所有列就好了。幸运的是，有一种方法可以很容易地做到这一点。这种方法就是将键进行参数化而不是将容器参数化。然后将参数化的键提交给容器来插入或者获取值。用泛型系统来确保值的类型与它的键相符。</p><p>下面简单地示范一下这种方法：以 Favorites 类为例，它允许其客户端从任意数量的其他类中，保存并获取一个“最喜爱”的实例。Class 对象充当参数化键的部分。之所以可以这样，是因为类 Class 被泛型化了。类的类型从字面上来看不再只是简单的 Class，而是 Class&lt;T&gt;。例如，String.class 属于 Class&lt;String&gt; 类型，Integer.class 属于 Class&lt;Integer&gt; 类型。当一个类的字面被用在方法中，来传达编译时和运行时的类型信息时，就被称作类型令牌。</p><p>Favorites 类的 API 很简单。它看起来就像一个简单的映射，除了键（而不是映射）被参数化之外。客户端在设置和获取最喜爱的实例时提交 Class 对象。下面就是这个 API：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Typesafe heterogeneous container pattern - API</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Favorites</span> <span class="token punctuation">(</span>
  <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">T</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个示例程序，检验一下 Favorites 类，它将保存、获取并打印一个最喜爱的 String、Integer 和 Class 实例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Typesafe heterogeneous container pattern - client</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Favorites</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Favorites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token number">0xcafebabe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Favorites</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">String</span> favoriteString <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> favoriteInteger <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> favoriteClass <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s %x %s%n&quot;</span><span class="token punctuation">,</span> favoriteString<span class="token punctuation">,</span> favoriteInteger<span class="token punctuation">,</span> favoriteClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如所料，这段程序打印出的是 Java cafebabe Favorites。注意，有时 Java 的 printf 方法与 C 语言中的不同，C 语言中使用 \n 的地方，在 Java 中应该使用 ％n。这个 ％n 会产生适用于特定平台的行分隔符，在许多平台上是 \n，但是并非所有平台都是如此。</p><p>Favorites 实例是类型安全的：当你向它请求 String 的时候，它从来不会返回一个 Integer 给你。同时它也是异构的：不像普通的映射，它的所有键都是不同类型的。因此，我们将 Favorites 称作类型安全的异构容器。</p><p>Favorites 的实现小得出奇。它的完整实现如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Typesafe heterogeneous container pattern - implementation</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Favorites</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> favorites <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        favorites<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> type<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>favorites<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面发生了一些微妙的事情。每个 Favorites 实例都得到一个称作 favorites 的私有 Map&lt;Class&lt;?&gt;, Object&gt; 的支持。你可能认为由于无限制通配符类型的关系，将不能把任何东西放进这个 Map 中，但事实正好相反。要注意的是通配符类型是嵌套的：它不是属于通配符类型的 Map 的类型，而是它的键的类型。由此可见，每个键都可以有一个不同的参数化类型：一个可以是 Class&lt;String&gt;，接下来是 Class&lt;Integer&gt; 等。异构就是从这里来的。</p><p>第二件要注意的事情是，favorites Map 的值类型只是 Object。换句话说，Map 并不能保证键和值之间的类型关系，即不能保证每个值都为它的健所表示的类型（通俗地说，就是指键与值的类型并不相同）。事实上，Java 的类型系统还没有强大到足以表达这一点。但我们知道这是事实，并在获取 favorite 的时候利用了这一点。</p><p>putFavorite 方法的实现很简单：它只是把（从指定的 Class 对象到指定的 favorite 实例）一个映射放到 favorites 中。如前所述，这是放弃了键和值之间的“类型联系”，因此无法知道这个值是键的一个实例。但是没关系，因为 getFavorites 方法能够并且的确重新建立了这种联系。</p><p>getFavorite 方法的实现比 putFavorite 的更难一些。它先从 favorites 映射中获得与指定 Class 对象相对应的值。这正是要返回的对象引用，但它的编译时类型是错误的。它的类型只是 Object（favorites 映射的值类型），我们需要返回一个 T。因此，getFavorite 方法的实现利用 Class 的 cast 方法，将对象引用动态地转换成了 Class 对象所表示的类型。</p><p>cast 方法是 Java 的转换操作符的动态模拟。它只检验它的参数是否为 Class 对象所表示的类型的实例。如果是，就返回参数；否则就抛出 ClassCastException 异常。我们知道 getFavorite 中的 cast 调用永远不会抛出 ClassCastException 异常，并假设客户端代码正确无误地进行了编译。也就是说，我们知道 favorites 映射中的值会始终与键的类型相匹配。</p><p>假设 cast 方法只返回它的参数，那它能为我们做什么呢？cast 方法的签名充分利用了 Class 类被泛型化的这个事实。它的返回类型是 Class 对象的类型参数：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token class-name">T</span> <span class="token function">cast</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这正是 getFavorite 方法所需要的，也正是让我们不必借助于未受检地转换成 T 就能确保 Favorites 类型安全的东西。</p><p>Favorites 类有两种局限性值得注意。首先，恶意的客户端可以很轻松地破坏 Favorites 实例的类型安全，只要以它的原生态形式使用 Class 对象。但会造成客户端代码在编译时产生未受检的警告。这与一般的集合实现，如 HashSet 和 HashMap 并没有什么区别。你可以很容易地利用原生态类型 HashSet 将 String 放进 HashSet&lt;Integer&gt; 中。也就是说，如果愿意付出一点点代价，就可以拥有运行时的类型安全。确保 Favorites 永远不违背它的类型约束条件的方式是，让 putFavorite 方法检验 instance 是否真的是 type 所表示的类型的实例。只需使用一个动态的转换，如下代码所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Achieving runtime type safety with a dynamic cast</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> vold <span class="token function">putFavorite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> type<span class="token punctuation">,</span> <span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  favorites<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>java.util.Collections 中有一些集合包装类釆用了同样的技巧。它们称作 checkedSet、checkedList、checkedMap，诸如此类。除了一个集合（或者映射）之外，它们的静态工厂还采用一个（或者两个）Class 对象。静态工厂属于泛型方法，确保 Class 对象和集合的编译时类型相匹配。包装类给它们所封装的集合增加了具体化。例如，如果有人试图将 Coin 放进你的 Collection&lt;Stamp&gt;，包装类就会在运行时抛出 ClassCastException 异常。用这些包装类在混有泛型和原生态类型的应用程序中追溯“是谁把错误的类型元素添加到了集合中”很有帮助。</p><p>Favorites 类的第二种局限性在于它不能用在不可具体化的类型中。换句话说，你可以保存最喜爱的 String 或者 String []，但不能保存最喜爱的 List&lt;String&gt;。如果试图保存最喜爱的 List&lt;String&gt;，程序就不能进行编译。原因在于你无法为 List&lt;String&gt; 获得一个 Class 对象：List&lt;String&gt;.Class 是个语法错误，这也是件好事。List&lt;String&gt; 和 List&lt;Integer&gt; 共用一个 Class 对象，即 List.class。如果从“类型的字面”上来看，List&lt;String&gt;.class 和 List&lt;Integer&gt;.class 是合法的，并返回了相同的对象引用，这会破坏 Favorites 对象的内部结构。对于这种局限性，还没有完全令人满意的解决办法。</p><p>Favorites 使用的类型令牌是无限制的：getFavorite 和 putFavorite 接受任何 Class 对象。有时可能需要限制那些可以传给方法的类型。这可以通过有限制的类型令牌来实现，它只是一个类型令牌，利用有限制类型参数或者有限制通配符，来限制可以表示的类型。</p><p>注解 API 广泛利用了有限制的类型令牌。例如，这是一个在运行时读取注解的方法。这个方法来自 AnnotatedElement 接口，它通过表示类、方法、域及其他程序元素的反射类型来实现：</p><p><code>public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType);</code></p><p>参数 annotationType 是一个表示注解类型的有限制的类型令牌。如果元素有这种类型的注解，该方法就将它返回；如果没有，则返回 null。被注解的元素本质上是个类型安全的异构容器，容器的键属于注解类型。</p><p>假设你有一个类型为 Class&lt;?&gt; 的对象，并且想将它传给一个需要有限制的类型令牌的方法，例如 getAnnotation。你可以将对象转换成 Class&lt;? extends Annotation&gt;，但是这种转换是非受检的，因此会产生一条编译时警告。幸运的是，类 Class 提供了一个安全（且动态）地执行这种转换的实例方法。该方法称作 asSubclass，它将调用它的 Class 对象转换成用其参数表示的类的一个子类。如果转换成功，该方法返回它的参数；如果失败，则抛出 ClassCastException 异常。</p><p>下面示范如何利用 asSubclass 方法在编译时读取类型未知的注解。这个方法编译时没有出现错误或者警告：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Use of asSubclass to safely cast to a bounded type token</span>
<span class="token keyword">static</span> <span class="token class-name">Annotation</span> <span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">AnnotatedElement</span> element<span class="token punctuation">,</span> <span class="token class-name">String</span> annotationTypeName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Unbounded type token</span>
  <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> annotationType <span class="token operator">=</span> nul1<span class="token punctuation">;</span>  
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
		annotationType <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>annotationTypeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> element<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>annotationType<span class="token punctuation">.</span><span class="token function">asSubclass</span><span class="token punctuation">(</span><span class="token class-name">Annotation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总而言之，集合 API 说明了泛型的一般用法，限制每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用 Class 对象作为键。以这种方式使用的 Class 对象称作类型令牌。你也可以使用定制的键类型。例如，用一个 DatabaseRow 类型表示一个数据库行（容器），用泛型 Column&lt;T&gt; 作为它的键。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Effective Java/第5章 泛型.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Effective%20Java/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.html" class="nav-link prev" aria-label="第 4 章 类和接口"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 4 章 类和接口</div></a><a href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html" class="nav-link next" aria-label="第 6 章 枚举和注解"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 6 章 枚举和注解<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
