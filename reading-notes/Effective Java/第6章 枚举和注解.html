<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 6 章 枚举和注解"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-06T09:11:40.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-06T09:11:40.000Z"><title>第 6 章 枚举和注解 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link active" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Effective Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC2%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 创建和销毁对象"><!---->第 2 章 创建和销毁对象<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC3%E7%AB%A0%20%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对于所有对象都通用的方法"><!---->第 3 章 对于所有对象都通用的方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类和接口"><!---->第 4 章 类和接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 泛型"><!---->第 5 章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 6 章 枚举和注解"><!---->第 6 章 枚举和注解<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-34-条-用-enum-代替-int-常量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 34 条：用 enum 代替 int 常量"><!---->第 34 条：用 enum 代替 int 常量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-35-条-用实例域代替序数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 35 条：用实例域代替序数"><!---->第 35 条：用实例域代替序数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-36-条-用-enumset-代替位域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 36 条：用 EnumSet 代替位域"><!---->第 36 条：用 EnumSet 代替位域<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-37-条-用-enummap-代替序数索引" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 37 条：用 EnumMap 代替序数索引"><!---->第 37 条：用 EnumMap 代替序数索引<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-38-条-用接口模拟可扩展的枚举" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 38 条：用接口模拟可扩展的枚举"><!---->第 38 条：用接口模拟可扩展的枚举<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-39-条-注解优先于命名模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 39 条：注解优先于命名模式"><!---->第 39 条：注解优先于命名模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-40-条-坚持使用-override-注解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 40 条：坚持使用 Override 注解"><!---->第 40 条：坚持使用 Override 注解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-41-条-用标记接口定义类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="第 41 条：用标记接口定义类型"><!---->第 41 条：用标记接口定义类型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 Lambda 和 Stream"><!---->第 7 章 Lambda 和 Stream<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC8%E7%AB%A0%20%E6%96%B9%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章方法"><!---->第 8 章方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC9%E7%AB%A0%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章通用编程"><!---->第 9 章通用编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC10%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章异常"><!---->第 10 章异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC11%E7%AB%A0%20%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章并发"><!---->第 11 章并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Effective%20Java/%E7%AC%AC12%E7%AB%A0%20%E5%BA%8F%E5%88%97%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章序列化"><!---->第 12 章序列化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 6 章 枚举和注解</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月16日</span><meta property="datePublished" content="2022-06-16T01:04:26.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 56 分钟</span><meta property="timeRequired" content="PT56M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 16885 字</span><meta property="wordCount" content="16885"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-34-条-用-enum-代替-int-常量" class="router-link-active router-link-exact-active toc-link level2">第 34 条：用 enum 代替 int 常量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-35-条-用实例域代替序数" class="router-link-active router-link-exact-active toc-link level2">第 35 条：用实例域代替序数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-36-条-用-enumset-代替位域" class="router-link-active router-link-exact-active toc-link level2">第 36 条：用 EnumSet 代替位域</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-37-条-用-enummap-代替序数索引" class="router-link-active router-link-exact-active toc-link level2">第 37 条：用 EnumMap 代替序数索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-38-条-用接口模拟可扩展的枚举" class="router-link-active router-link-exact-active toc-link level2">第 38 条：用接口模拟可扩展的枚举</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-39-条-注解优先于命名模式" class="router-link-active router-link-exact-active toc-link level2">第 39 条：注解优先于命名模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-40-条-坚持使用-override-注解" class="router-link-active router-link-exact-active toc-link level2">第 40 条：坚持使用 Override 注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Effective%20Java/%E7%AC%AC6%E7%AB%A0%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3.html#第-41-条-用标记接口定义类型" class="router-link-active router-link-exact-active toc-link level2">第 41 条：用标记接口定义类型</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-6-章-枚举和注解" tabindex="-1"><a class="header-anchor" href="#第-6-章-枚举和注解" aria-hidden="true">#</a> 第 6 章 枚举和注解</h1><p>Java 支持两种特殊用途的引用类型：一种是类，称作枚举类型；一种是接口，称作注解类型。本章将讨论这两个新类型的最佳使用实践。</p><h2 id="第-34-条-用-enum-代替-int-常量" tabindex="-1"><a class="header-anchor" href="#第-34-条-用-enum-代替-int-常量" aria-hidden="true">#</a> 第 34 条：用 enum 代替 int 常量</h2><p>枚举类型是指由一组固定的常量组成合法值的类型，例如一年中的季节、太阳系中的行星或者一副牌中的花色。在 Java 编程语言引入枚举类型之前，通常是用一组 int 常量来表示枚举类型，其中每一个 int 常量表示枚举类型的一个成员：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The int enum pattern - severely deficient!</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> APPLE_FUJI <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> APPLE_PIPPIN <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> APPLE_GRANNY_SMITH <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ORANGE_NAVEL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ORANGE_TEMPLE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ORANGE_BLOOD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法称作 int 枚举模式，它存在着很多不足。int 枚举模式不具有类型安全性，也几乎没有描述性可言。例如你将 apple 传到想要 orange 的方法中，编译器也不会发出警告，还会用 == 操作符对 apple 与 orange 进行比较，甚至更糟糕：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Tasty citrus flavored applesauce!</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>APPLE_FUJI <span class="token operator">-</span> ORANGE_TEMPLE<span class="token punctuation">)</span> <span class="token operator">/</span> APPLE_PIPPIN<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意每个 apple 常量的名称都以 APPLE_ 作为前缀，每个 orange 常量的名称则都以 ORANGE_ 作为前缀。这是因为 Java 没有为 int 枚举组提供命名空间。当两个 int 枚举组具有相同的命名常量时，前缀可以防止名称发生冲突，如使用 ELEMENT_MERCURY 和 PLANET_MERCURY 避免名称冲突。</p><p>釆用 int 枚举模式的程序是十分脆弱的。因为 int 枚举是编译时常量，它们的 int 值会被编译到使用它们的客户端中。如果与 int 枚举常量关联的值发生了变化，客户端必须重新编译。如果没有重新编译，客户端程序还是可以运行，不过其行为已经不再准确。</p><p>很难将 int 枚举常量转换成可打印的字符串。就算将这种常量打印出来，或者从调试器中将它显示出来，你所见到的也只是一个数字，这几乎没有什么用处。当需要遍历一个 int 枚举模式中的所有常量，以及获得 int 枚举数组的大小时，在 int 枚举模式中，几乎不存在可靠的方式。</p><p>这种模式还有一种变体，它使用的是 String 常量，而不是 int 常量。这样的变体被称作 String 枚举模式，同样也不是我们期望的。它虽然为这些常量提供了可打印的字符串，但是会导致初级用户直接把字符串常量硬编码到客户端代码中，而不是使用对应的常量字段名。一旦这样的硬编码字符串常量中包含书写错误，在编译时不会被检测到，但是在运行的时候却会报错。而且它会导致性能问题，因为它依赖于字符串的比较操作。</p><p>幸运的是，Java 提供了另一种替代的解决方案，可以避免 int 和 String 枚举模式的缺点，并提供更多的好处。这就是枚举类型。下面以最简单的形式演示了这种模式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>
    FUJI<span class="token punctuation">,</span> PIPPIN<span class="token punctuation">,</span> CRANNY_SMITH
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Orange</span> <span class="token punctuation">{</span>
    NAVEL<span class="token punctuation">,</span> TEMPLE<span class="token punctuation">,</span> BLOOD
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表面上看来，这些枚举类型与其他语言中的没有什么两样，例如 C、C++ 和 C#，但是实际上并非如此。Java 的枚举类型是功能十分齐全的类，其功能比其他语言中的对应类强大得多，Java 的枚举本质上是 int 值。</p><p>Java 枚举类型的基本想法非常简单：这些类通过公有的静态 final 域为每个枚举常量导出一个实例。枚举类型没有可以访问的构造器，所以它是真正的 final 类。客户端不能创建枚举类型的实例，也不能对它进行扩展，因此不存在实例，而只存在声明过的枚举常量。换句话说，枚举类型是实例受控的。它们是单例的泛型化，本质上是单元素的枚举。</p><p>枚举类型保证了编译时的类型安全。例如声明参数的类型为 Apple，它就能保证传到该参数上的任何非空的对象引用一定属于三个有效的 Apple 值之一，而其他任何试图传递类型错误的值都会导致编译时错误，就像试图将某种枚举类型的表达式赋给另一种枚举类型的变量，或者试图利用 == 操作符比较不同枚举类型的值都会导致编译时错误。</p><p>包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。你可以增加或者重新排列枚举类型中的常量，而无须重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端之间提供了一个隔离层：常量值并没有被编译到客户端代码中，而是在 int 枚举模式之中。最终，可以通过调用 toString 方法，将枚举转换成可打印的字符串。</p><p>除了完善 int 枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。它们提供了所有 Object 方法的高级实现，实现了 Comparable 和 Serializable 接口，并针对枚举类型的可任意改变性设计了序列化方式。</p><p>那么我们为什么要向枚举类型中添加方法或者域呢？首先，可能是想将数据与它的常量关联起来。例如，一个能够返回水果颜色或者返回水果图片的方法，对于我们的 Apple 和 Orange 类型就很有必要。你可以利用任何适当的方法来增强枚举类型。枚举类型可以先作为枚举常量的一个简单集合，随着时间的推移再演变成为全功能的抽象。</p><p>举个有关枚举类型的例子，比如太阳系中的 8 颗行星。每颗行星都有质量和半径，通过这两个属性可以计算出它的表面重力。从而给定物体的质量，进而计算出一个物体在行星表面上的重量。下面就是这个枚举。每个枚举常量后面括号中的数值就是传递给构造器的参数。在这个例子中，它们就是行星的质量和半径：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Enum type with data and behavior</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Planet</span> <span class="token punctuation">{</span>
    <span class="token function">MERCURY</span><span class="token punctuation">(</span><span class="token number">3.302e+23</span><span class="token punctuation">,</span> <span class="token number">2.439e6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">VENUS</span><span class="token punctuation">(</span><span class="token number">4.869e+24</span><span class="token punctuation">,</span> <span class="token number">6.052e6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">EARTH</span><span class="token punctuation">(</span><span class="token number">5.975e+24</span><span class="token punctuation">,</span> <span class="token number">6.378e6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">MARS</span><span class="token punctuation">(</span><span class="token number">6.419e+23</span><span class="token punctuation">,</span> <span class="token number">3.393e6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">JUPITER</span><span class="token punctuation">(</span><span class="token number">1.899e+27</span><span class="token punctuation">,</span> <span class="token number">7.149e7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SATURN</span><span class="token punctuation">(</span><span class="token number">5.685e+26</span><span class="token punctuation">,</span> <span class="token number">6.027e7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">URANUS</span><span class="token punctuation">(</span><span class="token number">8.683e+25</span><span class="token punctuation">,</span> <span class="token number">2.556e7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">NEPTUNE</span><span class="token punctuation">(</span><span class="token number">1.024e+26</span><span class="token punctuation">,</span> <span class="token number">2.477e7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// In kilograms</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> mass<span class="token punctuation">;</span>
    <span class="token comment">// In meters</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> radius<span class="token punctuation">;</span>
    <span class="token comment">// In m / s^2</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> surfaceGravity<span class="token punctuation">;</span>
    <span class="token comment">// Universal gravitational constant in m^3 / kg s^2</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> <span class="token class-name">G</span> <span class="token operator">=</span> <span class="token number">6.67300E-11</span><span class="token punctuation">;</span>

    <span class="token comment">// Constructor</span>
    <span class="token class-name">Planet</span><span class="token punctuation">(</span><span class="token keyword">double</span> mass<span class="token punctuation">,</span> <span class="token keyword">double</span> radius<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>mass <span class="token operator">=</span> mass<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
        surfaceGravity <span class="token operator">=</span> <span class="token class-name">G</span> <span class="token operator">*</span> mass <span class="token operator">/</span> <span class="token punctuation">(</span>radius <span class="token operator">*</span> radius<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">mass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mass<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">radius</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> radius<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">surfaceGravity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> surfaceGravity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">surfaceWeight</span><span class="token punctuation">(</span><span class="token keyword">double</span> mass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// F = ma</span>
        <span class="token keyword">return</span> mass <span class="token operator">*</span> surfaceGravity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编写一个像 Planet 这样的枚举类型并不难。为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。枚举天生就是不可变的，因此所有的域都应该为 final 的。它们可以是公有的，但最好将它们做成私有的，并提供公有的访问方法。在 Planet 这个示例中，构造器还计算和保存表面重力，但这正是一种优化。每当 surfaceWeight 方法用到重力时，都会根据质量和半径重新计算，并返回它在该常量所表示的行星上的重量。</p><p>虽然 Planet 枚举很简单，但它的功能强大得出奇。下面是一个简短的程序，根据某个物体在地球上的重量（以任何单位），打印出一张很棒的表格，显示出该物体在所有 8 颗行星上的重量（用相同的单位）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeightTable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">double</span> earthWeight <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">double</span> mass <span class="token operator">=</span> earthWeight <span class="token operator">/</span> <span class="token class-name">Planet</span><span class="token punctuation">.</span>EARTH<span class="token punctuation">.</span><span class="token function">surfaceGravity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Planet</span> p <span class="token operator">:</span> <span class="token class-name">Planet</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Weight on %s is %f%n&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> p<span class="token punctuation">.</span><span class="token function">surfaceWeight</span><span class="token punctuation">(</span>mass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意就像所有的枚举一样，Planet 有一个静态的 values 方法，按照声明顺序返回它的值数组。toString 方法返回每个枚举值的声明名称，使得 println 和 printf 的打印变得更加容易。如果你不满意这种字符串表不法，可以通过覆盖 toString 方法对它进行修改。下面就是带命令行参数为 185 来运行这个小小的 WeightTable 程序（没有覆盖 toString 方法）时的结果：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Weight</span> on MERCURY is <span class="token number">69.912739</span>
<span class="token class-name">Weight</span> on VENUS is <span class="token number">167.434436</span>
<span class="token class-name">Weight</span> on EARTH is <span class="token number">185.000000</span>
<span class="token class-name">Weight</span> on MARS is <span class="token number">70.226739</span>
<span class="token class-name">Weight</span> on JUPITER is <span class="token number">467.990696</span>
<span class="token class-name">Weight</span> on SATURN is <span class="token number">197.120111</span>
<span class="token class-name">Weight</span> on URANUS is <span class="token number">167.398264</span>
<span class="token class-name">Weight</span> on NEPTUNE is <span class="token number">210.208751</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直到 2006 年，即 Java 中增加了枚举的两年之后，当时冥王星 Pluto 还属于行星。这引发出一个问题：当把一个元素从一个枚举类型中移除时，会发生什么情况呢？答案是：没有引用该元素的任何客户端程序都会继续正常工作。因此，我们的 WeightTable 程序只会打印出一个少了一行的表格而已。对于引用了被删除元素（如本例中是指 Planet.Pluto）的客户端程序又如何呢？如果重新编译客户端程序，就会失败，并在引用被删除行星的那一条出现一条错误消息；如果没有重新编译客户端代码，在运行时就会在这一行抛出一个异常。这是你能期待的最佳行为了，远比使用 int 枚举模式时要好得多。</p><p>有些与枚举常量相关的行为，可能只会用在枚举类型的定义类或者所在的包中，那么这些方法最好被实现成私有的或者包级私有的。于是每个枚举常量都带有一组隐藏的行为，这使得枚举类型的类或者所在的包能够运作得很好，像其他的类一样，除非要将枚举方法导出至它的客户端，否则都应该声明为私有的，或者声明为包级私有的。</p><p>如果一个枚举具有普遍适用性，它就应该成为一个顶层类；如果它只是被用在一个特定的顶层类中，它就应该成为该顶层类的一个成员类。例如，java.math.RoundingMode 枚举表示十进制小数的舍入模式。这些舍入模式被用于 BigDecimal 类，但是它们却不属于 BigDecimal 类的一个抽象。通过使 RoundingMode 变成一个顶层类，库的设计者鼓励任何需要舍入模式的程序员重用这个枚举，从而增强 API 之间的一致性。</p><p>Planet 示例中所示的方法对于大多数枚举类型来说就足够了，但有时候我们会需要更多的方法。每个 Planet 常量关联了不同的数据，但你有时需要将不同的行为与每个常量关联起来。例如，假设你在编写一个枚举类型，来表示计算器的四大基本操作（即加减乘除），你想要提供一个方法来执行每个常量所表示的算术运算。有一种方法是通过启用枚举的值来实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Enum type that switches on its own value - questionable</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    PLUS<span class="token punctuation">,</span> MINUS<span class="token punctuation">,</span> TIMES<span class="token punctuation">,</span> DIVIDE<span class="token punctuation">;</span>

    <span class="token comment">// Do the arithmetic operation represented by this constant</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> PLUS<span class="token operator">:</span>
                <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> MINUS<span class="token operator">:</span>
                <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> TIMES<span class="token operator">:</span>
                <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
            <span class="token keyword">case</span> DIVIDE<span class="token operator">:</span>
                <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown op:&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码能用，但是不太好看。如果没有 throw 语句，它就不能进行编译，虽然从技术角度来看代码的结束部分是可以执行到的，但是实际上是不可能执行到这行代码的。更糟糕的是，这段代码很脆弱。如果你添加了新的枚举常量，却忘记给 switch 添加相应的条件，枚举仍然可以编译，但是当你试图运用新的运算时，就会运行失败。</p><p>幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的 apply 方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象 apply 方法。这种方法被称作特定于常量的方法实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Enum type with constant-specific method implementations</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    PLUS <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    MINUS <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    TIMES <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    DIVIDE <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果给 Operation 的第二种版本添加新的常量，你就不可能会忘记提供 apply 方法，因为该方法紧跟在每个常量声明之后。即使你真的忘记了，编译器也会提醒你，因为枚举类型中的抽象方法必须被它的所有常量中的具体方法所覆盖。</p><p>特定于常量的方法实现可以与特定于常量的数据结合起来。例如，下面的 Operation 覆盖了 toString 方法以返回通常与该操作关联的符号：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Enum type with constant-specific class bodies and data</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token function">PLUS</span><span class="token punctuation">(</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">MINUS</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">TIMES</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">DIVIDE</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>

    <span class="token class-name">Operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述的 toString 实现使得打印算术表达式变得非常容易。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> <span class="token class-name">Operation</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f %s %f = %f%n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 2 和 4 作为命令行参数来运行这段程序。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">2.000000</span> <span class="token operator">+</span> <span class="token number">4.000000</span> <span class="token operator">=</span> <span class="token number">6.000000</span>
<span class="token number">2.000000</span> <span class="token operator">-</span> <span class="token number">4.000000</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2.000000</span>
<span class="token number">2.000000</span> <span class="token operator">*</span> <span class="token number">4.000000</span> <span class="token operator">=</span> <span class="token number">8.000000</span>
<span class="token number">2.000000</span> <span class="token operator">/</span> <span class="token number">4.000000</span> <span class="token operator">=</span> <span class="token number">0.500000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>枚举类型有一个自动产生的 valueOf(String) 方法，它将常量的名字转成常量本身。如果在枚举类型中覆盖 toString，要考虑编写一个 fromString 方法，将定制的字符串表示法变回相应的枚举。下列代码（适当地改变了类型名称）可以为任何枚举完成这一技巧，只要每个常量都有一个独特的字符串表示法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Implementing a fromString method on an enum type</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> stringToEnum <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token operator">::</span><span class="token function">toString</span><span class="token punctuation">,</span> e <span class="token operator">-&gt;</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Returns Operation for String, if any</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token function">fromString</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>stringToEnum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在枚举常量被创建之后，Operation 常量从静态代码块中被放入到了 StringToEnum 的映射中。前面的代码在 values() 方法返回的数组上使用流；在 Java 8 之前，我么将创建一个空的散列映射并遍历 values 数组，将字符串到枚举的映射插入到映射中。但是，试图使每个常量都从自身的构造器放入自身的映射中是不起作用的。它会导致编译错误，因为如果这是合法的，可能会引发 NullPointerException 异常。除了编译时常量域之外，枚举构造器不可以访问枚举的静态域。这一限制时有必要的，因为构造器运行的时候，这些静态域还没有被初始化。这条限制有一个特例：枚举常量无法通过其构造器访问另一个构造器。</p><p>还要注意返回的 Optional&lt;Operation&gt; 的 fromString 方法。它用该方法表明：传入的字符串并不代表一项有效的操作，并强制客户端面对这种可能性。</p><p>特定于常量的方法实现有一个美中不足的地方，它们使得在枚举常量中共享代码变得更加困难了。例如，考虑用一个枚举表示薪资包中的工作天数。这个枚举有一个方法，根据给定的某工人的基本工资（按小时）以及当天的工作时间，来计算他当天的报酬。在五个工作日中，超过正常八小时的工作时间都会产生加班工资；在节假日中，所有工作都产生加班工资。利用 switch 语句，很容易通过将多个 case 标签分别应用到两个代码片段中，来完成这一计算：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Enum that switches on its value to share code - questionable</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PayrollDay</span> <span class="token punctuation">{</span>
    MONDAY<span class="token punctuation">,</span> TUESDAY<span class="token punctuation">,</span> WEDNESDAY<span class="token punctuation">,</span> THURSDAY<span class="token punctuation">,</span> FRIDAY<span class="token punctuation">,</span> SATURDAY<span class="token punctuation">,</span> SUNDAY<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MINS_PER_SHIFT <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">pay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minutesWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> basePay <span class="token operator">=</span> minutesWorked <span class="token operator">*</span> payRate<span class="token punctuation">;</span>
        <span class="token keyword">int</span> overtimePay<span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Weekend</span>
            <span class="token keyword">case</span> SATURDAY<span class="token operator">:</span>
            <span class="token keyword">case</span> SUNDAY<span class="token operator">:</span>
                overtimePay <span class="token operator">=</span> basePay <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment">// Weekday</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                overtimePay <span class="token operator">=</span> minutesWorked <span class="token operator">&lt;=</span> MINS_PER_SHIFT <span class="token operator">?</span>
                        <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>minutesWorked <span class="token operator">-</span> MINS_PER_SHIFT<span class="token punctuation">)</span> <span class="token operator">*</span> payRate <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> basePay <span class="token operator">+</span> overtimePay<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不可否认，这段代码十分简洁，但是从维护的角度来看，它非常危险。假设将一个元素添加到该枚举中，或许是一个表示假期天数的特殊值，但是忘记给 switch 语句添加相应的 case。程序依然可以编译，但 pay 方法会悄悄地将节假日的工资计算成正常工作日的工资。</p><p>为了利用特定于常量的方法实现安全地执行工资计算，你可能必须重复计算每个常量的加班工资，或者将计算移到两个辅助方法中（一个用来计算工作日，一个用来计算节假日），并从每个常量调用相应的辅助方法。任何一种方法都会产生相当数量的样板代码，这会降低可读性，并增加了出错的概率。</p><p>通过用计算工作日加班工资的具体方法来代替 PayrollDay 中抽象的 overtimePay 方法，可以减少样板代码。这样，就只有节假日必须覆盖该方法了。但是这样也有着与 switch 语句一样的不足：如果又增加了一天而没有覆盖。overtimePay 方法，就会悄悄地延续工作日的计算。</p><p>我们真正想要的就是每当添加一个枚举常量时，就强制选择一种加班报酬策略。幸运的是，有一种很好的方法可以实现这一点。这种想法就是将加班工资计算移到一个私有的嵌套枚举中，将这个策略枚举的实例传到 PayrollDay 枚举的构造器中。之后 PayrollDay 枚举将加班工资计算委托给策略枚举，PayrollDay 中就不需要 switch 语句或者特定于常量的方法实现了。虽然这种模式没有 switch 语句那么简洁，但更加安全，也更加灵活：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// The strategy enum pattern</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PayrollDay2</span> <span class="token punctuation">{</span>
    MONDAY<span class="token punctuation">,</span> TUESDAY<span class="token punctuation">,</span> WEDNESDAY<span class="token punctuation">,</span> THURSDAY<span class="token punctuation">,</span> FRIDAY<span class="token punctuation">,</span> <span class="token function">SATURDAY</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span>WEEKEND<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUNDAY</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span>WEEKEND<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PayType</span> payTape<span class="token punctuation">;</span>

    <span class="token class-name">PayrollDay2</span><span class="token punctuation">(</span><span class="token class-name">PayType</span> payTape<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>payTape <span class="token operator">=</span> payTape<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Default</span>
    <span class="token class-name">PayrollDay2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token class-name">PayType</span><span class="token punctuation">.</span>WEEKEND<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">pay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minutesWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> payTape<span class="token punctuation">.</span><span class="token function">pay</span><span class="token punctuation">(</span>minutesWorked<span class="token punctuation">,</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// The strategy enum type</span>
    <span class="token keyword">private</span> <span class="token keyword">enum</span> <span class="token class-name">PayType</span> <span class="token punctuation">{</span>
        WEEKDAY <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> minsWorked <span class="token operator">&lt;=</span> MINS_PER_SHIFT <span class="token operator">?</span>
                        <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>minsWorked <span class="token operator">-</span> MINS_PER_SHIFT<span class="token punctuation">)</span> <span class="token operator">*</span> payRate <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        WEEKEND <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minsWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> minsWorked <span class="token operator">*</span> payRate <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span><span class="token keyword">int</span> mins<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MINS_PER_SHIFT <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> <span class="token function">pay</span><span class="token punctuation">(</span><span class="token keyword">int</span> minutesWorked<span class="token punctuation">,</span> <span class="token keyword">int</span> payRate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> basePay <span class="token operator">=</span> minutesWorked <span class="token operator">*</span> payRate<span class="token punctuation">;</span>
            <span class="token keyword">return</span> basePay <span class="token operator">+</span> <span class="token function">overtimePay</span><span class="token punctuation">(</span>minutesWorked<span class="token punctuation">,</span> payRate<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果枚举中的 switch 语句不是在枚举中实现特定于常量的行为的一种很好的选择，那么它们还有什么用处呢？枚举中的 switch 语句适合于给外部的枚举类型增加特定于常量的行为。例如，假设 Operation 枚举不受你的控制，你希望它有一个实例方法来返回每个运算的反运算。你可以用下列静态方法模拟这种效果：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Switch on an enum to simulate a missing method</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Operation</span> <span class="token function">inverse</span><span class="token punctuation">(</span><span class="token class-name">Operation</span> op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> PLUS<span class="token operator">:</span> 
      <span class="token keyword">return</span> <span class="token class-name">Operation</span><span class="token punctuation">.</span>MINUS<span class="token punctuation">;</span>
    <span class="token keyword">case</span> MINUS<span class="token operator">:</span> 
      <span class="token keyword">return</span> <span class="token class-name">Operation</span><span class="token punctuation">.</span>PLUS<span class="token punctuation">;</span>
    <span class="token keyword">case</span> TIMES<span class="token operator">:</span> 
      <span class="token keyword">return</span> <span class="token class-name">Operation</span><span class="token punctuation">.</span>DIVIDE<span class="token punctuation">;</span>
    <span class="token keyword">case</span> DIVIDE<span class="token operator">:</span> 
      <span class="token keyword">return</span> <span class="token class-name">Operation</span><span class="token punctuation">.</span>TIMES<span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token string">&quot;Unknown op: &quot;</span> <span class="token operator">+</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果一个方法不属于枚举类型，也应该在你所能控制的枚举类型上使用这种方法。这种方法有点用处，但是通常还不值得将它包含到枚举类型中去。</p><p>一般来说，枚举通常在性能上与 int 常量相当。与 int 常量相比，枚举有个小小的性能缺点，即装载和初始化枚举时会需要空间和时间的成本，但在实践中几乎注意不到这个问题。</p><p>那么什么时候应该使用枚举呢？每当需要一组固定常量，并且在编译时就知道其成员的时候，就应该使用枚举。当然，这包括“天然的枚举类型”，例如行星、一周的天数以及棋子的数目等。但它也包括你在编译时就知道其所有可能值的其他集合，例如菜单的选项、操作代码以及命令行标记等。枚举类型中的常量集并不一定要始终保持不变。专门设计枚举特性是考虑到枚举类型的二进制兼容演变。</p><p>总而言之，与 int 常量相比，枚举类型的优势是不言而喻的。枚举的可读性更好，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于属性与每个常量的关联以及其行为受该属性影响的方法。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个（但非所有）枚举常量同时共享相同的行为，则要考虑策略枚举。</p><h2 id="第-35-条-用实例域代替序数" tabindex="-1"><a class="header-anchor" href="#第-35-条-用实例域代替序数" aria-hidden="true">#</a> 第 35 条：用实例域代替序数</h2><p>许多枚举天生就与一个单独的 int 值相关联。所有的枚举都有一个 ordinal 方法，它返回每个枚举常量在类型中的数字位置。你可以试着从序数中得到关联的 int 值：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Abuse of ordinal to derive an associated value - DON&#39;T DO THIS</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Ensemble</span> <span class="token punctuation">{</span>
    SOLO<span class="token punctuation">,</span> DUET<span class="token punctuation">,</span> TRIO<span class="token punctuation">,</span> QUARTET<span class="token punctuation">,</span> QUINTET<span class="token punctuation">,</span>
    SEXTET<span class="token punctuation">,</span> SEPTET<span class="token punctuation">,</span> OCTET<span class="token punctuation">,</span> NONET<span class="token punctuation">,</span> DECTET<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfMusicians</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然这个枚举工作得不错，但是维护起来就像一场噩梦。如果常量进行重新排序，numberOfMusicians 方法就会遭到破坏。如果要再添加一个与已经用过的 int 值关联的枚举常量，就没那么走运了。例如，给双四重奏添加一个常量，它就像个八重奏一样，是由 8 位演奏家组成，但是没有办法做到。</p><p>而且，要是没有给所有这些 int 值添加常量，也无法给某个比七值添加常量。例如，假设想要添加一个常量表示三四重奏，它由 12 位演奏家组成。对于由 11 位演奏家组成的合奏曲并没有标准的术语，因此只好给没有用过的 int 值添加一个虚拟常量。这么做顶多就是不太好看。如果有许多 int 值都是从未用过的，可就不切实际了。</p><p>幸运的是，有一种很简单的方法可以解决这些问题。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Ensemble</span> <span class="token punctuation">{</span>
    <span class="token function">SOLO</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DUET</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TRIO</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QUARTET</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QUINTET</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SEXTET</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SEPTET</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">OCTET</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DOUBLE_QUARTET</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">NONET</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DECTET</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TRIPLE_QUARTET</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> numberOfMusicians<span class="token punctuation">;</span>

    <span class="token class-name">Ensemble2</span><span class="token punctuation">(</span><span class="token keyword">int</span> numberOfMusicians<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>numberOfMusicians <span class="token operator">=</span> numberOfMusicians<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfMusicians</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> numberOfMusicians<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Enum 规范中谈及 ordinal 方法时写道：“大多数程序员都不需要这个方法。它是设计用于像 EnumSet 和 EnumMap 这种基于枚举的通用数据结构的。”除非你在编写的是这种数据结构，否则最好完全避免使用 ordinal 方法。</p><h2 id="第-36-条-用-enumset-代替位域" tabindex="-1"><a class="header-anchor" href="#第-36-条-用-enumset-代替位域" aria-hidden="true">#</a> 第 36 条：用 EnumSet 代替位域</h2><p>如果一个枚举类型的元素主要用在集合中，一般就使用 int 枚举模式，比如将 2 的不同倍数赋予每个常量：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Bit field enumeration constants - OBSOLETE!</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STYLE_BOLD <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 2</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STYLE_ITALIC <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 4</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STYLE_UNDERLINE <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 8</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STYLE_STRIKETHROUGH <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
  
  <span class="token comment">// Parameter is bitwise OR of zero or more STYLE_constants</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token keyword">int</span> styles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种表示法让你用 OR 位运算将几个常量合并到一个集合中，称作位域：</p><p><code>text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</code></p><p>位域表示法也允许利用位操作，有效地执行像 union 和 intersection 这样的集合操作。但位域具有 int 枚举常量的所有缺点，甚至更多。当位域以数字形式打印时，翻译位域比翻译简单的 int 枚举常量要困难得多。要遍历位域表示的所有元素也没有很容易的方法。最后一点，在编写 API 的时候，就必须先预测最多需要多少位，同时还要给位域选择对应的类型（一般是 int 或者 long）。一旦选择好类型，在没有修改 API 的情况下，将不能超出其位宽度（如 32 位或者 64 位）。</p><p>有些程序员虽然更倾向于使用枚举而非 int 常量，但是他们在需要传递多组常量集时，仍然倾向于使用位域。其实没有理由这么做，因为还有更好的替代方法。java.util 包提供了 EnumSet 类来有效地表示从单个枚举类型中提取的多个值的多个集合。这个类实现 Set 接口，提供了丰富的功能、类型安全性，以及可以从任何其他 Set 实现中得到的互用性。但是在内部具体的实现上，每个 EnumSet 内容都表示为位矢量。如果底层的枚举类型有 64 个或者更少的元素（大多如此）整个 EnumSet 就使用单个 long 来表示，因此它的性能比得上位域的性能。批处理操作，如 removeAll 和 retainAll，都是利用位算法来实现的，就像手工替位域实现的那样。但是可以避免手工位操作时容易出现的错误以及丑陋的代码，因为 EnumSet 替你完成了这项艰巨的工作。</p><p>下面是前一个范例改成用枚举代替位域之后的代码，它更加简短、更加清楚，也更加安全：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// EnumSet - a modern replacement for bit fields</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text2</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Style</span> <span class="token punctuation">{</span>
        BOLD<span class="token punctuation">,</span> ITALIC<span class="token punctuation">,</span> UNDERLINE<span class="token punctuation">,</span> STRIKETHROUGH
    <span class="token punctuation">}</span>

    <span class="token comment">// Any set could by passed in, but EnumSet is clearly best</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">applyStyles</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Style</span><span class="token punctuation">&gt;</span></span> styles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是将 EnumSet 实例传递给 applyStyles 方法的客户端代码。EnumSet 提供了丰富的静态工厂来轻松创建集合，其中一个如下代码所示：</p><p><code>text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</code></p><p>注意 applyStyles 方法采用的是 Set&lt;Style&gt; 而非 EnumSet&lt;Style&gt;。虽然看起来好像所有的客户端都可以将 EnumSet 传到这个方法，但是最好还是接受接口类型而非接受实现类型。这是考虑到可能会有特殊的客户端需要传递一些其他的 Set 实现。</p><p>总而言之，正是因为枚举类型要用在集合中，所以没有理由用位域来表示它。EnumSet 类集位域的简洁和性能优势及第 34 条中所述的枚举类型的所有优点于一身。实际上 EnumSet 有个缺点，即截止 Java 9 发行版本，它都无法创建不可变的 EnumSet，但是这一点很可能在即将发布的版本中得到修正。同时，可以用 Collections.unmodifiableSet 将 EnumSet 封装起来，但是简洁性和性能会受到影响。</p><h2 id="第-37-条-用-enummap-代替序数索引" tabindex="-1"><a class="header-anchor" href="#第-37-条-用-enummap-代替序数索引" aria-hidden="true">#</a> 第 37 条：用 EnumMap 代替序数索引</h2><p>有时你可能会见到利用 ordinal 方法来索引数组或列表的代码。例如下面这个超级简化的类，用来表示一种烹饪用的香草：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Plant</span> <span class="token punctuation">{</span>
    <span class="token keyword">enum</span> <span class="token class-name">LifeCycle</span> <span class="token punctuation">{</span> ANNUAL<span class="token punctuation">,</span> PERENNIAL<span class="token punctuation">,</span> BIENNIAL <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">LifeCycle</span> lifeCycle<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Plant</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">LifeCycle</span> lifeCycle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>lifeCycle <span class="token operator">=</span> lifeCycle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在假设有一个香草的数组，表示一座花园中的植物，你想要按照类型（一年生、多年生或者两年生植物）进行组织之后将这些植物列出来。如果要这么做，需要构建三个集合，每种类型一个，并且遍历整座花园，将每种香草放到相应的集合中。有些程序员会将这些集合放到一个按照类型的序数进行索引的数组中来实现这一点：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using ordinal() to index into an array - DON&#39;T DO THIS!</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> plantsByLifeCycle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">[</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> plantsByLifeCycle<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  plantsByLifeCycle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Plant</span> p <span class="token operator">:</span> garden<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  plantsByLifeCycle<span class="token punctuation">[</span>p<span class="token punctuation">.</span>lifeCycle<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment">// Print the results</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> plantsByLifeCycle<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s: %s%n&quot;</span><span class="token punctuation">,</span> plantsByLifeCycle<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> plantsByLifeCycle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法的确可行，但是隐藏着许多问题。因为数组不能与泛型兼容，程序需要进行未受检的转换，并且不能正确无误地进行编译。因为数组不知道它的索引代表着什么，你必须手工标注这些索引的输出。但是这种方法最严重的问题在于，当你访问一个按照枚举的序数进行索引的数组时，使用正确的 int 值就是你的职责了；int 不能提供枚举的类型安全。你如果使用了错误的值，程序就会悄悄地完成错误的工作，或者幸运的话，会抛出 ArrayIndexOutOfBoundException 异常。</p><p>有一种更好的方法可以达到同样的效果。数组实际上充当着从枚举到值的映射，因此可能还要用到 Map。更具体地说，有一种非常快速的 Map 实现专门用于枚举键，称作 java.util.EnumMap。以下就是用 EnumMap 改写后的程序：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using an EnumMap to associate data with an enum</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Plant</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> plantsByLifeCycle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span> lc <span class="token operator">:</span> <span class="token class-name">Plant<span class="token punctuation">.</span>LifeCycle</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  plantsByLifeCycle<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Plant</span> p <span class="token operator">:</span> garden<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  plantsByLifeCycle<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>lifeCycle<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>plantsByLifeCycle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段程序更简短、更清楚，也更加安全，运行速度方面可以与使用序数的程序相媲美。它没有不安全的转换；不必手工标注这些索引的输出，因为映射键知道如何将自身翻译成可打印字符串的枚举；计算数组索引时也不可能出错。EnumMap 在运行速度方面之所以能与通过序数索引的数组相媲美，正是因为 EnuMap 在内部使用了这种数组。但是它对程序员隐藏了这种实现细节，集 Map 的丰富功能和类型安全与数组的快速于一身。注意 EnumMap 构造器采用键类型的 Class 对象：这是一个有限制的类型令牌，它提供了运行时的泛型信息。</p><p>上一段程序可能比用 stream 管理映射要简短得多。下面是基于 stream 的最简单的代码，大量复制了上一个示例的行为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Naive stream-based approach - unlikely to produce an EnumMap!</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>garden<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">col1ect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span><span class="token function">1ifeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的问题在于它选择自己的映射实现，实际上不会是一个 EnumMap，因此与显式 EnumMap 版本的空间及时间性能并不吻合。为了解决这个问题，要使用有三种参数形式的 Collectors.groupingBy 方法，它允许调用者利用 mapFactory 参数定义映射实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using a stream and an EnumMap to associate data with an enum\</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>garden<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span>lifeCycle<span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">LifeCycle</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这样一个玩具程序中不值得进行这种优化，但是在大量使用映射的程序中就很重要了。</p><p>基于 stream 的代码版本的行为与 EnumMap 版本的稍有不同。EnumMap 版本总是给每一个植物生命周期都设计一个嵌套映射，基于 stream 的版本则仅当花园中包含了一种或多种植物带有该生命周期时才会设计一个嵌套映射。因此，假如花园中包含了一年生和多年生植物，但没有两年生植物，plantsByLifeCycle 的数量在 EnumMap 版本中应该是三种，在基于 stream 的两个版本中则都是两种。</p><p>你还可能见到按照序数进行索引（两次）的数组的数组，该序数表示两个枚举值的映射。例如，下面这个程序就是使用这样一个数组将两个阶段映射到一个阶段过渡中（从液体到固体称作凝固，从液体到气体称作沸腾，诸如此类）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using ordinal() to index array of arrays - DON&#39;T DO THIS!</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">{</span>
    SOLID<span class="token punctuation">,</span> LIQUID<span class="token punctuation">,</span> GAS<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
        MELT<span class="token punctuation">,</span> FREEZE<span class="token punctuation">,</span> BOIL<span class="token punctuation">,</span> CONDENSE<span class="token punctuation">,</span> SUBLIME<span class="token punctuation">,</span> DEPOSIT<span class="token punctuation">;</span>

        <span class="token comment">// Rows indexed by from-ordinal, cols by to-ordinal</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Transition</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> TRANSITIONS <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">,</span> MELT<span class="token punctuation">,</span> SUBLIME<span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>FREEZE<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> BOIL<span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>DEPOSIT<span class="token punctuation">,</span> CONDENSE<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Returns the phase transition from one phase to another</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Transition</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> TRANSITIONS<span class="token punctuation">[</span>from<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段程序可行，看起来也比较优雅，但是事实并非如此。就像上面那个比较简单的香草花园的示例一样，编译器无法知道序数和数组索引之间的关系。如果在过渡表中出了错，或者在修改 Phase 或者 Phase.Transition 枚举类型的时候忘记将它更新，程序就会在运行时失败。这种失败的形式可能为 ArrayIndexOutOfBoundsException、NullPointerException 或者（更糟糕的是）没有任何提示的错误行为。这张表的大小是阶段数的平方，即使非空项的数量比较少。</p><p>同样，利用 EnumMap 依然可以做得更好一些。因为每个阶段过渡都是通过一对阶段枚举进行索引的，最好将这种关系表示为一个映射，这个映射的键是一个枚举（起始阶段），值为另一个映射，这第二个映射的键为第二个枚举（目标阶段），它的值为结果（阶段过渡），即形成了 Map（起始阶段，Map（目标阶段，阶段过渡））这种形式。一个阶段过渡所关联的两个阶段，最好通过 “数据与阶段过渡枚举之间的关系”来获取，之后用该阶段过渡枚举来初始化嵌套的 EnumMap：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Using a nested EnumMap to associate data with enum pairs</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">{</span>
    SOLID<span class="token punctuation">,</span> LIQUID<span class="token punctuation">,</span> GAS<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
        <span class="token function">MELT</span><span class="token punctuation">(</span>SOLID<span class="token punctuation">,</span> LIQUID<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FREEZE</span><span class="token punctuation">(</span>LIQUID<span class="token punctuation">,</span> SOLID<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">BOIL</span><span class="token punctuation">(</span>LIQUID<span class="token punctuation">,</span> GAS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CONDENSE</span><span class="token punctuation">(</span>GAS<span class="token punctuation">,</span> LIQUID<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">SUBLIME</span><span class="token punctuation">(</span>SOLID<span class="token punctuation">,</span> GAS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEPOSIT</span><span class="token punctuation">(</span>GAS<span class="token punctuation">,</span> SOLID<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Phase</span> from<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">;</span>

        <span class="token class-name">Transition</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Initialize the phase transition map</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Phase</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Phase</span><span class="token punctuation">,</span> <span class="token class-name">Transition</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t<span class="token punctuation">.</span>from<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Phase</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        <span class="token function">toMap</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">,</span> t <span class="token operator">-&gt;</span> t<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Phase</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Transition</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">Phase</span> from<span class="token punctuation">,</span> <span class="token class-name">Phase</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化阶段过渡映射的代码看起来可能有点复杂。映射的类型为 Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;，表示是由键为源 Phase（即第一个阶段）、值为另一个映射组成的 Map，其中组成值的 Map 是由键值对目标 Phase（即第二个阶段）和 Transition 组成的。这个映射的映射是利用两个集合的级联顺序进行初始化的。第一个集合按源 Phase 对过渡进行分组，第二个集合利用从目标 Phase 到过渡之间的映射创建一个 EnumMap。第二个集合中的 merge 函数（(x, y) -&gt; y）没有用到；只有当我们因为想要获得一个 EnumMap 而定义映射工厂时才需要用到它，同时 Collectors 提供了重叠工厂。</p><p>现在假设想要给系统添加一个新的阶段：plasma（离子）或者电离气体。只有两个过渡与这个阶段关联：电离化，它将气体变成离子；以及消电离化，将离子变成气体。为了更新基于数组的程序，必须给 Phase 添加一种新常量，给 Phase.Transition 添加两种新常量，用一种新的 16 个元素的版本取代原来 9 个元素的数组的数组。如果给数组添加的元素过多或者过少，或者元素放置不妥当，可就麻烦了：程序可以编译，但是会在运行时失败。为了更新基于 EnumMap 的版本，所要做的就是必须将 PLASMA 添加到 Phase 列表，并将 IONIZE(GAS, PLASMA)和 DEIONIZE(PLASMA, GAS) 添加到 Phase.Transition 的列表中：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Adding a new phase using the nested EnumMap implementation</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Phase</span> <span class="token punctuation">(</span>
	SOLID<span class="token punctuation">,</span> LIQUID<span class="token punctuation">,</span> GAS<span class="token punctuation">,</span> PLASMA<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Transition</span> <span class="token punctuation">{</span>
    <span class="token function">MELT</span><span class="token punctuation">(</span>SOLID<span class="token punctuation">,</span> LIQUID<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FREEZE</span><span class="token punctuation">(</span>LIQUID<span class="token punctuation">,</span> SOLID<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">BOIL</span><span class="token punctuation">(</span>LIQUID<span class="token punctuation">,</span> GAS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">CONDENSE</span><span class="token punctuation">(</span>GAS<span class="token punctuation">,</span> LIQUID<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SUBLIME</span><span class="token punctuation">(</span>SOLID<span class="token punctuation">,</span> GAS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEPOSIT</span><span class="token punctuation">(</span>GAS<span class="token punctuation">,</span> SOLID<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token function">IONIZE</span><span class="token punctuation">(</span>GAS<span class="token punctuation">,</span> PLASMA<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DEIONIZE</span><span class="token punctuation">(</span>PLASMA<span class="token punctuation">,</span> GAS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
  	<span class="token comment">// ... Remainder unchanged</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序会自行处理所有其他的事情，这样就几乎没有出错的可能。从内部来看，映射的映射被实现成了数组的数组，因此在提升了清晰性、安全性和易维护性的同时，在空间或者时间上也几乎没有多余的开销。</p><p>为了简洁起见，上述范例是用 null 表明状态没有变化（这里的 to 和 from 是相等的）。这并不是好的实践，可能在运行时导致 NullPointerException 异常。要给这个问题设计一个整洁、优雅的解决方案，需要高超的技巧，得到的程序会很长，贬损了本条目的主要精神。</p><p>总而言之，最好不要用序数来索引数组，而要使用 EnumMap。如果你所表示的这种关系是多维的，就使用 EnumMap&lt;..., EnumMap&lt;...&gt;&gt;。应用程序的程序员一般都不使用 Enum.ordinal 方法，仅仅在极少数情况下才会使用，因此这是一种特殊情况。</p><h2 id="第-38-条-用接口模拟可扩展的枚举" tabindex="-1"><a class="header-anchor" href="#第-38-条-用接口模拟可扩展的枚举" aria-hidden="true">#</a> 第 38 条：用接口模拟可扩展的枚举</h2><p>几乎从所有方面来看，枚举类型都优越于类型安全枚举模式。从表面上看，有一个异常与可伸缩性有关，这个异常可能处在原来的模式中，却没有得到语言构造的支持。换句话说，使用类型安全枚举模式能够实现让一个枚举类型去扩展另一个枚举类型；利用这种语言特性，则不可能做到。这绝非偶然。枚举的可伸缩性最后证明基本上都不是什么好点子。扩展类型的元素为基本类型的实例，基本类型的实例却不是扩展类型的元素，这样很混乱。目前还没有很好的方法来枚举基本类型的所有元素及其扩展。最终，可伸缩性会导致设计和实现的许多方面变得复杂起来。</p><p>也就是说，对于可伸缩的枚举类型而言，至少有一种具有说服力的用例，这就是操作码，也称作 opcode。操作码是指这样的枚举类型：它的元素表示在某种机器上的那些操作，例如 Operation 类型，它表示一个简单的计算器中的某些函数。有时要尽可能地让 API 的用户提供它们自己的操作，这样可以有效地扩展 API 所提供的操作集。</p><p>幸运的是，有一种很好的方法可以利用枚举类型来实现这种效果。由于枚举类型可以通过给操作码类型和（属于接口的标准实现的）枚举定义接口来实现任意接口，基本的想法就是利用这一事实。例如，以下是 Operation 类型的扩展版本：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Emulated extensible enum using an interface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">BasicOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token function">PLUS</span><span class="token punctuation">(</span><span class="token string">&quot;+&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">MINUS</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">TIMES</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">DIVIDE</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>

    <span class="token class-name">BasicOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然枚举类型不是可扩展的，但接口类型却是可扩展的，它是用来表示 API 中的操作的接口类型。你可以定义另一个枚举类型，它实现</p><p>这个接口，并用这个新类型的实例代替基本类型。例如，假设你想要定义一个上述操作类型的扩展，由求幂和求余操作组成。你所要做的就是编写一个枚举类型，让它实现 Operation 接口：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Emulated extension enum</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ExtendedOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>
    <span class="token function">EXP</span><span class="token punctuation">(</span><span class="token string">&quot;^&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">REMAINDER</span><span class="token punctuation">(</span><span class="token string">&quot;%&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">%</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> symbol<span class="token punctuation">;</span>

    <span class="token class-name">ExtendedOperation</span><span class="token punctuation">(</span><span class="token class-name">String</span> symbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>symbol <span class="token operator">=</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在可以使用基础操作的任何地方，现在都可以使用新的操作，只要 API 是写成采用接口类型而非实现。注意，在枚举中，不必像在不可扩展的枚举中所做的那样，利用特定于实例的方法实现来声明抽象的 apply 方法。因为抽象的方法（apply）是接口的一部分。</p><p>不仅可以在任何需要“基本枚举”的地方单独传递一个“扩展枚举”的实例，而且除了那些基本类型的元素之外，还可以传递完整的扩展枚举类型，并使用它的元素。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">ExtendedOperation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span> <span class="token operator">&amp;</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> opEnumType<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opEnumType<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>	<span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f %s %f = %f%n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意扩展过的操作类型的类的字面文字（ExtendedOperation.class）从 main 被传递给了 test 方法，来描述被扩展操作的集合。这个类的字面文字充当有限制的类型令牌。opEnumType 参数中公认很复杂的声明（&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;）确保了 Class 对象既表示枚举又表示 Operation 的子类型，这正是遍历元素和执行与每个元素相关联的操作时所需要的。</p><p>第二种方法是传入一个 Collection&lt;? extends Operation&gt;，这是个有限制的通配符类型，而不是传递一个类对象：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">ExtendedOperation</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> test <span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Operation</span><span class="token punctuation">&gt;</span></span> opSet<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Operation</span> op <span class="token operator">:</span> opSet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f %s %f = %f%n&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> op<span class="token punctuation">,</span> y<span class="token punctuation">,</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样得到的代码没有那么复杂，test 方法也比较灵活一些：它允许调用者将多个实现类型的操作合并到一起。另一方面，也放弃了在指定操作上使用 EnumSet 和 EnumMap 的功能。</p><p>上面这两段程序运行时带上命令行参数 4 和 2，都会产生如下输出：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">4.000000</span> <span class="token operator">^</span> <span class="token number">2.000000</span> <span class="token operator">=</span> <span class="token number">16.000000</span>
<span class="token number">4.000000</span> <span class="token operator">%</span> <span class="token number">2.000000</span> <span class="token operator">=</span> <span class="token number">0.000000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>用接口模拟可伸缩枚举有个小小的不足，即无法将实现从一个枚举类型继承到另一个枚举类型。如果实现代码不依赖于任何状态，就可以将缺省实现放在接口中。在上述 Operation 的示例中，保存和获取与某项操作相关联的符号的逻辑代码，必须复制到 BasicOperation 和 ExtendedOperation 中。在这个例子中是可以的，因为复制的代码非常少。如果共享功能比较多，则可以将它封装在一个辅助类或者静态辅助方法中，来避免代码的复制工作。</p><p>本条目所述的模式也在 Java 类库中得到了应用。例如，java.nio.file.LinkOption 枚举类型，它同时实现了 CopyOption 和 OpenOption 接口。</p><p>总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟。这样允许客户端编写自己的枚举（或者其他类型）来实现接口。如果 API 是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。</p><h2 id="第-39-条-注解优先于命名模式" tabindex="-1"><a class="header-anchor" href="#第-39-条-注解优先于命名模式" aria-hidden="true">#</a> 第 39 条：注解优先于命名模式</h2><p>根据经验，一般使用命名模式表明有些程序元素需要通过某种工具或者框架进行特殊处理。例如，在 Java 4 发行版本之前，JUnit 测试框架原本要求其用户一定要用 test 作为测试方法名称的开头。这种方法可行，但是有几个很严重的缺点。首先，文字拼写错误会导致失败，且没有任何提示。例如，假设不小心将一个测试方法命名为 tsetSafetyOverride 而不是 testSafetyOverride。JUnit 3 不会提示，但也不会执行测试，造成错误的安全感。</p><p>命名模式的第二个缺点是，无法确保它们只用于相应的程序元素上。例如，假设将某个类称作 TestSafetyMechanisms，是希望 JUnit 3 会自动地测试它所有的方法，而不管它们叫什么名称。JUnit 3 还是不会提示，但也同样不会执行测试。</p><p>命名模式的第三个缺点是，它们没有提供将参数值与程序元素关联起来的好方法。例如，假设想要支持一种测试类别，它只在抛出特殊异常时才会成功。异常类型本质上是测试的一个参数。你可以利用某种具体的命名模式，将异常类型名称编码到测试方法名称中，但是这样的代码很不雅观，也很脆弱。编译器不知道要去检验准备命名异常的字符串是否真正命名成功。如果命名的类不存在，或者不是一个异常，你也要到试着运行测试时才会发现。</p><p>注解很好地解决了所有这些问题，JUnit 从 Java 4 开始使用。在本条目中，我们要编写自己的试验测试框架，展示一下注解的使用方法。假设想要定义一个注解类型来指定简单的测试，它们自动运行，并在抛出异常时失败。以下就是这样的一个注解类型，命名为 Test：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Marker annotation type declaration</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * Indicates that the annotated method is a test method.
 * Use only on parameterless static methods.
 */</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Test 注解类型的声明就是它自身通过 Retention 和 Target 注解进行了注解。注解类型声明中的这种注解被称作元注解。@Retention(RetentionPolicy.RUNTIME) 元注解表明 Test 注解在运行时也应该存在，否则测试工具就无法知道 Test 注解。@Target(ElementType.METHOD) 元注解表明，Test 注解只在方法声明中才是合法的：它不能运用到类声明、域声明或者其他程序元素上。</p><p>注意 Test 注解声明上方的注释：&quot;Use only on parameterless static method”（只用于无参的静态方法）。如果编译器能够强制这一限制最好，但是它做不到，除非编写一个注解处理器，让它来完成。关于这个主题的更多信息，请参阅 javax.annotation.processing 的文档。在没有这类注解处理器的情况下，如果将 Test 注解放在实例方法的声明中，或者放在带有一个或者多个参数的方法中，测试程序还是可以编译，让测试工具在运行时来处理这个问题。</p><p>下面就是现实应用中的 Test 注解，称作标记注解，因为它没有参数，只是“标注”被注解的元素。如果程序员拼错了 Test，或者将 Test 注解应用到程序元素而非方法声明，程序就无法编译：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Program containing marker annotations</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>
    <span class="token comment">// Test should pass</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Test should fail</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Boom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Not a test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// INVALID USE: nonstatic method</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Test should fail</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Crash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Sample 类有 7 个静态方法，其中 4 个被注解为测试。这 4 个中有 2 个抛出了异常：m3 和 m7，另外两个则没有：m1 和 m5。但是其中一个没有抛出异常的被注解方法：m5，是一个实例方法，因此不属于注解的有效使用。总之，Sample 包含 4 项测试：一项会通过，两项会失败，另一项无效。没有用 Test 注解进行标注的另外 4 个方法会被测试工具忽略。</p><p>Test 注解对 Sample 类的语义没有直接的影响。它们只负责提供信息供相关的程序使用。更一般地讲，注解永远不会改变被注解代码的语义，但是使它可以通过工具进行特殊的处理，例如像这种简单的测试运行类：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Program to process marker annotations</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunTests</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tests <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> passed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> testClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> m <span class="token operator">:</span> testClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                tests<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    passed<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> wrappedExc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> wrappedExc<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token string">&quot; failed: &quot;</span> <span class="token operator">+</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid @Test: &quot;</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Passed: %d, Failed: %d%n&quot;</span><span class="token punctuation">,</span> passed<span class="token punctuation">,</span> tests <span class="token operator">-</span> passed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试运行工具在命令行上使用完全匹配的类名，并通过调用 Method.invoke 反射式地运行类中所有标注了 Test 注解的方法。isAnnotationPresent 方法告知该工具要运行哪些方法。如果测试方法抛出异常，反射机制就会将它封装在 InvocationTargetException 中。该工具捕捉到这个异常，并打印失败报告，包含测试方法抛出的原始异常，这些信息是通过 getCause 方法从 InvocationTargetException 中提取出来的。</p><p>如果尝试通过反射调用测试方法时抛出 InvocationTargetException 之外的任何异常，表明编译时没有捕捉到 Test 注解的无效用法。这种用法包括实例方法的注解，或者带有一个或多个参数的方法的注解，或者不可访问的方法的注解。测试运行类中的第二个 catch 块捕捉到这些 Test 用法错误，并打印出相应的错误消息。下面就是 RunTests 在 Sample 上运行时打印的输出：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name"><span class="token namespace">item39<span class="token punctuation">.</span></span>Sample</span><span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> failed<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>RuntimeException</span><span class="token operator">:</span> <span class="token class-name">Boom</span>
<span class="token class-name">Invalid</span> <span class="token annotation punctuation">@Test</span><span class="token operator">:</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name"><span class="token namespace">item39<span class="token punctuation">.</span></span>Sample</span><span class="token punctuation">.</span><span class="token function">m5</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name"><span class="token namespace">item39<span class="token punctuation">.</span></span>Sample</span><span class="token punctuation">.</span><span class="token function">m7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> failed<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>RuntimeException</span><span class="token operator">:</span> <span class="token class-name">Crash</span>
<span class="token class-name">Passed</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Failed</span><span class="token operator">:</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们要针对只在抛出特殊异常时才成功的测试添加支持。为此需要一个新的注解类型：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Annotation type with a parameter</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * Indicates that the annotated method is a test method that
 * must throw the designated exception to succed.
 */</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTest</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个注解的参数类型是 Class&lt;? extends Throwable&gt;。这个通配符类型有些绕口。它在英语中的意思是：某个扩展 Throwable 的类的 Class 对象，它允许注解的用户指定任何异常（或错误）类型。这种用法是有限制的类型令牌的一个示例。下面就是实际应用中的这个注解。注意类名称被用作了注解参数的值：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Program containing annotations with a parameter</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sample2</span> <span class="token punctuation">{</span>
    <span class="token comment">// Test should pass</span>
    <span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        i <span class="token operator">=</span> i <span class="token operator">/</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Should fail (wrong exception)</span>
    <span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Should fail (no exception)</span>
    <span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们要修改一下测试运行工具来处理新的注解。这其中包括将以下代码添加到 main 方法中：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tests<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: no excepetion%n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> wrappedExc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> wrappedExc<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> excType <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>excType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      passed<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: expected %s, got %s%n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> excType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid @Test: &quot;</span> <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码类似于用来处理 Test 注解的代码，但有一处不同：这段代码提取了注解参数的值，并用它检验该测试抛出的异常是否为正确的类型。没有显式的转换，因此没有出现 ClassCastException 的危险。编译过的测试程序确保它的注解参数表示的是有效的异常类型，需要提醒一点：有可能注解参数在编译时是有效的，但是表示特定异常类型的类文件在运行时却不存在。在这种希望很少出现的情况下，测试运行类会抛出 TypeNotPresentException 异常。</p><p>将上面的异常测试示例再深入一点，想象测试可以在抛出任何一种指定异常时都能够通过。注解机制有一种工具，使得支持这种用法变得十分容易。假设我们将 ExceptionTest 注解的参数类型改成 Class 对象的一个数组：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Annotation type with an array parameter</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTest</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注解中数组参数的语法十分灵活。它是进行过优化的单元素数组。使用了 ExceptionTest 新版的数组参数之后，之前的所有 ExceptionTest 注解仍然有效，并产生单元素的数组。为了指定多元素的数组，要用花括号将元素包围起来，并用逗号将它们隔开：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Code containing an annotation with an array parameter</span>
<span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Nul1PointerException</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doublyBad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// The spec permits this method to throw either </span>
  <span class="token comment">// IndexOutOfBoundsException or NullPointerException </span>
  list<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> nul1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改测试运行工具来处理新的 ExceptionTest 相当简单。下面的代码代替了原来的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tests<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: no excepetion%n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Trowable</span> wrappedExc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> wrappedEx<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldPassed <span class="token operator">=</span> passed<span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> excTypes <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">&gt;</span></span> excType <span class="token operator">:</span> excTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>excType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        passed<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>passed <span class="token operator">==</span> oldPassed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: %s %n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Java 8 开始，还有另一种方法可以进行多值注解。它不是用一个数组参数声明一个注解类型，而是用 Repeatable 元注解对注解的声明进行注解，表示该注解可以被重复地应用给单个元素。这个元注解只有一个参数，就是包含注解类型的类对象，它唯一的参数是一个注解类型数组。下面的注解声明就是把 ExceptionTest 注解改成使用这个方法之后的版本。注意包含的注解类型必须利用适当的保留策略和目标进行注解，否则声明将无法编译：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Repeatable annotation type</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTestContainer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTest</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">&gt;</span></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ExceptionTestContainer</span> <span class="token punctuation">{</span>
    <span class="token class-name">ExceptionTest</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是 doublyBad 测试方法用重复注解代替数组值注解之后的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Code containing a repeated annotation</span>
<span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ExceptionTest</span><span class="token punctuation">(</span><span class="token class-name">Nul1PointerException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doublyBad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span> 
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>处理可重复的注解要非常小心。重复的注解会产生一个包含注解类型的合成注解。getAnnotationsByType 方法掩盖了这个事实，可以用于访问可重复注解类型的重复和非重复的注解。但 isAnnotationPresent 使它变成了显式的，即重复的注解不是注解类型（而是所包含的注解类型）的一部分。如果一个元素具有某种类型的重复注解，并且用 isAnnotationPresent 方法检验该元素是否具有该类型的注解，会发现它没有。用这种方法检验是否存在注解类型，会导致程序默默地忽略掉重复的注解。同样地，用这种方法检验是否存在包含的注解类型，会导致程序默默地忽略掉非重复的注解。为了利用 isAnnotationPresent 检测重复和非重复的注解，必须检查注解类型及其包含的注解类型。下面是 Runtests 程序改成使用 ExceptionTest 注解时有关部分的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Processing repeatable annotations</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token operator">||</span> m<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTestContainer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  tests<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: no excepetion%n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Trowable</span> wrappedExc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Throwable</span> exc <span class="token operator">=</span> wrappedEx<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldPassed <span class="token operator">=</span> passed<span class="token punctuation">;</span>
    <span class="token class-name">ExceptionTest</span><span class="token punctuation">[</span><span class="token punctuation">]</span> excTests <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionTest</span> excTest <span class="token operator">:</span> excTests<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>excTest<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        passed<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>passed <span class="token operator">==</span> oldPassed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Test %s failed: %s %n&quot;</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加入可重复的注解，提升了源代码的可读性，逻辑上是将同一个注解类型的多个实例应用到了一个指定的程序元素。如果你觉得它们增强了源代码的可读性就使用它们，但是记住在声明和处理可重复注解的代码中会有更多的样板代码，并且处理可重复的注解容易出错。</p><p>本条目中的测试框架只是一个试验，但它清楚地示范了注解之于命名模式的优越性。这只是揭开了注解功能的冰山一角。如果是在编写一个需要程序员给源文件添加信息的工具，就要定义一组适当的注解类型。既然有了注解，就完全没有理由再使用命名模式了。</p><p>也就是说，除了“工具铁匠”（即平台框架程序员）之外，大多数程序员都不必定义注解类型。但是所有的程序员都应该使用 Java 平台所提供的预定义的注解类型。还要考虑使用 IDE 或者静态分析工具所提供的任何注解。这种注解可以提升由这些工具所提供的诊断信息的质量。但是要注意这些注解还没有标准化，因此如果变换工具或者形成标准，就有很多工作要做了。</p><h2 id="第-40-条-坚持使用-override-注解" tabindex="-1"><a class="header-anchor" href="#第-40-条-坚持使用-override-注解" aria-hidden="true">#</a> 第 40 条：坚持使用 Override 注解</h2><p>Java 类库中包含了几种注解类型。对于传统的程序员而言，这里面最重要的就是 @0verride 注解。这个注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型中的一个方法声明。如果坚持使用这个注解，可以防止一大类的非法错误。以下面的程序为例，这里的 Bigram 类表示一个双字母组或者有序的字母对：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Can you spot the bug?</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bigram</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> second<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Bigram</span><span class="token punctuation">(</span><span class="token keyword">char</span> first<span class="token punctuation">,</span> <span class="token keyword">char</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Bigram</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span>first <span class="token operator">==</span> first <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>second <span class="token operator">==</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">31</span> <span class="token operator">*</span> first <span class="token operator">+</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Bigram</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">;</span> ch <span class="token operator">&lt;=</span> <span class="token char">&#39;z&#39;</span><span class="token punctuation">;</span> ch<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Bigram</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主程序反复地将 26 个双字母组添加到集合中，每个双字母组都由两个相同的小写字母组成。随后它打印出集合的大小。你可能以为程序打印出的大小为 26，因为集合不能包含重复。如果你试着运行程序，会发现它打印的不是 26 而是 260。哪里出错了呢？</p><p>很显然，Bigram 类的创建者原本想要覆盖 equals 方法，同时还记得覆盖了 hashCode。遗憾的是，不幸的程序员没能覆盖 equals 方法，而是将它重载了。为了覆盖 Object.equals 必须定义一个参数为 Object 类型的 equals 方法，但是 Bigram 类的 equals 方法的参数并不是 Object 类型，因此 Bigram 类从 Object 继承了 equals 方法。这个 equals 方法测试对象的同一性，就像 == 操作符一样。每个 bigram 的 10 个备份中，每一个都与其余的 9 个不同，因此 Object.equals 认为它们不相等，这正是程序会打印出 260 的原因。</p><p>幸运的是，编译器可以帮助你发现这个错误，但是只有当你告知编译器你想要覆盖 Object.equals 时才行。为了做到这一点，要用 @Override 标注 Bigram.euqals，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Bigram</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> b<span class="token punctuation">.</span>first <span class="token operator">==</span> first <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>second <span class="token operator">==</span> second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果插入这个注解，并试着重新编译程序，编译器就会产生如下的错误消息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Bigram</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">10</span><span class="token operator">:</span> method does not override or implement a method from a supertype
<span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Bigram</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">^</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会立即意识到哪里错了，拍拍自己的头，恍然大悟，马上用正确的来取代出错的 equals 实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Bigram</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">Bigram</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Bigram</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
	<span class="token keyword">return</span> b<span class="token punctuation">.</span>first <span class="token operator">==</span> first <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>second <span class="token operator">==</span> second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，应该在你想要覆盖超类声明的每个方法声明中使用 Override 注解。这一规则有个小小的例外。如果你在编写一个没有标注为抽象的类，并且确信它覆盖了超类的抽象方法，在这种情况下，就不必将 Override 注解放在该方法上了。在没有声明为抽象的类中，如果没有覆盖抽象的超类方法，编译器就会发出一条错误消息。但是，你可能希望关注类中所有覆盖超类方法的方法，在这种情况下，也可以放心地标注这些方法。大多数 IDE 可以设置为在需要覆盖一个方法时自动插入 Override 注解。</p><p>大多数 IDE 都提供了使用 Override 注解的另一种理由。如果启用相应的代码检验功能，当有一个方法没有 Override 注解，却覆盖了超类方法时，IDE 就会产生一条警告。如果使用了 Override 注解，这些警告就会提醒你警惕无意识的覆盖。这些警告补充了编译器的错误消息，后者会提醒你警惕无意识的覆盖失败。IDE 和编译器可以确保你无一遗漏地覆盖任何你想要覆盖的方法。</p><p>Override 注解可以用在方法声明中，覆盖来自接口以及类的声明。由于缺省方法的出现，在接口方法的具体实现上使用 Override，可以确保签名正确，这是一个很好的实践。如果知道接口没有缺省方法，可以选择省略接口方法的具体实现上的 Override 注解，以减少混乱。</p><p>但是在抽象类或者接口中，还是值得标注所有你想要的方法，来覆盖超类或者超接口方法，无论它们是具体的还是抽象的。例如，Set 接口没有给 Collection 接口添加新方法，因此它应该在它的所有方法声明中包括 Override 注解，以确保它不会意外地给 Collection 接口添加任何新方法。</p><p>总而言之，如果在你想要的每个方法声明中使用 Override 注解来覆盖超类声明，编译器就可以替你防止大量的错误，但有一个例外。在具体的类中，不必标注你确信覆盖了抽象方法声明的方法（虽然这么做也没有什么坏处）。</p><h2 id="第-41-条-用标记接口定义类型" tabindex="-1"><a class="header-anchor" href="#第-41-条-用标记接口定义类型" aria-hidden="true">#</a> 第 41 条：用标记接口定义类型</h2><p>标记接口是不包含方法声明的接口，它只是指明（或者“标明”）一个类实现了具有某种属性的接口。例如，考虑 Serializable 接口。通过实现这个接口，类表明它的实例可以被写到 ObjectOutputStream 中（或者“被序列化”）。</p><p>你可能听说过标记注解使得标记接口过时了。这种断言是不正确的。标记接口有两点胜过标记注解。首先，也是最重要的一点是，标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型。标记接口类型的存在，允许你在编译时就能捕捉到。在使用标记注解的情况下，要到运行时才能捕捉到的错误。Java 的序列化设施利用 Serializable 标记接口表明一个类型是可以序列化的。ObjectOutputStream.writeObject 方法将传入的对象序列化，其参数必须是可序列化的。该方法的参数类型应该为 Serializable，如果试着序列化一个不恰当的对象，（通过类型检查）在编译时就会被发现。编译时的错误侦测是标记接口的目的，但遗憾的是，ObjectOutputStream.write API 并没有利用 Serializable 接口的优势：其参数声明为 Object 类型，因此，如果尝试序列化一个不可序列化的对象，将直到程序运行时才会失败。</p><p>标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定。如果注解类型用目标 ElementType.TYPE 声明，它就可以被应用于任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它将唯一的接口扩展成它适用的接口，确保所有被标记的类型也都是该唯一接口的子类型。</p><p>Set 接口可以说就是这种有限制的标记接口。它只适用于 Collection 子类型，但是它不会添加除了 Collection 定义之外的方法。一般情况下，不把它当作是标记接口，因为它改进了几个 Collection 方法的合约，包括 add、equals 和 hashCode。但是很容易想象只适用于某种特殊接口的子类型的标记接口，它没有改进接口的任何方法的合约。这种标记接口可以描述整个对象的某个约束条件，或者表明实例能够利用其他某个类的方法进行处理（就像 Serializable 接口表明实例可以通过 ObjectOutputStream 进行处理一样）。</p><p>标记注解胜过标记接口的最大优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。</p><p>那么什么时候应该使用标记注解，什么时候应该使用标记接口呢？很显然，如果标记是应用于任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或者扩展接口。如果标记只应用于类和接口，就要问问自己：我要编写一个还是多个只接受有这种标记的方法呢？如果是这种情况，就应该优先使用标记接口而非注解。这样你就可以用接口作为相关方法的参数类型，它可以真正为你提供编译时进行类型检査的好处。如果你确信自己永远不需要编写一个只接受带有标记的对象，那么或许最好使用标记注解。此外，如果标记是广泛使用注解的框架的一个组成部分，则显然应该选择标记注解。</p><p>总而言之，标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。如果你发现自己在编写的是目标为 ElementType.TYPE 的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否会更加合适。</p><p>从某种意义上说，本条目与第 22 条中“如果不想定义类型就不要使用接口”的说法相反。本条目最接近的意思是说：“如果想要定义类型，一定要使用接口。”</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Effective Java/第6章 枚举和注解.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/6 下午5:11:40</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Effective%20Java/%E7%AC%AC5%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link prev" aria-label="第 5 章 泛型"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 5 章 泛型</div></a><a href="/reading-notes/Effective%20Java/%E7%AC%AC7%E7%AB%A0%20Lambda%E5%92%8CStream.html" class="nav-link next" aria-label="第 7 章 Lambda 和 Stream"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 7 章 Lambda 和 Stream<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
