<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 6 章 类文件结构"><meta property="og:type" content="article"><meta property="og:image" content="https://www.cxlsn.cn/"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="第 6 章 类文件结构"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 6 章 类文件结构 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link active" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第一部分 走近 Java</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 走近 Java"><!---->第 1 章 走近 Java<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 自动内存管理</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC2%E7%AB%A0Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 Java 内存区域与内存溢出异常"><!---->第 2 章 Java 内存区域与内存溢出异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC3%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 垃圾收集器与内存分配策略"><!---->第 3 章 垃圾收集器与内存分配策略<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 虚拟机性能监控、故障处理工具"><!---->第 4 章 虚拟机性能监控、故障处理工具<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC5%E7%AB%A0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 调优案例分析与实战"><!---->第 5 章 调优案例分析与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第三部分 虚拟机执行子系统</span><!----></p><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 6 章 类文件结构"><!---->第 6 章 类文件结构<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.1 概述"><!---->6.1 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-2-无关性的基石" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.2 无关性的基石"><!---->6.2 无关性的基石<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-class-类文件的结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3 Class 类文件的结构"><!---->6.3 Class 类文件的结构<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-1-魔数与-class-文件的版本" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.1 魔数与 Class 文件的版本"><!---->6.3.1 魔数与 Class 文件的版本<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-2-常量池" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.2 常量池"><!---->6.3.2 常量池<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-3-访问标志" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.3 访问标志"><!---->6.3.3 访问标志<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-4-类索引、父类索引与接口索引集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.4 类索引、父类索引与接口索引集合"><!---->6.3.4 类索引、父类索引与接口索引集合<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-5-字段表集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.5 字段表集合"><!---->6.3.5 字段表集合<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-6-方法表集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.6 方法表集合"><!---->6.3.6 方法表集合<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-7-属性表集合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3.7 属性表集合"><!---->6.3.7 属性表集合<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-字节码指令简介" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4 字节码指令简介"><!---->6.4 字节码指令简介<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-1-字节码与数据类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.1 字节码与数据类型"><!---->6.4.1 字节码与数据类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-2-加载和存储指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.2 加载和存储指令"><!---->6.4.2 加载和存储指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-3-运算指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.3 运算指令"><!---->6.4.3 运算指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-4-类型转换指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.4 类型转换指令"><!---->6.4.4 类型转换指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-5-对象创建与访问指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.5 对象创建与访问指令"><!---->6.4.5 对象创建与访问指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-6-操作数栈管理指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.6 操作数栈管理指令"><!---->6.4.6 操作数栈管理指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-7-控制转移指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.7 控制转移指令"><!---->6.4.7 控制转移指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-8-方法调用和返回指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.8 方法调用和返回指令"><!---->6.4.8 方法调用和返回指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-9-异常处理指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.9 异常处理指令"><!---->6.4.9 异常处理指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-10-同步指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4.10 同步指令"><!---->6.4.10 同步指令<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-5-公有设计-私有实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.5 公有设计，私有实现"><!---->6.5 公有设计，私有实现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-6-class-文件结构的发展" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.6 Class 文件结构的发展"><!---->6.6 Class 文件结构的发展<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-7-本章小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.7 本章小结"><!---->6.7 本章小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC7%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 虚拟机类加载机制"><!---->第 7 章 虚拟机类加载机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC8%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 虚拟机字节码执行引擎"><!---->第 8 章 虚拟机字节码执行引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC9%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 类加载及执行子系统的案例与实战"><!---->第 9 章 类加载及执行子系统的案例与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 程序编译与代码优化</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC10%E7%AB%A0%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 前端编译与优化"><!---->第 10 章 前端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC11%E7%AB%A0%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 后端编译与优化"><!---->第 11 章 后端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第五部分 高效并发</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC12%E7%AB%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 Java 内存模型与线程"><!---->第 12 章 Java 内存模型与线程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC13%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 线程安全与锁优化"><!---->第 13 章 线程安全与锁优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 6 章 类文件结构</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年8月7日</span><meta property="datePublished" content="2022-08-07T15:02:14.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 96 分钟</span><meta property="timeRequired" content="PT96M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 28808 字</span><meta property="wordCount" content="28808"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-1-概述" class="router-link-active router-link-exact-active toc-link level2">6.1 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-2-无关性的基石" class="router-link-active router-link-exact-active toc-link level2">6.2 无关性的基石</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-class-类文件的结构" class="router-link-active router-link-exact-active toc-link level2">6.3 Class 类文件的结构</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-1-魔数与-class-文件的版本" class="router-link-active router-link-exact-active toc-link level3">6.3.1 魔数与 Class 文件的版本</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-2-常量池" class="router-link-active router-link-exact-active toc-link level3">6.3.2 常量池</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-3-访问标志" class="router-link-active router-link-exact-active toc-link level3">6.3.3 访问标志</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-4-类索引、父类索引与接口索引集合" class="router-link-active router-link-exact-active toc-link level3">6.3.4 类索引、父类索引与接口索引集合</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-5-字段表集合" class="router-link-active router-link-exact-active toc-link level3">6.3.5 字段表集合</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-6-方法表集合" class="router-link-active router-link-exact-active toc-link level3">6.3.6 方法表集合</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-3-7-属性表集合" class="router-link-active router-link-exact-active toc-link level3">6.3.7 属性表集合</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-字节码指令简介" class="router-link-active router-link-exact-active toc-link level2">6.4 字节码指令简介</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-1-字节码与数据类型" class="router-link-active router-link-exact-active toc-link level3">6.4.1 字节码与数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-2-加载和存储指令" class="router-link-active router-link-exact-active toc-link level3">6.4.2 加载和存储指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-3-运算指令" class="router-link-active router-link-exact-active toc-link level3">6.4.3 运算指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-4-类型转换指令" class="router-link-active router-link-exact-active toc-link level3">6.4.4 类型转换指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-5-对象创建与访问指令" class="router-link-active router-link-exact-active toc-link level3">6.4.5 对象创建与访问指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-6-操作数栈管理指令" class="router-link-active router-link-exact-active toc-link level3">6.4.6 操作数栈管理指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-7-控制转移指令" class="router-link-active router-link-exact-active toc-link level3">6.4.7 控制转移指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-8-方法调用和返回指令" class="router-link-active router-link-exact-active toc-link level3">6.4.8 方法调用和返回指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-9-异常处理指令" class="router-link-active router-link-exact-active toc-link level3">6.4.9 异常处理指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-4-10-同步指令" class="router-link-active router-link-exact-active toc-link level3">6.4.10 同步指令</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-5-公有设计-私有实现" class="router-link-active router-link-exact-active toc-link level2">6.5 公有设计，私有实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-6-class-文件结构的发展" class="router-link-active router-link-exact-active toc-link level2">6.6 Class 文件结构的发展</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html#_6-7-本章小结" class="router-link-active router-link-exact-active toc-link level2">6.7 本章小结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-6-章-类文件结构" tabindex="-1"><a class="header-anchor" href="#第-6-章-类文件结构" aria-hidden="true">#</a> 第 6 章 类文件结构</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><h2 id="_6-1-概述" tabindex="-1"><a class="header-anchor" href="#_6-1-概述" aria-hidden="true">#</a> 6.1 概述</h2><p>曾记得在第一堂计算机程序课上老师就讲过：“计算机只认识 0 和 1，所以我们写的程序需要被编译器翻译成由 0 和 1 构成的二进制格式才能被计算机执行。” 十多年过去了，今天的计算机仍然只能识别 0 和 1，但由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><h2 id="_6-2-无关性的基石" tabindex="-1"><a class="header-anchor" href="#_6-2-无关性的基石" aria-hidden="true">#</a> 6.2 无关性的基石</h2><p>如果全世界所有计算机的指令集就只有 x86 一种，操作系统就只有 Windows 一种，那也许就不会有 Java 语言的出现。Java 在刚刚诞生之时曾经提出过一个非常著名的宣传口号 “一次编写，到处运行（Write Once, Run Anywhere）”，这句话充分表达了当时软件开发人员对冲破平台界限的渴求。在每时每刻都充满竞争的 IT 业界，不可能只有 Wintel<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>存在，我们也不希望出现只有 Wintel 而没有竞争者的世界，各种不同的硬件体系结构、各种不同的操作系统肯定将会长期并存发展。“与平台无关” 的理想最终只有实现在操作系统以上的应用层：Oracle 公司以及其他虚拟机发行商发布过许多可以运行在各种不同硬件平台和操作系统上的 Java 虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的 “一次编写，到处运行”。</p><p>各种不同平台的 Java 虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石，但本节标题中笔者刻意省略了 “平台” 二字，那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正在越来越被开发者所重视。直到今天，或许还有相当一部分程序员认为 Java 虚拟机执行 Java 程序是一件理所当然和天经地义的事情。但在 Java 技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在 Java 虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把 Java 的规范拆分成了《Java 语言规范》（The Java Language Specification）及《Java 虚拟机规范》（The Java Virtual Machine Specification）两部分。并且早在 1997 年发表的第一版《Java 虚拟机规范》中就曾经承诺过：“在未来，我们会对 Java 虚拟机进行适当的扩展，以便更好地支持其他语言运行于 Java 虚拟机之上”（In the future, we will consider bounded extensions to the Java virtual machine to provide better support for other languages）。Java 虚拟机发展到今天，尤其是在 2018 年，基于 HotSpot 扩展而来的 GraalVM 公开之后，当年的虚拟机设计者们已经基本兑现了这个承诺。</p><p>时至今日，商业企业和开源机构已经在 Java 语言之外发展出一大批运行在 Java 虚拟机之上的语言，如 Kotlin、Clojure、Groovy、JRuby、JPython、Scala 等。相比起基数庞大的 Java 程序员群体，使用过这些语言的开发者可能还不是特别多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后 Java 虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？</p><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java 虚拟机不与包括 Java 语言在内的任何程序语言绑定，它只与 “Class 文件” 这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集、符号表以及若干其他辅助信息。基于安全方面的考虑，《Java 虚拟机规范》中要求在 Class 文件必须应用许多强制性的语法和结构化约束，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将 Java 虚拟机作为他们语言的运行基础，以 Class 文件作为他们产品的交付媒介。例如，使用 Java 编译器可以把 Java 代码编译为存储字节码的 Class 文件，使用 JRuby 等其他语言的编译器一样可以把它们的源程序代码编译成 Class 文件。虚拟机丝毫不关心 Class 的来源是什么语言，它与程序语言之间的关系如图6-1 所示。</p><p><img src="/assets/图6-1.43e50d4d.png" alt="图6-1" loading="lazy"></p><p>图6-1 Java 虚拟机提供的语言无关性</p><p>Java 语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比 Java 语言本身更加强大才行。因此，有一些 Java 语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于 Java 的语言特性提供了发挥空间。</p><h2 id="_6-3-class-类文件的结构" tabindex="-1"><a class="header-anchor" href="#_6-3-class-类文件的结构" aria-hidden="true">#</a> 6.3 Class 类文件的结构</h2><p>解析 Class 文件的数据结构是本章的最主要内容。笔者曾经在前言中阐述过本书的写作风格：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容。但是，对文件格式、结构方面的学习，有点类似于 “读字典”，读者阅读本章时，大概会不可避免地感到比较枯燥，但这部分内容又是 Java 虚拟机的重要基础之一，是了解虚拟机的必经之路，如果想比较深入地学习虚拟机相关知识，这部分是无法回避的。</p><p>Java 技术能够一直保持着非常良好的向后兼容性，Class 文件结构的稳定功不可没，任何一门程序语言能够获得商业上的成功，都不可能去做升级版本后，旧版本编译的产品就不再能够运行这种事情。本章所讲述的关于 Class 文件结构的内容，绝大部分都是在第一版的《Java 虚拟机规范》（1997 年发布，对应于 JDK 1.2 时代的 Java 虚拟机）中就已经定义好的，内容虽然古老，但时至今日，Java 发展经历了十余个大版本、无数小更新，那时定义的 Class 文件格式的各项细节几乎没有出现任何改变。尽管不同版本的《Java 虚拟机规范》对 Class 文件格式进行了几次更新，但基本上只是在原有结构基础上新增内容、扩充功能，并未对已定义的内容做出修改。</p><p><strong>注意</strong>：任何一个 Class 文件都对应着唯一的一个类或接口的定义信息<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>，但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中)。本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为 “Class 文件格式”，实际上它完全不需要以磁盘文件的形式存在。</p><p>Class 文件是一组以 8 个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 个字节以上空间的数据项时，则会按照高位在前<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>的方式分割成若干个 8 个字节进行存储。</p><p>根据《Java 虚拟机规范》的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数” 和 “表”。后面的解析都要以这两种数据类型为基础，所以这里笔者必须先解释清楚这两个概念。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以 &quot;_info&quot; 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上也可以视作是一张表，这张表由表6-1 所示的数据项按严格顺序排列构成。</li></ul><p>表6-1 Class 文件格式</p><p><img src="/assets/表6-1.dc4cfd3f.png" alt="表6-1" loading="lazy"></p><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的 “集合”。</p><p>本节结束之前，笔者需要再强调一次，Class 的结构不像 XML 等描述语言，由于它没有任何分隔符号，所以在表6-1 中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class 文件中字节序为 Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。接下来，我们将一起看看这个表中各个数据项的具体含义。</p><h3 id="_6-3-1-魔数与-class-文件的版本" tabindex="-1"><a class="header-anchor" href="#_6-3-1-魔数与-class-文件的版本" aria-hidden="true">#</a> 6.3.1 魔数与 Class 文件的版本</h3><p>每个 Class 文件的头 4 个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。不仅是 Class 文件，很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如图片格式，如 GIF 或者 JPEG 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。Class 文件的魔数取得很有 “浪漫气息”，值为 0xCAFEBABE（咖啡宝贝？）。这个魔数值在 Java 还被称作 &quot;Oak&quot; 语言的时候（大约是 1991 年前后）就已经确定下来了。它还有一段很有趣的历史，据 Java 开发小组最初的关键成员 Patrick Naughton 所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择 0xCAFEBABE 是因为它象征着著名咖啡品牌 Peet’s Coffee 深受欢迎的 Baristas 咖啡。”<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>这个魔数似乎也预示着日后 &quot;Java&quot; 这个商标名称的出现。</p><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK 1.0 ~ 1.1 使用了 45.0 ~ 45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，因为《Java 虚拟机规范》在 Class 文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。</p><p>例如，JDK 1.1 能支持版本号为 45.0 ~ 45.65535 的 Class 文件，无法执行版本号为 46.0 以上的 Class 文件，而 JDK 1.2 则能支持 45.0 ~ 46.65535 的 Class 文件。目前最新的 JDK 版本为 13，可生成的 Class 文件主版本号最大值为 57.0。</p><p>为了讲解方便，笔者准备了一段最简单的 Java 代码（如代码清单6-1 所示），本章后面的内容都将以这段程序使用 JDK 6 编译输出的 Class 文件为基础来进行讲解，建议读者不妨用较新版本的 JDK 跟随本章的实验流程自己动手测试一遍。</p><p>代码清单6-1 简单的 Java 代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>clazz</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图6-2 显示的是使用十六进制编辑器 WinHex 打开这个 Class 文件的结果，可以清楚地看见开头 4 个字节的十六进制表示是 0xCAFEBABE，代表次版本号的第 5 个和第 6 个字节值为 0x0000，而主版本号的值为 0x0032，也即是十进制的 50，该版本号说明这个是可以被 JDK 6 或以上版本虚拟机执行的 Class 文件。</p><p><img src="/assets/图6-2.34a1c22f.png" alt="图6-2" loading="lazy"></p><p>图6-2 Java Class 文件的结构</p><p>表6-2 列出了从 JDK 1.1 到 13 之间，主流 JDK 版本编译器输出的默认的和可支持的 Class 文件版本号。</p><p>表6-2 Class 文件版本号</p><p><img src="/assets/表6-2.3a167f7f.png" alt="表6-2" loading="lazy"></p><p><strong>注</strong>：从 JDK 9 开始，Javac 编译器不再支持使用 -source 参数编译版本号小于 1.5 的源码。</p><p>关于次版本号，曾经在现代 Java（即 Java 2）出现前被短暂使用过，JDK 1.0.2 支持的版本 45.0 ~ 45.3（包括 45.0 ~ 45.3）。JDK 1.1 支持版本 45.0 ~ 45.65535，从 JDK 1.2 以后，直到 JDK 12 之前次版本号均未使用，全部固定为零。而到了 JDK 12 时期，由于 JDK 提供的功能集已经非常庞大，有一些复杂的新特性需要以 “公测” 的形式放出，所以设计者重新启用了副版本号，将它用于标识 “技术预览版” 功能特性的支持。如果 Class 文件中使用了该版本 JDK 尚未列入正式特性清单中的预览功能，则必须把次版本号标识为 65535，以便 Java 虚拟机在加载类文件时能够区分出来。</p><h3 id="_6-3-2-常量池" tabindex="-1"><a class="header-anchor" href="#_6-3-2-常量池" aria-hidden="true">#</a> 6.3.2 常量池</h3><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为 Class 文件里的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据，通常也是占用 Class 文件空间最大的数据项目之一，另外，它还是在 Class 文件中第一个出现的表类型数据项目。</p><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不同，这个容量计数是从 1 而不是 0 开始的，如图6-3 所示，常量池容量（偏移地址：0x00000008）为十六进制数 0x0016，即十进制的 22，这就代表常量池中有 21 项常量，索引值范围为 1 ~ 21。在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达 “不引用任何一个常量池项目” 的含义，可以把索引值设置为 0 来表示。Class 文件结构中只有常量池的容量计数是从 1 开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从 0 开始。</p><p><img src="/assets/图6-3.42f30487.png" alt="图6-3" loading="lazy"></p><p>图6-3 常量池结构</p><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p><ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>Java 代码在进行 Javac 编译的时候，并不像 C 和 C++ 那样有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接（具体见第 7 章）。也就是说，在 Class 文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再详细讲解。</p><p>常量池中每一项常量都是一个表，最初常量表中共有 11 种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了 4 种动态语言相关的常量<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>，为了支持 Java 模块化系统（Jigsaw），又加入了 CONSTANT_Module_info 和 CONSTANT_Package_info 两个常量，所以截至 JDK 13，常量表中分别有 17 种不同类型的常量。</p><p>这 17 类表都有一个共同的特点，表结构起始的第一位是个 u1 类型的标志位（tag，取值见表6-3 中标志列），代表着当前常量属于哪种常量类型。17 种常量类型所代表的具体含义如表6-3 所示。</p><p>表6-3 常量池的项目类型</p><p><img src="/assets/表6-3.91723980.png" alt="表6-3" loading="lazy"></p><p>之所以说常量池是最烦琐的数据，是因为这 17 种常量类型各自有着完全独立的数据结构，两两之间并没有什么共性和联系，因此只能逐项进行讲解。</p><p>请读者回头看看图6-3 中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是 0x07，查表6-3 的标志列可知这个常量属于 CONSTANT_Class_info 类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info 的结构比较简单，如表6-4 所示。</p><p>表6-4 CONSTANT_Class_info 型常量的结构</p><p><img src="/assets/表6-4.6d427819.png" alt="表6-4" loading="lazy"></p><p>tag 是标志位，它用于区分常量类型；name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表了这个类（或者接口）的全限定名，本例中的 name_index 值（偏移地址：0x0000000B）为 0x0002，也就是指向了常量池中的第二项常量。继续从图6-3 中查找第二项常量，它的标志位（地址：0x0000000D）是 0x01，查表6-3 可知确实是一个 CONSTANT_Utf8_info 类型的常量。CONSTANT_Utf8_info 类型的结构如表6-5 所示。</p><p>表6-5 CONSTANT_Utf8_info 型常量的结构</p><p><img src="/assets/表6-5.e37f9a00.png" alt="表6-5" loading="lazy"></p><p>length 值说明了这个 UTF-8 编码的字符串长度是多少字节，它后面紧跟着的长度为 length 字节的连续数据是一个使用 UTF-8 缩略编码表示的字符串。UTF-8 缩略编码与普通 UTF-8 编码的区别是：</p><p>从 &#39;\u0001&#39; 到 &#39;\u007f&#39; 之间的字符（相当于 1 ~ 127 的 ASCII 码）的缩略编码使用一个字节表示，从 &#39;\u0080&#39; 到 &#39;\u07ff&#39; 之间的所有字符的缩略编码用两个字节表示，从 &#39;\u0800&#39; 开始到 &#39;\uffff&#39; 之间的所有字符的缩略编码就按照普通 UTF-8 编码规则使用三个字节表示。</p><p>顺便提一下，由于 Class 文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info 型常量的最大长度也就是 Java 中方法、字段名的最大长度。而这里的最大长度就是 length 的最大值，既 u2 类型能表达的最大值 65535。所以 Java 程序中如果定义了超过 64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</p><p>本例中这个字符串的 length 值（偏移地址：0x0000000E）为 0x001D，也就是长 29 个字节，往后 29 个字节正好都在 1 ~ 127 的 ASCII 码范围以内，内容为 &quot;org/fenixsoft/clazz/TestClass&quot;，有兴趣的读者可以自己逐个字节换算一下，换算结果如图6-4 中选中的部分所示。</p><p><img src="/assets/图6-4.a083ea72.png" alt="图6-4" loading="lazy"></p><p>图6-4 常量池 UTF-8 字符串结构</p><p>到此为止，我们仅仅分析了 TestClass.class 常量池中 21 个常量中的两个，还未提到的其余 19 个常量都可以通过类似的方法逐一计算出来，为了避免计算过程占用过多的版面篇幅，后续的 19 个常量的计算过程就不手工去做了，而借助计算机软件来帮忙完成。在 JDK 的 bin 目录中，Oracle 公司已经为我们准备好一个专门用于分析 Class 文件字节码的工具：javap。代码清单6-2 中列出了使用 javap 工具的 -verbose 参数输出的 TestClass.class 文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。笔者曾经提到过 Class 文件中还有很多数据项都要引用常量池中的常量，建议读者不妨在本页做个记号，因为代码清单6-2 中的内容在后续的讲解之中会频繁使用到。</p><p>代码清单6-2 使用 javap 命令输出常量表</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>C:\&gt;javap -verbose TestClass 
Compiled from &quot;TestClass.java&quot;
public class org.fenixsoft.clazz.TestClass extends java.lang.Object 
SourceFile: &quot;TestClass.java&quot;
minor version: 0
major version: 50 
Constant pool:
const #1 = class	#2;	// org/fenixsoft/clazz/TestClass 
const #2 = Asciz	org/fenixsoft/clazz/TestClass;
const #3 = class	#4;	// java/lang/Object 
const #4 = Asciz	java/lang/Object;
const #5 = Asciz	m;
const #6 = Asciz	I;
const #7 = Asciz	&lt;init&gt;;
const #8 = Asciz	()V;
const #9 = Asciz	Code;
const #10 = Method	#3.#11; // java/lang/Object.&quot;&lt;init&gt;&quot;:()V 
const #11 = NameAndType #7:#8;// &quot;&lt;init&gt;&quot;:()V
const #12 = Asciz	LineNumberTable; 
const #13 = Asciz	LocalVariableTable; 
const #14 = Asciz	this;
const #15 = Asciz	Lorg/fenixsoft/clazz/TestClass;; 
const #16 = Asciz	inc;
const #17 = Asciz	()I;
const #18 = Field	#1.#19; // org/fenixsoft/clazz/TestClass.m:I 
const #19 = NameAndType #5:#6; // m:I
const #20 = Asciz	SourceFile; 
const #21 = Asciz	TestClass.java;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码清单6-2 中可以看到，计算机已经帮我们把整个常量池的 21 项常量都计算了出来，并且第 1、2 项常量的计算结果与我们手工计算的结果完全一致。仔细看一下会发现，其中有些常量似乎从来没有在代码中出现过，如 &quot;I&quot;、&quot;V&quot;、&quot;&lt;init&gt;&quot;、&quot;LineNumberTable&quot;、&quot;LocalVariableTable&quot; 等，这些看起来在源代码中不存在的常量是哪里来的？</p><p>这部分常量的确不来源于 Java 源代码，它们都是编译器自动生成的，会被后面即将讲到的字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用 “固定字节” 进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么。因为 Java 中的 “类” 是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。这部分内容将在后面进一步详细阐述。最后，笔者将 17 种常量项的结构定义总结为表6-6。</p><p>表6-6 常量池中的 17 种数据类型的结构总表</p><p><img src="/assets/表6-6-1.e3563807.png" alt="表6-6-1" loading="lazy"></p><p><img src="/assets/表6-6-2.e33c77bf.png" alt="表6-6-2" loading="lazy"></p><p><img src="/assets/表6-6-3.1bef52c8.png" alt="表6-6-3" loading="lazy"></p><p><img src="/assets/表6-6-4.432dd1d0.png" alt="表6-6-4" loading="lazy"></p><h3 id="_6-3-3-访问标志" tabindex="-1"><a class="header-anchor" href="#_6-3-3-访问标志" aria-hidden="true">#</a> 6.3.3 访问标志</h3><p>在常量池结束之后，紧接着的 2 个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final；等等。具体的标志位以及标志的含义见表 6-7。</p><p>表6-7 访问标志</p><p><img src="/assets/表6-7.52c02f56.png" alt="表6-7" loading="lazy"></p><p>access_flags 中一共有 16 个标志位可以使用，当前只定义了其中 9 个<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>，没有使用到的标志位要求一律为零。以代码清单6-1 中的代码为例，TestClass 是一个普通 Java 类，不是接口、枚举、注解或者模块，被 public 关键字修饰但没有被声明为 final 和 abstract，并且它使用了 JDK 1.2 之后的编译器进行编译，因此它的 ACC_PUBLIC、ACC_SUPER 标志应当为真，而 ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_MODULE 这七个标志应当为假，因此它的 access_flags 的值应为：0x0001 | 0x0020 = 0x0021。从图6-5 中看到，access_flags 标志（偏移地址：0x000000EF）的确为 0x0021。</p><p><img src="/assets/图6-5.80b9c0f5.png" alt="图6-5" loading="lazy"></p><p>图6-5 access_flags 标志</p><h3 id="_6-3-4-类索引、父类索引与接口索引集合" tabindex="-1"><a class="header-anchor" href="#_6-3-4-类索引、父类索引与接口索引集合" aria-hidden="true">#</a> 6.3.4 类索引、父类索引与接口索引集合</h3><p>类索引（this_class）和父类索引（super_class）都是一个 u2 类型的数据，而接口索引集合（interfaces）是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 关键字（如果这个 Class 文件表示的是一个接口，则应当是 extends 关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。图6-6 演示了代码清单6-1中代码的类索引查找过程。</p><p><img src="/assets/图6-6.feeba956.png" alt="图6-6" loading="lazy"></p><p>图6-6 类索引查找全限定名的过程</p><p>对于接口索引集合，入口的第一项 u2 类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为 0，后面接口的索引表不再占用任何字节。代码清单6-1 中的代码的类索引、父类索引与接口表索引的内容如图6-7 所示。</p><p><img src="/assets/图6-7.30b25286.png" alt="图6-7" loading="lazy"></p><p>图6-7 类索引、父类索引、接口索引集合</p><p>从偏移地址 0x000000F1 开始的 3 个 u2 类型的值分别为 0x0001、0x0003、0x0000，也就是类索引为 1，父类索引为 3，接口索引集合大小为 0。查询前面代码清单6-2 中 javap 命令计算出来的常量池，找出对应的类和父类的常量，结果如代码清单6-3 所示。</p><p>代码清单6-3 部分常量池内容</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const #1 = class	#2;	// org/fenixsoft/clazz/TestClass 
const #2 = Asciz	org/fenixsoft/clazz/TestClass;
const #3 = class	#4;	// java/lang/Object
const #4 = Asciz	java/lang/Object;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-5-字段表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-5-字段表集合" aria-hidden="true">#</a> 6.3.5 字段表集合</h3><p>字段表（field_info）用于描述接口或者类中声明的变量。Java 语言中的 “字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。读者可以回忆一下在 Java 语言中描述一个字段可以包含哪些信息。字段可以包括的修饰符有字段的作用域（public、private、protected 修饰符）、是实例变量还是类变量（static 修饰符）、可变性（final）、并发可见性（volatile 修饰符，是否强制从主内存读写）、可否被序列化（transient 修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。表6-8 中列出了字段表的最终格式。</p><p>表6-8 字段表结构</p><p><img src="/assets/表6-8.fd00ef14.png" alt="表6-8" loading="lazy"></p><p>字段修饰符放在 access_flags 项目中，它与类中的 access_flags 项目是非常类似的，都是一个 u2 的数据类型，其中可以设置的标志位和含义如表6-9 所示。</p><p>表6-9 字段访问标志</p><p><img src="/assets/表6-9.faca6c3d.png" alt="表6-9" loading="lazy"></p><p>很明显，由于语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED 三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE 不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL 标志，这些都是由 Java 本身的语言规则所导致的。</p><p>跟随 access_flags 标志的是两项索引值：name_index 和 descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下 “简单名称”、“描述符” 以及前面出现过多次的 “全限定名” 这三种特殊字符串的概念。</p><p>全限定名和简单名称很好理解，以代码清单6-1 中的代码为例，&quot;org/fenixsoft/clazz/TestClass&quot; 是这个类的全限定名，仅仅是把类全名中的 &quot;.&quot; 替换成了 &quot;/&quot; 而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 &quot;;&quot; 号表示全限定名结束。简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的 inc() 方法和 m 字段的简单名称分别就是 &quot;inc&quot; 和 &quot;m&quot;。</p><p>相比于全限定名和简单名称，方法和字段的描述符就要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见表6-10。</p><p>表6-10 描述符标识字符含义</p><p><img src="/assets/表6-10.b7d56ae6.png" alt="表6-10" loading="lazy"></p><p><strong>注</strong>：void 类型在《Java 虚拟机规范》之中单独列出为 &quot;VoidDescriptor&quot;，笔者为了结构统一，将其列在基本数据类型中一起描述。</p><p>对于数组类型，每一维度将使用一个前置的 &quot;[&quot; 字符来描述，如一个定义为 &quot;java.lang.String&quot; 类型的二维数组将被记录成 &quot;[[Ljava/lang/String;&quot;，一个整型数组 &quot;int[]&quot; 将被记录成 &quot;[I&quot;。</p><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号 &quot;()&quot; 之内。如方法 void inc() 的描述符为 &quot;()V&quot;，方法 java.lang.String toString() 的描述符为 &quot;()Ljava/lang/String;&quot;，方法 int indexOf(char[]source, int sourceOffset, int sourceCount, char[]target, int targetOffset, int targetCount, int fromIndex) 的描述符为&quot;([CII[CIII)I&quot;。</p><p>对于代码清单6-1 所编译的 TestClass.class 文件来说，字段表集合从地址 0x000000F8 开始，第一个 u2 类型的数据为容量计数器 fields_count，如图6-8 所示，其值为 0x0001，说明这个类只有一个字段表数据。接下来紧跟着容量计数器的是 access_flags 标志，值为 0x0002，代表 private 修饰符的 ACC_PRIVATE 标志位为真（ACC_PRIVATE 标志的值为 0x0002），其他修饰符为假。代表字段名称的 name_index 的值为 0x0005，从代码清单6-2 列出的常量表中可查得第五项常量是一个 CONSTANT_Utf8_info 类型的字符串，其值为 &quot;m&quot;，代表字段描述符的 descriptor_index 的值为 0x0006，指向常量池的字符串 &quot;I&quot;。根据这些信息，我们可以推断出原代码定义的字段为 &quot;private int m;&quot;。</p><p><img src="/assets/图6-8.d950108f.png" alt="图6-8" loading="lazy"></p><p>图6-8 字段表结构实例</p><p>字段表所包含的固定数据项目到 descriptor_index 为止就全部结束了，不过在 descriptor_index 之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。对于本例中的字段 m，它的属性表计数器为 0，也就是没有需要额外描述的信息，但是，如果将字段 m 的声明改为 &quot;final static int m=123;&quot;，那就可能会存在一项名称为 ConstantValue 的属性，其值指向常量 123。关于 attribute_info 的其他内容，将在 6.3.7 节介绍属性表的数据项目时再做进一步讲解。</p><p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于 Class 文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。</p><h3 id="_6-3-6-方法表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-6-方法表集合" aria-hidden="true">#</a> 6.3.6 方法表集合</h3><p>如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class 文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，如表6-11 所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><p>表6-11 方法表结构</p><p><img src="/assets/表6-11.e2115d96.png" alt="表6-11" loading="lazy"></p><p>因为 volatile 关键字和 transient 关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE 标志和 ACC_TRANSIENT 标志。与之相对，synchronized、native、strictfp 和 abstract 关键字可以修饰方法，方法表的访问标志中也相应地增加了 ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP 和 ACC_ABSTRACT 标志。对于方法表，所有标志位及其取值可参见表6-12。</p><p>表6-12 方法访问标志</p><p><img src="/assets/表6-12.3a42cebe.png" alt="表6-12" loading="lazy"></p><p>行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了？方法里的 Java 代码，经过 Javac 编译器编译成字节码指令之后，存放在方法属性表集合中一个名为 &quot;Code&quot; 的属性里面，属性表作为 Class 文件格式中最具扩展性的一种数据项目，将在下一节中详细讲解。</p><p>我们继续以代码清单6-1 中的 Class 文件为例对方法表集合进行分析。如图6-9 所示，方法表集合的入口地址为 0x00000101，第一个 u2 类型的数据（即计数器容量）的值为 0x0002，代表集合中有两个方法，这两个方法为编译器添加的实例构造器 &lt;init&gt; 和源码中定义的方法 inc()。第一个方法的访问标志值为 0x0001，也就是只有 ACC_PUBLIC 标志为真，名称索引值为 0x0007，查代码清单6-2 的常量池得方法名为 &quot;&lt;init&gt;&quot;，描述符索引值为 0x0008，对应常量为 &quot;()V&quot;，属性表计数器 attributes_count 的值为 0x0001，表示此方法的属性表集合有 1 项属性，属性名称的索引值为 0x0009，对应常量为 &quot;Code&quot;，说明此属性是方法的字节码描述。</p><p><img src="/assets/图6-9.4a2097a9.png" alt="图6-9" loading="lazy"></p><p>图6-9 方法表结构实例</p><p>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器 &quot;&lt;clinit&gt;()&quot; 方法和实例构造器 &quot;&lt;init&gt;()&quot; 方法<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>。</p><p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名<sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup>。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在 Class 文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。</p><h3 id="_6-3-7-属性表集合" tabindex="-1"><a class="header-anchor" href="#_6-3-7-属性表集合" aria-hidden="true">#</a> 6.3.7 属性表集合</h3><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class 文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p><p>与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java 虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。为了能正确解析 Class 文件，《Java 虚拟机规范》最初只预定义了 9 项所有 Java 虚拟机实现都应当能识别的属性，而在最新的《Java 虚拟机规范》的 Java SE 12 版本中，预定义属性已经增加到 29 项，这些属性具体见表6-13。后文中将对这些属性中的关键的、常用的部分进行讲解。</p><p>表6-13 虚拟机规范预定义的属性</p><p><img src="/assets/表6-13-1.4600db72.png" alt="表6-13-1" loading="lazy"></p><p><img src="/assets/表6-13-2.b12e8d8c.png" alt="表6-13-2" loading="lazy"></p><p>对于每一个属性，它的名称都要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14 中所定义的结构。</p><p>表6-14 属性表结构</p><p><img src="/assets/表6-14.a1f464ff.png" alt="表6-14" loading="lazy"></p><ol><li><p>Code 属性</p><p>Java 程序方法体里面的代码经过 Javac 编译器处理之后，最终变为字节码指令存储在 Code 属性内。Code 属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在 Code 属性，如果方法表有 Code 属性存在，那么它的结构将如表6-15 所示。</p><p>表6-15 Code 属性表的结构</p><p><img src="/assets/表6-15.34e2e54f.png" alt="表6-15" loading="lazy"></p><p>attribute_name_index 是一项指向 CONSTANT_Utf8_info 型常量的索引，此常量值固定为 &quot;Code&quot;，它代表了该属性的属性名称，attribute_length 指示了属性值的长度，由于属性名称索引与属性长度一共为 6 个字节，所以属性值的长度固定为整个属性表长度减去 6 个字节。</p><p>max_stack 代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p><p>max_locals 代表了局部变量表所需的存储空间。在这里，max_locals 的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于 byte、char、float、int、short、boolean 和 returnAddress 等长度不超过 32 位的数据类型，每个局部变量占用一个变量槽，而 double 和 long 这两种 64 位的数据类型则需要两个变量槽来存放。方法参数（包括实例方法中的隐藏参数 &quot;this&quot;）、显式异常处理程序的参数（Exception Handler Parameter，就是 try-catch 语句中 catch 块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。注意，并不是在方法中用了多少个局部变量，就把这些局部变量所占变量槽数量之和作为 max_locals 的值，操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java 虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac 编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出 max_locals 的大小。</p><p>code_length 和 code 用来存储 Java 源程序编译后生成的字节码指令。code_length 代表字节码长度，code 是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个 u1 类型的单字节，当虚拟机读取到 code 中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个 u1 数据类型的取值范围为 0x00 ~ 0xFF，对应十进制的 0 ~ 255，也就是一共可以表达 256 条指令。目前，《Java 虚拟机规范》已经定义了其中约 200 条编码值对应的指令含义，编码与指令之间的对应关系可查阅本书的附录 C “虚拟机字节码指令表”。</p><p>关于 code_length，有一件值得注意的事情，虽然它是一个 u4 类型的长度值，理论上最大值可以达到 2 的 32 次幂，但是《Java 虚拟机规范》中明确限制了一个方法不允许超过 65535 条字节码指令，即它实际只使用了 u2 的长度，如果超过这个限制，Javac 编译器就会拒绝编译。一般来讲，编写 Java 代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。但是，某些特殊情况，例如在编译一个很复杂的 JSP 文件时，某些 JSP 编译器会把 JSP 内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。</p><p>Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码（Code，方法体里面的 Java 代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个 Class 文件里，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。了解 Code 属性是学习后面两章关于字节码执行引擎内容的必要基础，能直接阅读字节码也是工作中分析 Java 代码语义问题的必要工具和基本技能，为此，笔者准备了一个比较详细的实例来讲解虚拟机是如何使用这个属性的。</p><p>继续以代码清单6-1 的 TestClass.class 文件为例，如图6-10 所示，这是上一节分析过的实例构造器 &quot;&lt;init&gt;()&quot; 方法的 Code 属性。它的操作数栈的最大深度和本地变量表的容量都为 0x0001，字节码区域所占空间的长度为 0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的 5 个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译 &quot;2A B7 000A B1&quot; 的过程为：</p><p><img src="/assets/图6-10.3f611e3e.png" alt="图6-10" loading="lazy"></p><p>图6-10 Code 属性结构实例</p><p>1）读入 2A，查表得 0x2A 对应的指令为 aload_0，这个指令的含义是将第 0 个变量槽中为 reference 类型的本地变量推送到操作数栈顶。</p><p>2）读入 B7，查表得 0xB7 对应的指令为 invokespecial，这条指令的作用是以栈顶的 reference 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private 方法或者它的父类的方法。这个方法有一个 u2 类型的参数说明具体调用哪一个方法，它指向常量池中的一个 CONSTANT_Methodref_info 类型常量，即此方法的符号引用。</p><p>3）读入 000A，这是 invokespecial 指令的参数，代表一个符号引用，查常量池得 0x000A 对应的常量为实例构造器 &quot;&lt;init&gt;()&quot; 方法的符号引用。</p><p>4）读入 B1，查表得 0xB1 对应的指令为 return，含义是从方法的返回，并且返回值为 void。这条指令执行后，当前方法正常结束。</p><p>这段字节码虽然很短，但我们可以从中看出它执行过程中的数据交换、方法调用等操作都是基于栈（操作数栈）的。我们可以初步猜测，Java 虚拟机执行字节码应该是基于栈的体系结构。但又发现与通常基于栈的指令集里都是无参数的又不太一样，某些指令（如 invokespecial）后面还会带有参数，关于虚拟机字节码执行的讲解是后面两章的话题，我们不妨把这里的疑问放到第 8 章去解决。</p><p>我们再次使用 javap 命令把此 Class 文件中的另一个方法的字节码指令也计算出来，结果如代码清单6-4 所示。</p><p>代码清单6-4 用 Javap 命令计算字节码指令</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 原始 Java 代码
public class TestClass {
    private int m;

    public int inc() {
        return m + 1;
    }
}

C:\&gt;javap -verbose TestClass
// 常量表部分的输出见代码清单6-1，因版面原因这里省略掉
{
public org.fenixsoft.clazz.TestClass(); 
    Code:
        Stack=1, Locals=1, Args_size=1 
        0:  aload_0
        1:  invokespecial	#10; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
        4:  return 
    LineNumberTable:
    	line 3: 0

    LocalVariableTable:
        Start  Length  Slot  Name	Signature
        0	5	0	this	Lorg/fenixsoft/clazz/TestClass;

public int inc(); 
    Code:
        Stack=2, Locals=1, Args_size=1 
        0:  aload_0
        1:  getfield	#18; //Field m:I
        4:  iconst_1
        5:  iadd
        6:  ireturn 
    LineNumberTable:
    	line 8: 0

    LocalVariableTable:
        Start  Length  Slot  Name	Signature
        0	7	0	this	Lorg/fenixsoft/clazz/TestClass;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果大家注意到 javap 中输出的 &quot;Args_size&quot; 的值，可能还会有疑问：这个类有两个方法——实例构造器 &lt;init&gt;() 和 inc()，这两个方法很明显都是没有参数的，为什么 Args_size 会为 1？而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那 Locals 又为什么会等于 1？如果有这样疑问的读者，大概是忽略了一条 Java 语言里面的潜规则：在任何实例方法里面，都可以通过 &quot;this&quot; 关键字访问到此方法所属的对象。这个访问机制对 Java 程序的编写很重要，而它的实现非常简单，仅仅是通过在 Javac 编译器编译的时候把对 this 关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从 1 开始计算。这个处理只对实例方法有效，如果代码清单6-1 中的 inc() 方法被声明为 static，那 Args_size 就不会等于 1 而是等于 0 了。</p><p>在字节码指令之后的是这个方法的显式异常处理表（下文简称 “异常表”）集合，异常表对于 Code 属性来说并不是必须存在的，如代码清单6-4 中就没有异常表生成。</p><p>如果存在异常表，那它的格式应如表6-16 所示，包含四个字段，这些字段的含义为：如果当字节码从第 start_pc 行<sup class="footnote-ref"><a href="#footnote9">[9]</a><a class="footnote-anchor" id="footnote-ref9"></a></sup>到第 end_pc 行之间（不含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type 为指向一个 CONSTANT_Class_info 型常量的索引），则转到第 handler_pc 行继续处理。当 catch_type 的值为 0 时，代表任意异常情况都需要转到 handler_pc 处进行处理。</p><p>表6-16 属性表结构</p><p><img src="/assets/表6-16.3d424e5a.png" alt="表6-16" loading="lazy"></p><p>异常表实际上是 Java 代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，但《Java 虚拟机规范》中明确要求 Java 语言的编译器应当选择使用异常表而不是通过跳转指令来实现 Java 异常及 finally 处理机制<sup class="footnote-ref"><a href="#footnote10">[10]</a><a class="footnote-anchor" id="footnote-ref10"></a></sup>。</p><p>代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了在字节码层面 try-catch-finally 是如何体现的。阅读字节码之前，大家不妨先看看下面的 Java 源码，想一下这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少？</p><p>代码清单6-5 异常表运作演示</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// Java 源码
public int inc() {
    int x;
    try {
        x = 1;
        return x;
    } catch (Exception e) {
        x = 2;
        return x;
    } finally {
        x = 3;
    }
}

// 编译后的 ByteCode 字节码及异常表
public int inc(); 
    Code:
        Stack=1, Locals=5, Args_size=1
        0:  iconst_1    // try 块中的 x = 1 
        1:  istore_1
        2:  iload_1     // 保存 x 到 returnValue 中，此时 x = 1
        3:  istore 4
        5:  iconst_3    // finaly 块中的 x = 3 
        6:  istore_1
        7:  iload 4     // 将 returnValue 中的值放到栈顶，准备给 ireturn 返回
        9:  ireturn
        10:  astore_2   // 给 catch 中定义的 Exception e 赋值，存储在变量槽 2 中
        11:  iconst_2   // catch 块中的 x = 2
        12:  istore_1
        13:  iload_1    // 保存 x 到 returnValue 中，此时 x = 2 
        14:  istore 4
        16:  iconst_3   // finaly 块中的 x = 3
        17:  istore_1
        18:  iload 4    // 将 returnValue 中的值放到栈顶，准备给 ireturn 返回
        20:  ireturn
        21:  astore_3   // 如果出现了不属于 java.lang.Exception 及其子类的异常才会走到这里
        22:  iconst_3   // finaly 块中的 x = 3 
        23:  istore_1
        24:  aload_3    // 将异常放置到栈顶，并抛出
        25:  athrow 
    Exception table:
        from  to  target  type
        0     5   10      Class java/lang/Exception 
        0     5   21      any
        10    16  21      any
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器为这段 Java 源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从 Java 代码的语义上讲，这三条执行路径分别为：</p><ul><li>如果 try 语句块中出现属于 Exception 或其子类的异常，转到 catch 语句块处理；</li><li>如果 try 语句块中出现不属于 Exception 或其子类的异常，转到 finally 语句块处理；</li><li>如果 catch 语句块中出现任何异常，转到 finally 语句块处理。</li></ul><p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉 Java 语言的读者应该很容易说出答案：如果没有出现异常，返回值是 1；如果出现了 Exception 异常，返回值是 2；如果出现了 Exception 以外的异常，方法非正常退出，没有返回值。我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p><p>字节码中第 0 ~ 4 行所做的操作就是将整数 1 赋值给变量 x，并且将此时 x 的值复制一份副本到最后一个本地变量表的变量槽中（这个变量槽里面的值在 ireturn 指令执行前将会被重新读到操作栈顶，作为方法返回值使用。为了讲解方便，笔者给这个变量槽起个名字：returnValue）。如果这时候没有出现异常，则会继续走到第 5 ~ 9 行，将变量 x 赋值为 3，然后将之前保存在 returnValue 中的整数 1 读入到操作栈顶，最后 ireturn 指令会以 int 形式返回操作栈顶中的值，方法结束。如果出现了异常，PC 寄存器指针转到第 10 行，第 10 ~ 20 行所做的事情是将 2 赋值给变量 x，然后将变量 x 此时的值赋给 returnValue，最后再将变量 x 的值改为 3。方法返回前同样将 returnValue 中保留的整数 2 读到了操作栈顶。从第 21 行开始的代码，作用是将变量 x 的值赋为 3，并将栈顶的异常抛出，方法结束。</p><p>尽管大家都知道这段代码出现异常的概率非常之小，但是并不影响它为我们演示异常表的作用。如果大家到这里仍然对字节码的运作过程比较模糊，其实也不要紧，关于虚拟机执行字节码的过程，本书第 8 章中将会有更详细的讲解。</p></li><li><p>Exceptions 属性</p><p>这里的 Exceptions 属性是在方法表中与 Code 属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions 属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在 throws 关键字后面列举的异常。它的结构见表6-17。</p><p>表6-17 Exceptions 属性结构</p><p><img src="/assets/表6-17.a250dcd8.png" alt="表6-17" loading="lazy"></p><p>此属性中的 number_of_exceptions 项表示方法可能抛出 number_of_exceptions 种受查异常，每一种受查异常使用一个 exception_index_table 项表示；exception_index_table 是一个指向常量池中 CONSTANT_Class_info 型常量的索引，代表了该受查异常的类型。</p></li><li><p>LineNumberTable 属性</p><p>LineNumberTable 属性用于描述 Java 源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中使用 -g:none或 -g:lines 选项来取消或要求生成这项信息。如果选择不生成 LineNumberTable 属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。LineNumberTable 属性的结构如表6-18 所示。</p><p>表6-18 LineNumberTable 属性结构</p><p><img src="/assets/表6-18.c6b92957.png" alt="表6-18" loading="lazy"></p><p>line_number_table 是一个数量为 line_number_table_length、类型为 line_number_info 的集合，line_number_info 表包含 start_pc 和 line_number 两个 u2 类型的数据项，前者是字节码行号，后者是 Java 源码行号。</p></li><li><p>LocalVariableTable 及 LocalVariableTypeTable 属性</p><p>LocalVariableTable 属性用于描述栈帧中局部变量表的变量与 Java 源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中使用 -g:none 或 -g:vars 选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如 IDE 将会使用诸如 arg0、arg1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。LocalVariableTable 属性的结构如表6-19 所示。</p><p>表6-19 LocalVariableTable 属性结构</p><p><img src="/assets/表6-19.fbc2ddf6.png" alt="表6-19" loading="lazy"></p><p>其中 local_variable_info 项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20 所示。</p><p>表6-20 local_variable_info 项目结构</p><p><img src="/assets/表6-20.f16aa018.png" alt="表6-20" loading="lazy"></p><p>start_pc 和 length 属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p><p>name_index 和 descriptor_index 都是指向常量池中 CONSTANT_Utf8_info 型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p><p>index 是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是 64 位类型时（double 和 long），它占用的变量槽为 index 和i ndex + 1 两个。</p><p>顺便提一下，在 JDK 5 引入泛型之后，LocalVariableTable 属性增加了一个 “姐妹属性”—— LocalVariableTypeTable。这个新增的属性结构与 LocalVariableTable 非常相似，仅仅是把记录的字段描述符的 descriptor_index 替换成了字段的特征签名（Signature）。对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉<sup class="footnote-ref"><a href="#footnote11">[11]</a><a class="footnote-anchor" id="footnote-ref11"></a></sup>，描述符就不能准确描述泛型类型了。因此出现了 LocalVariableTypeTable 属性，使用字段的特征签名来完成泛型的描述。</p></li><li><p>SourceFile 及 SourceDebugExtension 属性</p><p>SourceFile 属性用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以使用 Javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性，其结构如表6-21 所示。</p><p>表6-21 SourceFile 属性结构</p><p><img src="/assets/表6-21.f7360d66.png" alt="表6-21" loading="lazy"></p><p>sourcefile_index 数据项是指向常量池中 CONSTANT_Utf8_info 型常量的索引，常量值是源码文件的文件名。</p><p>为了方便在编译器和动态生成的 Class 中加入供程序员使用的自定义内容，在 JDK 5 时，新增了 SourceDebugExtension 属性用于存储额外的代码调试信息。典型的场景是在进行 JSP 文件调试时，无法通过 Java 堆栈来定位到 JSP 文件的行号。JSR-45 提案为这些非 Java 语言编写，却需要编译成字节码并运行在 Java 虚拟机中的程序提供了一个进行调试的标准机制，使用 SourceDebugExtension 属性就可以用于存储这个标准所新加入的调试信息，譬如让程序员能够快速从异常堆栈中定位出原始 JSP 中出现问题的行号。SourceDebugExtension 属性的结构如表6-22 所示。</p><p>表6-22 SourceDebugExtension 属性结构</p><p><img src="/assets/表6-22.889f1d5e.png" alt="表6-22" loading="lazy"></p><p>其中 debug_extension 存储的就是额外的调试信息，是一组通过变长 UTF-8 格式来表示的字符串。一个类中最多只允许存在一个 SourceDebugExtension 属性。</p></li><li><p>ConstantValue 属性</p><p>ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似 &quot;int x=123&quot; 和 &quot;static int x=123&quot; 这样的变量定义在 Java 程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 &lt;init&gt;() 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 &lt;clinit&gt;() 方法中或者使用 ConstantValue 属性。目前 Oracle 公司实现的 Javac 编译器的选择是，如果同时使用 final 和 static 来修饰一个变量（按照习惯，这里称 “常量” 更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就将会生成 ConstantValue 属性来进行初始化；如果这个变量没有被 final 修饰，或者并非基本类型及字符串，则将会选择在 &lt;clinit&gt;() 方法中进行初始化。</p><p>虽然有 final 关键字才更符合 &quot;ConstantValue&quot; 的语义，但《Java 虚拟机规范》中并没有强制要求字段必须设置 ACC_FINAL 标志，只要求有 ConstantValue 属性的字段必须设置 ACC_STATIC 标志而已，对 final 关键字的要求是 Javac 编译器自己加入的限制。而对 ConstantValue 的属性值只能限于基本类型和 String 这点，其实并不能算是什么限制，这是理所当然的结果。因为此属性的属性值只是一个常量池的索引号，由于 Class 文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算 ConstantValue 属性想支持别的类型也无能为力。ConstantValue 属性的结构如表6-23 所示。</p><p>表6-23 ConstantValue属性结构</p><p><img src="/assets/表6-23.e28dbd83.png" alt="表6-23" loading="lazy"></p><p>从数据结构中可以看出 ConstantValue 属性是一个定长属性，它的 attribute_length 数据项值必须固定为 2。constantvalue_index 数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是 CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info 和 CONSTANT_String_info 常量中的一种。</p></li><li><p>InnerClasses 属性</p><p>InnerClasses 属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClasses 属性。InnerClasses 属性的结构如表6-24 所示。</p><p>表6-24 InnerClasses 属性结构</p><p><img src="/assets/表6-24.b3d31d23.png" alt="表6-24" loading="lazy"></p><p>数据项 number_of_classes 代表需要记录多少个内部类信息，每一个内部类的信息都由一个 inner_classes_info 表进行描述。inner_classes_info 表的结构如表6-25 所示。</p><p>表6-25 inner_classes_info 表的结构</p><p><img src="/assets/表6-25.5d220f1c.png" alt="表6-25" loading="lazy"></p><p>inner_class_info_index 和 outer_class_info_index 都是指向常量池中 CONSTANT_Class_info 型常量的索引，分别代表了内部类和宿主类的符号引用。</p><p>inner_name_index 是指向常量池中 CONSTANT_Utf8_info 型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为 0。</p><p>inner_class_access_flags 是内部类的访问标志，类似于类的 access_flags，它的取值范围如表6-26 所示。</p><p>表6-26 inner_class_access_flags 标志</p><p><img src="/assets/表6-26.c6ea1b2d.png" alt="表6-26" loading="lazy"></p></li><li><p>Deprecated 及 Synthetic 属性</p><p>Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><p>Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用 &quot;@deprecated&quot; 注解进行设置。</p><p>Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位。编译器通过生成一些在源代码中不存在的 Synthetic 方法、字段甚至是整个类的方式，实现了越权访问（越过 private 修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。所有由不属于用户代码产生的类、方法及字段都应当至少设置 Synthetic 属性或者 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器 &quot;&lt;init&gt;()&quot; 方法和类构造器 &quot;&lt;clinit&gt;()&quot; 方法。</p><p>Deprecated 和 Synthetic 属性的结构非常简单，如表6-27 所示。</p><p>表6-27 Deprecated 及 Synthetic 属性结构</p><p><img src="/assets/表6-27.d6b5000c.png" alt="表6-27" loading="lazy"></p><p>其中 attribute_length 数据项的值必须为 0x00000000，因为没有任何属性值需要设置。</p></li><li><p>StackMapTable 属性</p><p>StackMapTable 属性在 JDK 6 增加到 Class 文件规范之中，它是一个相当复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（详见第 7 章字节码验证部分），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><p>这个类型检查验证器最初来源于 Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）实现为 Java ME CLDC 实现的字节码验证器。新的验证器在同样能保证 Class 文件合法性的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而在编译阶段将一系列的验证类型（Verification Type）直接记录在 Class 文件之中，通过检查这些验证类型代替了类型推导过程，从而大幅提升了字节码验证的性能。这个验证器在 JDK 6 中首次提供，并在 JDK 7 中强制代替原本基于类型推断的字节码验证器。关于这个验证器的工作原理，《Java 虚拟机规范》在 Java SE 7 版中新增了整整 120 页的篇幅来讲解描述，其中使用了庞大而复杂的公式化语言去分析证明新验证方法的严谨性，笔者在此就不展开赘述了。</p><p>StackMapTable 属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。StackMapTable 属性的结构如表6-28 所示。</p><p>表6-28 StackMapTable 属性结构</p><p><img src="/assets/表6-28.cd27018c.png" alt="表6-28" loading="lazy"></p><p>在 Java SE 7 版之后的《Java 虚拟机规范》中，明确规定对于版本号大于或等于 50.0 的 Class 文件，如果方法的 Code 属性中没有附带 StackMapTable 属性，那就意味着它带有一个隐式的 StackMap 属性，这个 StackMap 属性的作用等同于 number_of_entries 值为 0 的 StackMapTable 属性。一个方法的 Code 属性最多只能有一个 StackMapTable 属性，否则将抛出 ClassFormatError 异常。</p></li><li><p>Signature 属性</p><p>Signature 属性在 JDK 5 增加到 Class 文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。在 JDK 5 里面大幅增强了 Java 语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（Parameterized Type），则 Signature 属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，字节码（Code 属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改 Javac 编译器，虚拟机内部只做了很少的改动）、非常容易实现 Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像 C# 等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature 属性就是为了弥补这个缺陷而增设的，现在 Java 的反射 API 能够获取的泛型类型，最终的数据来源也是这个属性。关于 Java 泛型、Signature 属性和类型擦除，在第 10 章讲编译器优化的时候我们会通过一个更具体的例子来讲解。Signature 属性的结构如表6-29 所示。</p><p>表6-29 Signature 属性结构</p><p><img src="/assets/表6-29.2767b099.png" alt="表6-29" loading="lazy"></p><p>其中 signature_index 项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示类签名或方法类型签名或字段类型签名。如果当前的 Signature 属性是类文件的属性，则这个结构表示类签名，如果当前的 Signature 属性是方法表的属性，则这个结构表示方法类型签名，如果当前 Signature 属性是字段表的属性，则这个结构表示字段类型签名。</p></li><li><p>BootstrapMethods 属性</p><p>BootstrapMethods 属性在 JDK 7 时增加到 Class 文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。</p><p>根据《Java 虚拟机规范》（从 Java SE 7 版起）的规定，如果某个类文件结构的常量池中曾经出现过 CONSTANT_InvokeDynamic_info 类型的常量，那么这个类文件的属性表中必须存在一个明确的 BootstrapMethods 属性，另外，即使 CONSTANT_InvokeDynamic_info 类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个 BootstrapMethods 属性。BootstrapMethods 属性和 JSR-292 中的 InvokeDynamic 指令和 java.lang.Invoke 包关系非常密切，要介绍这个属性的作用，必须先讲清楚 InovkeDynamic 指令的运作原理，笔者将在第 8 章专门花一整节篇幅去介绍它们，在此先暂时略过。</p><p>虽然 JDK 7 中已经提供了 InovkeDynamic 指令，但这个版本的 Javac 编译器还暂时无法支持 InvokeDynamic 指令和生成 BootstrapMethods 属性，必须通过一些非常规的手段才能使用它们。直到 JDK 8 中 Lambda 表达式和接口默认方法的出现，InvokeDynamic 指令才算在 Java 语言生成的 Class 文件中有了用武之地。BootstrapMethods 属性的结构如表6-30 所示。</p><p>表6-30 BootstrapMethods 属性结构</p><p><img src="/assets/表6-30.26e357bc.png" alt="表6-30" loading="lazy"></p><p>其中引用到的 bootstrap_method 结构如表6-31 所示。</p><p>表6-31 bootstrap_method 属性结构</p><p><img src="/assets/表6-31.779a5735.png" alt="表6-31" loading="lazy"></p><p>BootstrapMethods 属性里，num_bootstrap_methods 项的值给出了 bootstrap_methods[] 数组中的引导方法限定符的数量。而 bootstrap_methods[] 数组的每个成员包含了一个指向常量池 CONSTANT_MethodHandle 结构的索引值，它代表了一个引导方法。还包含了这个引导方法静态参数的序列（可能为空）。bootstrap_methods[] 数组的每个成员必须包含以下三项内容：</p><ul><li><p>bootstrap_method_ref：bootstrap_method_ref 项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个 CONSTANT_MethodHandle_info 结构。</p></li><li><p>num_bootstrap_arguments：num_bootstrap_arguments 项的值给出了 bootstrap_arguments[] 数组成员的数量。</p></li><li><p>bootstrap_arguments[]：bootstrap_arguments[] 数组的每个成员必须是一个对常量池的有效索引。</p><p>常量池在该索引出必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info 或 CONSTANT_MethodType_info。</p></li></ul></li><li><p>MethodParameters 属性</p><p>MethodParameters 是在 JDK 8 时新加入到 Class 文件格式中的，它是一个用在方法表中的变长属性。MethodParameters 的作用是记录方法的各个形参名称和信息。</p><p>最初，基于存储空间的考虑，Class 文件默认是不储存方法参数名称的，因为给参数起什么名字对计算机执行程序来说是没有任何区别的，所以只要在源码中妥当命名就可以了。随着 Java 的流行，这点确实为程序的传播和二次复用带来了诸多不便，由于 Class 文件中没有参数的名称，如果只有单独的程序包而不附加上 JavaDoc 的话，在 IDE 中编辑使用包里面的方法时是无法获得方法调用的智能提示的，这就阻碍了 JAR 包的传播。后来，&quot;-g:var&quot; 就成为了 Javac 以及许多 IDE 编译 Class 时采用的默认值，这样会将方法参数的名称生成到 LocalVariableTable 属性之中。不过此时问题仍然没有全部解决，</p><p>LocalVariableTable 属性是 Code 属性的子属性——没有方法体存在，自然就不会有局部变量表，但是对于其他情况，譬如抽象方法和接口方法，是理所当然地可以不存在方法体的，对于方法签名来说，还是没有找到一个统一完整的保留方法参数名称的地方。所以 JDK 8 中新增的这个属性，使得编译器可以（编译时加上 -parameters 参数）将方法名称也写进 Class 文件中，而且 MethodParameters 是方法表的属性，与 Code 属性平级的，可以运行时通过反射 API 获取。MethodParameters 的结构如表6-32 所示。</p><p>表6-32 MethodParameters 属性结构</p><p><img src="/assets/表6-32.60f24dbd.png" alt="表6-32" loading="lazy"></p><p>其中，引用到的 parameter 结构如表6-33 所示。</p><p>表6-33 parameter 属性结构</p><p><img src="/assets/表6-33.5336ce70.png" alt="表6-33" loading="lazy"></p><p>其中，name_index 是一个指向常量池 CONSTANT_Utf8_info 常量的索引值，代表了该参数的名称。而 access_flags 是参数的状态指示器，它可以包含以下三种状态中的一种或多种：</p><ul><li>0x0010（ACC_FINAL）：表示该参数被 final 修饰。</li><li>0x1000（ACC_SYNTHETIC）：表示该参数并未出现在源文件中，是编译器自动生成的。</li><li>0x8000（ACC_MANDATED）：表示该参数是在源文件中隐式定义的。Java 语言中的典型场景是 this 关键字。</li></ul></li><li><p>模块化相关属性</p><p>JDK 9 的一个重量级功能是 Java 的模块化功能，因为模块描述文件（module-info.java）最终是要编译成一个独立的 Class 文件来存储的，所以，Class 文件格式也扩展了 Module、ModulePackages 和 ModuleMainClass 三个属性用于支持 Java 模块化相关功能。</p><p>Module 属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块 requires、exports、opens、uses 和 provides 定义的全部内容，其结构如表6-34 所示。</p><p>表6-34 Module 属性结构</p><p><img src="/assets/表6-34.dddd5fa6.png" alt="表6-34" loading="lazy"></p><p>其中，module_name_index 是一个指向常量池 CONSTANT_Utf8_info 常量的索引值，代表了该模块的名称。而 module_flags 是模块的状态指示器，它可以包含以下三种状态中的一种或多种：</p><ul><li>0x0020（ACC_OPEN）：表示该模块是开放的。</li><li>0x1000（ACC_SYNTHETIC）：表示该模块并未出现在源文件中，是编译器自动生成的。</li><li>0x8000（ACC_MANDATED）：表示该模块是在源文件中隐式定义的。</li></ul><p>module_version_index 是一个指向常量池 CONSTANT_Utf8_info 常量的索引值，代表了该模块的版本号。</p><p>后续的几个属性分别记录了模块的 requires、exports、opens、uses 和 provides 定义，由于它们的结构是基本相似的，为了节省版面，笔者仅介绍其中的 exports，该属性结构如表6-35 所示。</p><p>表6-35 exports 属性结构</p><p><img src="/assets/表6-35.c25867b6.png" alt="表6-35" loading="lazy"></p><p>exports 属性的每一元素都代表一个被模块所导出的包，exports_index 是一个指向常量池 CONSTANT_Package_info 常量的索引值，代表了被该模块导出的包。exports_flags 是该导出包的状态指示器，它可以包含以下两种状态中的一种或多种：</p><ul><li>0x1000（ACC_SYNTHETIC）：表示该导出包并未出现在源文件中，是编译器自动生成的。</li><li>0x8000（ACC_MANDATED）：表示该导出包是在源文件中隐式定义的。</li></ul><p>exports_to_count 是该导出包的限定计数器，如果这个计数器为零，这说明该导出包是无限定的（Unqualified），即完全开放的，任何其他模块都可以访问该包中所有内容。如果该计数器不为零，则后面的 exports_to_index 是以计数器值为长度的数组，每个数组元素都是一个指向常量池中 CONSTANT_Module_info 常量的索引值，代表着只有在这个数组范围内的模块才被允许访问该导出包的内容。</p><p>ModulePackages 是另一个用于支持 Java 模块化的变长属性，它用于描述该模块中所有的包，不论是不是被 export 或者 open 的。该属性的结构如表6-36 所示。</p><p>表6-36 ModulePackages 属性结构</p><p><img src="/assets/表6-36.62ce669c.png" alt="表6-36" loading="lazy"></p><p>package_count 是 package_index 数组的计数器，package_index 中每个元素都是指向常量池 CONSTANT_Package_info 常量的索引值，代表了当前模块中的一个包。</p><p>最后一个 ModuleMainClass 属性是一个定长属性，用于确定该模块的主类（Main Class），其结构如表6-37 所示。</p><p>表6-37 ModuleMainClass 属性结构</p><p><img src="/assets/表6-37.52e858b3.png" alt="表6-37" loading="lazy"></p><p>其中，main_class_index 是一个指向常量池 CONSTANT_Class_info 常量的索引值，代表了该模块的主类。</p></li><li><p>运行时注解相关属性</p><p>早在 JDK 5 时期，Java 语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。为了存储源码中注解信息，Class 文件同步增加了 RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations 和 RuntimeInvisibleParameterAnnotations 四个属性。到了 JDK 8 时期，进一步加强了 Java 语言的注解使用范围，又新增类型注解（JSR-308），所以 Class 文件中也同步增加了 RuntimeVisibleTypeAnnotations 和 RuntimeInvisibleTypeAnnotations 两个属性。由于这六个属性不论结构还是功能都比较雷同，因此我们把它们合并到一起，以 RuntimeVisibleAnnotations 为代表进行介绍。</p><p>RuntimeVisibleAnnotations 是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射 API 来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。RuntimeVisibleAnnotations 属性的结构如表6-38 所示。</p><p>表6-38 RuntimeVisibleAnnotations 属性结构</p><p><img src="/assets/表6-38.321eb2d6.png" alt="表6-38" loading="lazy"></p><p>num_annotations 是 annotations 数组的计数器，annotations 中每个元素都代表了一个运行时可见的注解，注解在 Class 文件中以 annotation 结构来存储，具体如表6-39 所示。</p><p>表6-39 annotation 属性结构</p><p><img src="/assets/表6-39.f2aa182b.png" alt="表6-39" loading="lazy"></p><p>type_index 是一个指向常量池 CONSTANT_Utf8_info 常量的索引值，该常量应以字段描述符的形式表示一个注解。num_element_value_pairs 是 element_value_pairs 数组的计数器，element_value_pairs 中每个元素都是一个键值对，代表该注解的参数和值。</p></li></ol><h2 id="_6-4-字节码指令简介" tabindex="-1"><a class="header-anchor" href="#_6-4-字节码指令简介" aria-hidden="true">#</a> 6.4 字节码指令简介</h2><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。由于 Java 虚拟机采用面向操作数栈而不是面向寄存器的架构（这两种架构的执行过程、区别和影响将在第 8 章中探讨），所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p><p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为一个字节（即 0 ~ 255），这意味着指令集的操作码总数不能够超过 256 条；又由于 Class 文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，譬如要将一个 16 位长度的无符号整数使用两个无符号字节存储起来（假设将它们命名为 byte1 和 byte2），那它们的值应该是这样的：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(byte1 &lt;&lt; 8) | byte2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显：放弃了操作数长度对齐<sup class="footnote-ref"><a href="#footnote12">[12]</a><a class="footnote-anchor" id="footnote-ref12"></a></sup>，就意味着可以省略掉大量的填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由 Java 语言设计之初主要面向网络、智能家电的技术背景所决定的，并一直沿用至今。</p><p>如果不考虑异常处理的话，那 Java 虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>do {
    自动计算 PC 寄存器的值加 1;
    根据 PC 寄存器指示的位置，从字节码流中取出操作码; 
    if (字节码存在操作数) 从字节码流中取出操作数; 
    执行操作码所定义的操作;
} while (字节码流长度 &gt; 0);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-4-1-字节码与数据类型" tabindex="-1"><a class="header-anchor" href="#_6-4-1-字节码与数据类型" aria-hidden="true">#</a> 6.4.1 字节码与数据类型</h3><p>在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。举个例子，iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。</p><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。也有一些指令的助记符中没有明确指明操作类型的字母，例如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，例如无条件跳转指令 goto 则是与数据类型无关的指令。</p><p>因为 Java 虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持 Java 虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了。因此，Java 虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会被故意设计成非完全独立的。（《Java 虚拟机规范》中把这种特性称为 &quot;Not Orthogonal&quot;，即并非每种数据类型和每一种操作都有对应的指令。）有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p><p>表6-40 列举了 Java 虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的 T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如 load 指令有操作 int 类型的 iload，但是没有操作 byte 类型的同类指令。</p><p>表6-40 Java 虚拟机指令集所支持的数据类型</p><p><img src="/assets/表6-40-1.45b1de67.png" alt="表6-40-1" loading="lazy"></p><p><img src="/assets/表6-40-2.24512f24.png" alt="表6-40-2" loading="lazy"></p><p>请注意，从表6-40 中看来，大部分指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型（Computational Type）来进行的。</p><p>在本书里，受篇幅所限，无法对字节码指令集中每条指令逐一讲解，但阅读字节码作为了解 Java 虚拟机的基础技能，是一项应当熟练掌握的能力。笔者将字节码操作按用途大致分为 9 类，下面按照分类来为读者概略介绍这些指令的用法。如果读者希望了解更详细的信息，可以阅读由 Oracle 官方授权、由笔者翻译的《Java 虚拟机规范（Java SE 7）》中文版（字节码的介绍可见此书第 6 章）。</p><h3 id="_6-4-2-加载和存储指令" tabindex="-1"><a class="header-anchor" href="#_6-4-2-加载和存储指令" aria-hidden="true">#</a> 6.4.2 加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第 2 章关于内存区域的介绍）之间来回传输，这类指令包括：</p><ul><li>将一个局部变量加载到操作栈：iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;</li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</li><li>扩充局部变量表的访问索引的指令：wide</li></ul><p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p><p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 iload_&lt;n&gt;），这些指令助记符实际上代表了一组指令（例如 iload_&lt;n&gt;，它代表了 iload_0、iload_1、iload_2 和 iload_3 这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。除了这点不同以外，它们的语义与原生的通用指令是完全一致的（例如 iload_0 的语义与操作数为 0 时的 iload 指令语义完全一致）。这种指令表示方法，在本书和《Java 虚拟机规范》中都是通用的。</p><h3 id="_6-4-3-运算指令" tabindex="-1"><a class="header-anchor" href="#_6-4-3-运算指令" aria-hidden="true">#</a> 6.4.3 运算指令</h3><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。无论是哪种算术指令，均是使用 Java 虚拟机的算术类型来进行计算的，换句话说是不存在直接支持 byte、short、char 和 boolean 类型的算术指令，对于上述几种数据的运算，应使用操作 int 类型的指令代替。所有的算术指令包括：</p><ul><li>加法指令：iadd、ladd、fadd、dadd</li><li>减法指令：isub、lsub、fsub、dsub</li><li>乘法指令：imul、lmul、fmul、dmul</li><li>除法指令：idiv、ldiv、fdiv、ddiv</li><li>求余指令：irem、lrem、frem、drem</li><li>取反指令：ineg、lneg、fneg、dneg</li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li><li>按位或指令：ior、lor</li><li>按位与指令：iand、land</li><li>按位异或指令：ixor、lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li></ul><p>Java 虚拟机的指令集直接支持了在《Java 语言规范》中描述的各种对整数及浮点数操作（详情参见《Java 语言规范》4.2.2 节和 4.2.4 节）的语义。数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，但其实《Java 虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，只有除法指令（idiv 和 ldiv）以及求余指令（irem 和 lrem）中当出现除数为零时会导致虚拟机抛出 ArithmeticException 异常，其余任何整型数运算场景都不应该抛出运行时异常。</p><p>《Java 虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循 IEEE 754 规范中所规定行为和限制，也就是说 Java 虚拟机必须完全支持 IEEE 754 中定义的 “非正规浮点数值”（Denormalized Floating-Point Number）和 “逐级下溢”（Gradual Underflow）的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境。譬如以上规则要求 Java 虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的。这种舍入模式也是 IEEE 754 规范中的默认舍入模式，称为向最接近数舍入模式。而在把浮点数转换为整数时，Java 虚拟机使用 IEEE 754 标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</p><p>另外，Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是 Java 语言中的异常，请读者勿与 IEEE 754 规范中的浮点异常互相混淆，IEEE 754 的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示；如果某个操作结果没有明确的数学定义的话，将会使用 NaN（Not a Number）值来表示。所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</p><p>在对 long 类型数值进行比较时，Java 虚拟机采用带符号的比较方式，而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用 IEEE 754 规范所定义的无信号比较（Nonsignaling Comparison）方式进行。</p><h3 id="_6-4-4-类型转换指令" tabindex="-1"><a class="header-anchor" href="#_6-4-4-类型转换指令" aria-hidden="true">#</a> 6.4.4 类型转换指令</h3><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java 虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p><ul><li>int 类型到 long、float 或者 double 类型</li><li>long 类型到 float、double 类型</li><li>float 类型到 double 类型</li></ul><p>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括 i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和 d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><p>在将 int 或 long 类型窄化转换为整数类型 T 的时候，转换过程仅仅是简单丢弃除最低位 N 字节以外的内容，N 是类型 T 的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低 N 字节的首位了。</p><p>Java 虚拟机将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，必须遵循以下转换规则：</p><ul><li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0。</li><li>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v。如果 v 在目标类型 T（int 或 long）的表示范围之类，那转换结果就是 v；否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数。</li></ul><p>从 double 类型到 float 类型做窄化转换的过程与 IEEE 754 中定义的一致，通过 IEEE 754 向最接近数舍入模式舍入得到一个可以使用 float 类型表示的数字。如果转换结果的绝对值太小、无法使用 float 来表示的话，将返回 float 类型的正负零；如果转换结果的绝对值太大、无法使用 float 来表示的话，将返回 float 类型的正负无穷大。对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是《Java 虚拟机规范》中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p><h3 id="_6-4-5-对象创建与访问指令" tabindex="-1"><a class="header-anchor" href="#_6-4-5-对象创建与访问指令" aria-hidden="true">#</a> 6.4.5 对象创建与访问指令</h3><p>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在下一章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p><ul><li>创建类实例的指令：new</li><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>访问类字段（static 字段，或者称为类变量）和实例字段（非 static 字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li><li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li><li>取数组长度的指令：arraylength</li><li>检查类实例类型的指令：instanceof、checkcast</li></ul><h3 id="_6-4-6-操作数栈管理指令" tabindex="-1"><a class="header-anchor" href="#_6-4-6-操作数栈管理指令" aria-hidden="true">#</a> 6.4.6 操作数栈管理指令</h3><p>如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li><li>将栈最顶端的两个数值互换：swap</li></ul><h3 id="_6-4-7-控制转移指令" tabindex="-1"><a class="header-anchor" href="#_6-4-7-控制转移指令" aria-hidden="true">#</a> 6.4.7 控制转移指令</h3><p>控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值。控制转移指令包括：</p><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和 if_acmpne</li><li>复合条件分支：tableswitch、lookupswitch</li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li></ul><p>在 Java 虚拟机中有专门的指令集用来处理 int 和 reference 类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否 null，也有专门的指令用来检测 null 值。</p><p>与前面算术运算的规则一致，对于 boolean 类型、byte 类型、char 类型和 short 类型的条件分支比较操作，都使用 int 类型的比较指令来完成，而对于 long 类型、float 类型和 double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见 6.4.3 节），运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为 int 类型的比较操作，int 类型比较是否方便、完善就显得尤为重要，而 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富、强大的。</p><h3 id="_6-4-8-方法调用和返回指令" tabindex="-1"><a class="header-anchor" href="#_6-4-8-方法调用和返回指令" aria-hidden="true">#</a> 6.4.8 方法调用和返回指令</h3><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p><ul><li>invokevirtual 指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是 Java 语言中最常见的方法分派方式。</li><li>invokeinterface 指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li><li>invokespecial 指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic 指令：用于调用类静态方法（static 方法）。</li><li>invokedynamic 指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn，另外还有一条 return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。</p><h3 id="_6-4-9-异常处理指令" tabindex="-1"><a class="header-anchor" href="#_6-4-9-异常处理指令" aria-hidden="true">#</a> 6.4.9 异常处理指令</h3><p>在 Java 程序中显式抛出异常的操作（throw 语句）都由 athrow 指令来实现，除了用 throw 语句显式抛出异常的情况之外，《Java 虚拟机规范》还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。</p><p>而在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（很久之前曾经使用 jsr 和 ret 指令来实现，现在已经不用了），而是采用异常表来完成。</p><h3 id="_6-4-10-同步指令" tabindex="-1"><a class="header-anchor" href="#_6-4-10-同步指令" aria-hidden="true">#</a> 6.4.10 同步指令</h3><p>Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为 “锁”）来实现的。</p><p>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p><p>同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示的，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 Javac 编译器与 Java 虚拟机两者共同协作支持，譬如有代码清单6-6 所示的代码。</p><p>代码清单6-6 代码同步演示</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span><span class="token class-name">Foo</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后，这段代码生成的字节码序列如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Method void onlyMe(Foo)
0 aload_1            // 将对象 f 入栈
1 dup                // 复制栈顶元素（即 f 的引用）
2 astore_2           // 将栈顶元素存储到局部变量表变量槽 2 中
3 monitorenter       // 以栈定元素（即 f）作为锁，开始同步
4 aload_0            // 将局部变量槽 0（即 this 指针）的元素入栈
5 invokevirtual #5   // 调用 doSomething() 方法
8 aload_2            // 将局部变量 Slow 2 的元素（即 f）入栈
9 monitorexit        // 退出同步
10 goto 18           // 方法正常结束，跳转到 18 返回
13 astore_3	         // 从这步开始是异常路径，见下面异常表的 Taget 13
14 aload_2	         // 将局部变量 Slow 2 的元素（即 f）入栈
15 monitorexit	     // 退出同步
16 aload_3	         // 将局部变量 Slow 3 的元素（即异常对象）入栈
17 athrow	         // 把异常对象重新抛出给 onlyMe() 方法的调用者
18 return	         // 方法正常返回
Exception table:
From  To  Target  Type
4	  10  13      any
13	  16  13      any
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p><p>从代码清单6-6的字节码序列中可以看到，为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h2 id="_6-5-公有设计-私有实现" tabindex="-1"><a class="header-anchor" href="#_6-5-公有设计-私有实现" aria-hidden="true">#</a> 6.5 公有设计，私有实现</h2><p>《Java 虚拟机规范》描绘了 Java 虚拟机应有的共同程序存储格式：Class 文件格式以及字节码指令集。这些内容与硬件、操作系统和具体的 Java 虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看作程序在各种 Java 平台实现之间互相安全地交互的手段。</p><p>理解公有设计与私有实现之间的分界线是非常有必要的，任何一款 Java 虚拟机实现都必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的语义。拿着《Java 虚拟机规范》一成不变地逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足《Java 虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，并且《Java 虚拟机规范》中明确鼓励实现者这样去做。只要优化以后 Class 文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，虚拟机在后台如何处理 Class 文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可<sup class="footnote-ref"><a href="#footnote13">[13]</a><a class="footnote-anchor" id="footnote-ref13"></a></sup>。</p><p>虚拟机实现者可以使用这种伸缩性来让 Java 虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于 Java 虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p><ul><li>将输入的 Java 虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；</li><li>将输入的 Java 虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li></ul><p>精确定义的虚拟机行为和目标文件格式，不应当对虚拟机实现者的创造性产生太多的限制，Java 虚拟机是被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的同时提供不同的新的、有趣的解决方案。</p><h2 id="_6-6-class-文件结构的发展" tabindex="-1"><a class="header-anchor" href="#_6-6-class-文件结构的发展" aria-hidden="true">#</a> 6.6 Class 文件结构的发展</h2><p>Class 文件结构自《Java 虚拟机规范》初版订立以来，已经有超过二十年的历史。这二十多年间，Java 技术体系有了翻天覆地的改变，JDK 的版本号已经从 1.0 提升到了 13。相对于语言、API 以及 Java 技术体系中其他方面的变化，Class 文件结构一直处于一个相对比较稳定的状态，Class 文件的主体结构、字节码指令的语义和数量几乎没有出现过变动<sup class="footnote-ref"><a href="#footnote14">[14]</a><a class="footnote-anchor" id="footnote-ref14"></a></sup>，所有对 Class 文件格式的改进，都集中在访问标志、属性表这些设计上原本就是可扩展的数据结构中添加新内容。</p><p>如果以《Java 虚拟机规范（第 2 版）》（对应于 JDK 1.4，是 Java 2 的奠基版本）为基准进行比较的话，在后续 Class 文件格式的发展过程中，访问标志新加入了 ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS 共五个标志。属性表集合中，在 JDK 5 到 JDK 12 发展过程中一共增加了 20 项新属性，这些属性大部分是用于支持 Java 中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信息，譬如 JDK 6 的新类型校验器的 StackMapTable 属性和对非 Java 代码调试中用到的 SourceDebugExtension 属性。</p><p>Class 文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱。</p><h2 id="_6-7-本章小结" tabindex="-1"><a class="header-anchor" href="#_6-7-本章小结" aria-hidden="true">#</a> 6.7 本章小结</h2><p>Class 文件是 Java 虚拟机执行引擎的数据入口，也是 Java 技术体系的基础支柱之一。了解 Class 文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义。</p><p>本章详细讲解了 Class 文件结构中的各个组成部分，以及每个部分的定义、数据结构和使用方法。通过代码清单6-1 的 Java 代码及其 Class 文件样例，以实战的方式演示了 Class 的数据是如何存储和访问的。从下一章开始，我们将以动态的、运行时的角度去看看字节码流在虚拟机执行引擎中是如何被解释执行的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>Wintel 指微软的 Windows 与 Intel 的芯片相结合，曾经是业界最强大的联盟。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>其实也有反例，譬如 package-info.class、module-info.class 这些文件就属于完全描述性的。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>这种顺序称为 &quot;Big-Endian&quot;，具体顺序是指按高位字节在地址最低位，最低字节在地址最高位来存储数据，它是 SPARC、PowerPC 等处理器的默认多字节存储顺序，而 x86 等处理器则是使用了相反的 &quot;Little-Endian&quot; 顺序来存储数据。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>根据 Java 之父 James Gosling 的解释，当时还定义了 &quot;CAFEDEAD&quot; 用作另一种对象持久化文件格式的魔数，只是后来该格式被废弃掉了，所以并未流传开来。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>JDK 7 时增加了前三种：CONSTANT_MethodHandle_info、CONSTANT_MethodType_info 和 CONSTANT_InvokeDynamic_info。出于性能和易用性的考虑（JDK 7 设计时已经考虑到，预留了 17 个常量标志位），在 JDK 11 中又增加了第四种常量 CONSTANT_Dynamic_info。本章不会涉及这 4 种新增的类型，留待第 8 章介绍字节码执行和方法调用时详细讲解。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p>在原始的《Java 虚拟机规范》初版中，只定义了开头 5 种标志。JDK 5 中增加了后续 3 种。这些标志为在 JSR-202 规范之中声明，是对《Java 虚拟机规范》第 2 版的补充。JDK 9 发布之后，增加了第 9 种。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li><li id="footnote7" class="footnote-item"><p>&lt;init&gt;() 和 &lt;clinit&gt;() 的详细内容见本书的下一部分 “前端编译与优化”。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p></li><li id="footnote8" class="footnote-item"><p>在《Java 虚拟机规范》第 2 版的 4.4.4 节及《Java 语言规范》第 3 版的 8.4.2 节中分别都定义了字节码层面的方法特征签名以及 Java 代码层面的方法特征签名，Java 代码的方法特征签名只包括方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，请读者根据上下文语境注意区分。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p></li><li id="footnote9" class="footnote-item"><p>此处字节码的 “行” 是一种形象的描述，指的是字节码相对于方法体开始的偏移量，而不是 Java 源码的行号，下同。 <a href="#footnote-ref9" class="footnote-backref">↩︎</a></p></li><li id="footnote10" class="footnote-item"><p>在 JDK 1.4.2 之前的 Javac 编译器采用了 jsr 和 ret 指令实现 finally 语句，但 1.4.2 之后已经改为编译器在每段分支之后都将 finally 语句块的内容冗余生成一遍来实现。从 JDK 7 起，已经完全禁止 Class 文件中出现 jsr 和 ret 指令，如果遇到这两条指令，虚拟机会在类加载的字节码校验阶段抛出异常。 <a href="#footnote-ref10" class="footnote-backref">↩︎</a></p></li><li id="footnote11" class="footnote-item"><p>详见 10.3 节的内容。 <a href="#footnote-ref11" class="footnote-backref">↩︎</a></p></li><li id="footnote12" class="footnote-item"><p>字节码指令流基本上都是单字节对齐的，只有 &quot;tableswitch&quot; 和 &quot;lookupswitch&quot; 两条指令例外，由于它们的操作数比较特殊，是以 4 字节为界划分开的，所以这两条指令也需要预留出相应的空位填充来实现对齐。 <a href="#footnote-ref12" class="footnote-backref">↩︎</a></p></li><li id="footnote13" class="footnote-item"><p>这里其实多少存在一些例外，譬如调试器（Debugger）、性能监视器（Profiler）和即时编译器（Just-In-Time Code Generator）等都可能需要访问一些通常被认为是 “虚拟机后台” 的元素。 <a href="#footnote-ref13" class="footnote-backref">↩︎</a></p></li><li id="footnote14" class="footnote-item"><p>二十余年间，字节码的数量和语义只发生过屈指可数的几次变动，例如 JDK 1.0.2 时改动过 invokespecial 指令的语义，JDK 7 增加了 invokedynamic 指令，禁止了 ret 和 jsr 指令。 <a href="#footnote-ref14" class="footnote-backref">↩︎</a></p></li></ol></section></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/深入理解Java虚拟机：JVM高级特性与最佳实践/第6章类文件结构.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC7%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link next" aria-label="第 7 章 虚拟机类加载机制"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 7 章 虚拟机类加载机制<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
