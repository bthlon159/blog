<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 4 章 虚拟机性能监控、故障处理工具"><meta property="og:type" content="article"><meta property="og:image" content="https://www.cxlsn.cn/"><meta property="og:updated_time" content="2022-08-12T09:39:15.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="第 4 章 虚拟机性能监控、故障处理工具"><meta property="article:modified_time" content="2022-08-12T09:39:15.000Z"><title>第 4 章 虚拟机性能监控、故障处理工具 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link active" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第一部分 走近 Java</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 走近 Java"><!---->第 1 章 走近 Java<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第二部分 自动内存管理</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC2%E7%AB%A0Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 Java 内存区域与内存溢出异常"><!---->第 2 章 Java 内存区域与内存溢出异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC3%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 垃圾收集器与内存分配策略"><!---->第 3 章 垃圾收集器与内存分配策略<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 4 章 虚拟机性能监控、故障处理工具"><!---->第 4 章 虚拟机性能监控、故障处理工具<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 概述"><!---->4.1 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-基础故障处理工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 基础故障处理工具"><!---->4.2 基础故障处理工具<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-1-jps-虚拟机进程状况工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.1 jps：虚拟机进程状况工具"><!---->4.2.1 jps：虚拟机进程状况工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-2-jstat-虚拟机统计信息监视工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.2 jstat：虚拟机统计信息监视工具"><!---->4.2.2 jstat：虚拟机统计信息监视工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-3-jinfo-java-配置信息工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.3 jinfo：Java 配置信息工具"><!---->4.2.3 jinfo：Java 配置信息工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-4-jmap-java-内存映像工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.4 jmap：Java 内存映像工具"><!---->4.2.4 jmap：Java 内存映像工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-5-jhat-虚拟机堆转储快照分析工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.5 jhat：虚拟机堆转储快照分析工具"><!---->4.2.5 jhat：虚拟机堆转储快照分析工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-6-jstack-java-堆栈跟踪工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.6 jstack：Java 堆栈跟踪工具"><!---->4.2.6 jstack：Java 堆栈跟踪工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-7-基础工具总结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.7 基础工具总结"><!---->4.2.7 基础工具总结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-可视化故障处理工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 可视化故障处理工具"><!---->4.3 可视化故障处理工具<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-1-jhsdb-基于服务性代理的调试工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.1 JHSDB：基于服务性代理的调试工具"><!---->4.3.1 JHSDB：基于服务性代理的调试工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-2-jconsole-java-监视与管理控制台" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.2 JConsole：Java 监视与管理控制台"><!---->4.3.2 JConsole：Java 监视与管理控制台<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-3-visualvm-多合一故障处理工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.3 VisualVM：多合一故障处理工具"><!---->4.3.3 VisualVM：多合一故障处理工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-4-java-mission-control-可持续在线的监控工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.4 Java Mission Control：可持续在线的监控工具"><!---->4.3.4 Java Mission Control：可持续在线的监控工具<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-4-hotspot-虚拟机插件及工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 HotSpot 虚拟机插件及工具"><!---->4.4 HotSpot 虚拟机插件及工具<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-5-本章小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5 本章小结"><!---->4.5 本章小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC5%E7%AB%A0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 调优案例分析与实战"><!---->第 5 章 调优案例分析与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第三部分 虚拟机执行子系统</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 类文件结构"><!---->第 6 章 类文件结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC7%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 虚拟机类加载机制"><!---->第 7 章 虚拟机类加载机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC8%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 虚拟机字节码执行引擎"><!---->第 8 章 虚拟机字节码执行引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC9%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 类加载及执行子系统的案例与实战"><!---->第 9 章 类加载及执行子系统的案例与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 程序编译与代码优化</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC10%E7%AB%A0%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 前端编译与优化"><!---->第 10 章 前端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC11%E7%AB%A0%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 后端编译与优化"><!---->第 11 章 后端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第五部分 高效并发</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC12%E7%AB%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 Java 内存模型与线程"><!---->第 12 章 Java 内存模型与线程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC13%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 线程安全与锁优化"><!---->第 13 章 线程安全与锁优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 4 章 虚拟机性能监控、故障处理工具</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年8月7日</span><meta property="datePublished" content="2022-08-07T15:02:14.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 60 分钟</span><meta property="timeRequired" content="PT60M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 18081 字</span><meta property="wordCount" content="18081"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-1-概述" class="router-link-active router-link-exact-active toc-link level2">4.1 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-基础故障处理工具" class="router-link-active router-link-exact-active toc-link level2">4.2 基础故障处理工具</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-1-jps-虚拟机进程状况工具" class="router-link-active router-link-exact-active toc-link level3">4.2.1 jps：虚拟机进程状况工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-2-jstat-虚拟机统计信息监视工具" class="router-link-active router-link-exact-active toc-link level3">4.2.2 jstat：虚拟机统计信息监视工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-3-jinfo-java-配置信息工具" class="router-link-active router-link-exact-active toc-link level3">4.2.3 jinfo：Java 配置信息工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-4-jmap-java-内存映像工具" class="router-link-active router-link-exact-active toc-link level3">4.2.4 jmap：Java 内存映像工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-5-jhat-虚拟机堆转储快照分析工具" class="router-link-active router-link-exact-active toc-link level3">4.2.5 jhat：虚拟机堆转储快照分析工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-6-jstack-java-堆栈跟踪工具" class="router-link-active router-link-exact-active toc-link level3">4.2.6 jstack：Java 堆栈跟踪工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-2-7-基础工具总结" class="router-link-active router-link-exact-active toc-link level3">4.2.7 基础工具总结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-可视化故障处理工具" class="router-link-active router-link-exact-active toc-link level2">4.3 可视化故障处理工具</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-1-jhsdb-基于服务性代理的调试工具" class="router-link-active router-link-exact-active toc-link level3">4.3.1 JHSDB：基于服务性代理的调试工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-2-jconsole-java-监视与管理控制台" class="router-link-active router-link-exact-active toc-link level3">4.3.2 JConsole：Java 监视与管理控制台</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-3-visualvm-多合一故障处理工具" class="router-link-active router-link-exact-active toc-link level3">4.3.3 VisualVM：多合一故障处理工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-3-4-java-mission-control-可持续在线的监控工具" class="router-link-active router-link-exact-active toc-link level3">4.3.4 Java Mission Control：可持续在线的监控工具</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-4-hotspot-虚拟机插件及工具" class="router-link-active router-link-exact-active toc-link level2">4.4 HotSpot 虚拟机插件及工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html#_4-5-本章小结" class="router-link-active router-link-exact-active toc-link level2">4.5 本章小结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-4-章-虚拟机性能监控、故障处理工具" tabindex="-1"><a class="header-anchor" href="#第-4-章-虚拟机性能监控、故障处理工具" aria-hidden="true">#</a> 第 4 章 虚拟机性能监控、故障处理工具</h1><p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p><h2 id="_4-1-概述" tabindex="-1"><a class="header-anchor" href="#_4-1-概述" aria-hidden="true">#</a> 4.1 概述</h2><p>经过前面两章对于虚拟机内存分配与回收技术各方面的介绍，相信读者已经建立了一个比较系统、完整的理论基础。理论总是作为指导实践的工具，把这些知识应用到实际工作中才是我们的最终目的。接下来的两章，我们将从实践的角度去认识虚拟机内存管理的世界。</p><p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括但不限于异常堆栈、虚拟机运行日志、垃圾收集器日志、线程快照（threaddump / javacore 文件）、堆转储快照（heapdump / hprof 文件）等。恰当地使用虚拟机故障处理、分析的工具可以提升我们分析数据、定位并解决问题的效率，但我们在学习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”，拥有了就能“包治百病”。</p><h2 id="_4-2-基础故障处理工具" tabindex="-1"><a class="header-anchor" href="#_4-2-基础故障处理工具" aria-hidden="true">#</a> 4.2 基础故障处理工具</h2><p>Java 开发人员肯定都知道 JDK 的 bin 目录中有 java.exe、javac.exe 这两个命令行工具，但并非所有程序员都了解过 JDK 的 bin 目录下其他各种小工具的作用。随着 JDK 版本的更迭，这些小工具的数量和功能也在不知不觉地增加与增强。除了编译和运行 Java 程序外，打包、部署、签名、调试、监控、运维等各种场景都可能会用到它们，这些工具如图4-1 所示。</p><p><img src="/assets/图4-1.b2428278.png" alt="图4-1" loading="lazy"></p><p>图4-1 JDK 自带工具</p><p>在本章，笔者将介绍这些工具中的一部分，主要是用于监视虚拟机运行状态和进行故障处理的工具。这些故障处理工具并不单纯是被 Oracle 公司作为 “礼物” 附赠给 JDK 的使用者，根据软件可用性和授权的不同，可以把它们划分成三类：</p><ul><li>商业授权工具：主要是 JMC（Java Mission Control）及它要使用到的 JFR（Java Flight Recorder），JMC 这个原本来自于 JRockit 的运维监控套件从 JDK 7 Update 40 开始就被集成到 OracleJDK 中，JDK 11 之前都无须独立下载，但是在商业环境中使用它则是要付费的<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。</li><li>正式支持工具：这一类工具属于被长期支持的工具，不同平台、不同版本的 JDK 之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。</li><li>实验性工具：这一类工具在它们的使用说明中被声明为 “没有技术支持，并且是实验性质的”（Unsupported and Experimental）产品，日后可能会转正，也可能会在某个 JDK 版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。</li></ul><p>读者如果比较细心的话，还可能会注意到这些工具程序大多数体积都异常小。假如之前没注意到，现在不妨再看看图4-1 中的最后一列 “大小”，各个工具的体积基本上都稳定在 21KB 左右。并非 JDK 开发团队刻意把它们制作得如此精炼、统一，而是因为这些命令行工具大多仅是一层薄包装而已，真正的功能代码是实现在 JDK 的工具类库中的，读者把图4-1 和图4-2 两张图片对比一下就可以看得很清楚<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>。假如读者使用的是 Linux 版本的 JDK，还可以发现这些工具中不少是由 Shell 脚本直接写成，可以用文本编辑器打开并编辑修改它们。</p><p><img src="/assets/图4-2.700d2ed9.png" alt="图4-2" loading="lazy"></p><p>图4-2 JDK 类库中的工具模块</p><p>JDK 开发团队选择采用 Java 语言本身来实现这些故障处理工具是有特别用意的：当应用程序部署到生产环境后，无论是人工物理接触到服务器还是远程 Telnet 到服务器上都可能会受到限制。借助这些工具类库里面的接口和实现代码，开发者可以选择直接在应用程序中提供功能强大的监控分析功能 <sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>。</p><p>本章所讲解的工具大多基于 Windows 平台下的 JDK 进行演示，如果读者选用的 JDK 版本、操作系统不同，那么工具不仅可能数量上有所差别，同一个工具所支持的功能范围和效果都可能会不一样。本章提及的工具，如无特别说明，是 JDK 5 中就已经存在的，但为了避免运行环境带来的差异和兼容性问题，建议读者使用更高版本的 JDK 来验证本章介绍的内容。通常高版本 JDK 的工具有可能向下兼容运行于低版本 JDK 的虚拟机上的程序，反之则一般不行。</p><p><strong>注意</strong>：如果读者在工作中需要监控运行于 JDK 5 的虚拟机之上的程序，在程序启动时请添加参数 &quot;-Dcom.sun.management.jmxremote&quot; 开启 JMX 管理功能，否则由于大部分工具都是基于或者要用到 JMX（包括下一节的可视化工具)，它们都将无法使用，如果被监控程序运行于 JDK 6 或以上版本的虚拟机之上，那 JMX 管理默认是开启的，虚拟机启动时无须再添加任何参数。</p><h3 id="_4-2-1-jps-虚拟机进程状况工具" tabindex="-1"><a class="header-anchor" href="#_4-2-1-jps-虚拟机进程状况工具" aria-hidden="true">#</a> 4.2.1 jps：虚拟机进程状况工具</h3><p>JDK 的很多小工具的名字都参考了 UNIX 命令的命名方式，jps（JVM Process Status Tool）是其中的典型。除了名字像 UNIX 的 ps 命令之外，它的功能也和 ps 命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）。虽然功能比较单一，但它绝对是使用频率最高的 JDK 命令行工具，因为其他的 JDK 工具大多需要输入它查询到的 LVMID 来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID 与操作系统的进程 ID（PID，Process Identifier）是一致的，使用 Windows 的任务管理器或者 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖 jps 命令显示主类的功能才能区分了。</p><p>jps 命令格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jps [ options ] [ hostid ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>jps 执行样例：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jps -l
2388 D:\Develop\glassfish\bin\..\modules\admin-cli.jar
2764 com.sun.enterprise.glassfish.bootstrap.ASMain
3788 sun.tools.jps.Jps
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jps 还可以通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态，参数 hostid 为 RMI 注册表中注册的主机名。jps 的其他常用选项见表 4-1。</p><p>表4-1 jps 工具主要选项</p><p><img src="/assets/表4-1.c29ca733.png" alt="表4-1" loading="lazy"></p><h3 id="_4-2-2-jstat-虚拟机统计信息监视工具" tabindex="-1"><a class="header-anchor" href="#_4-2-2-jstat-虚拟机统计信息监视工具" aria-hidden="true">#</a> 4.2.2 jstat：虚拟机统计信息监视工具</h3><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有 GUI 图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p><p>jstat 命令格式为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jstat [ option vmid [interval[s|ms] [count]] ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于命令格式中的 VMID 与L VMID 需要特别说明一下：如果是本地虚拟机进程，VMID 与 LVMID 是一致的；如果是远程虚拟机进程，那 VMID 的格式应当是：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[protocol:][//]lvmid[@hostname[:port]/servername]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数 interval 和 count 代表查询间隔和次数，如果省略这 2 个参数，说明只查询一次。假设需要每 250 毫秒查询一次进程 2764 垃圾收集状况，一共查询 20 次，那命令应当是：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jstat -gc 2764 250 20
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>选项 option 代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。详细请参考表4-2 中的描述。</p><p>表4-2 jstat 工具主要选项</p><p><img src="/assets/表4-2.6a312fe0.png" alt="表4-2" loading="lazy"></p><p>jstat 监视选项众多，囿于版面原因无法逐一演示，这里仅举一个在命令行下监视一台刚刚启动的 GlassFish v3 服务器的内存状况的例子，用以演示如何查看监视结果。监视参数与输出结果如代码清单4-1 所示。</p><p>代码清单4-1 jstat 执行样例</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jstat -gcutil 2764
S0    S1    E      O     P      YGC   YGCT   FGC  FGCT     GCT   
0.00  0.00  6.20  41.42  47.20  16    0.105  3    0.472    0.577
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询结果表明：这台服务器的新生代 Eden区（E，表示 Eden）使用了 6.2% 的空间，2 个 Survivor 区（S0、S1，表示 Survivor0、Survivor1）里面都是空的，老年代（O，表示 Old）和永久代（P，表示 Permanent）则分别使用了 41.42% 和 47.20% 的空间。程序运行以来共发生 Minor GC（YGC，表示 Young GC）16 次，总耗时 0.105 秒；发生 Full GC（FGC，表示 Full GC）3 次，总耗时（FGCT，表示 Full GC Time）为 0.472 秒；所有 GC 总耗时（GCT，表示 GC Time）为 0.577 秒。</p><p>使用 jstat 工具在纯文本状态下监视虚拟机状态的变化，在用户体验上也许不如后文将会提到的 JMC、VisualVM 等可视化的监视工具直接以图表展现那样直观，但在实际生产环境中不一定可以使用图形界面，而且多数服务器管理员也都已经习惯了在文本控制台工作，直接在控制台中使用 jstat 命令依然是一种常用的监控方式。</p><h3 id="_4-2-3-jinfo-java-配置信息工具" tabindex="-1"><a class="header-anchor" href="#_4-2-3-jinfo-java-配置信息工具" aria-hidden="true">#</a> 4.2.3 jinfo：Java 配置信息工具</h3><p>jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。使用 jps 命令的 -v 参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用 jinfo 的 -flag 选项进行查询了（如果只限于 JDK 6 或以上版本的话，使用 java -XX:+PrintFlagsFinal 查看参数默认值也是一个很好的选择）。jinfo 还可以使用- sysprops 选项把虚拟机进程的 System.getProperties() 的内容打印出来。这个命令在 JDK 5 时期已经随着 Linux 版的 JDK 发布，当时只提供了信息查询的功能，JDK 6 之后，jinfo 在 Windows 和 Linux 平台都有提供，并且加入了在运行期修改部分参数值的能力（可以使用 -flag[+|-]name 或者 -flag name=value 在运行期修改一部分运行期可写的虚拟机参数值）。在 JDK 6 中，jinfo 对于 Windows 平台功能仍然有较大限制，只提供了最基本的 -flag 选项。</p><p>jinfo 命令格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jinfo [ option ] pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行样例：查询 CMSInitiatingOccupancyFraction 参数值</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jinfo -flag CMSInitiatingOccupancyFraction 1444
-XX:CMSInitiatingOccupancyFraction=85
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-4-jmap-java-内存映像工具" tabindex="-1"><a class="header-anchor" href="#_4-2-4-jmap-java-内存映像工具" aria-hidden="true">#</a> 4.2.4 jmap：Java 内存映像工具</h3><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。如果不使用 jmap 命令，要想获取 Java 堆转储快照也还有一些比较 “暴力” 的手段：譬如在第 2 章中用过的 -XX:+HeapDumpOnOutOfMemoryError 参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过 -XX:+HeapDumpOnCtrlBreak 参数则可以使用 [Ctrl] + [Break] 键让虚拟机生成堆转储快照文件，又或者在 Linux 系统下通过 Kill -3 命令发送进程退出信号 “恐吓” 一下虚拟机，也能顺利拿到堆转储快照。</p><p>jmap 的作用并不仅仅是为了获取堆转储快照，它还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。</p><p>和 jinfo 命令一样，jmap 有部分功能在 Windows 平台下是受限的，除了生成堆转储快照的 -dump 选项和用于查看每个类的实例、空间占用统计的 -histo 选项在所有操作系统中都可以使用之外，其余选项都只能在 Linux / Solaris 中使用。</p><p>jmap 命令格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jmap [ option ] vmid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>option 选项的合法值与具体含义如表4-3 所示。</p><p>表4-3 jmap 工具主要选项</p><p><img src="/assets/表4-3.76b0b2fb.png" alt="表4-3" loading="lazy"></p><p>代码清单4-2 是使用 jmap 生成一个正在运行的 Eclipse 的堆转储快照文件的例子，例子中的 3500 是通过 jps 命令查询到的 LVMID。</p><p>代码清单4-2 使用 jmap 生成 dump 文件</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jmap -dump:format=b,file=eclipse.bin 3500
Dumping heap to C:\Users\IcyFenix\eclipse.bin ... 
Heap dump file created
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-5-jhat-虚拟机堆转储快照分析工具" tabindex="-1"><a class="header-anchor" href="#_4-2-5-jhat-虚拟机堆转储快照分析工具" aria-hidden="true">#</a> 4.2.5 jhat：虚拟机堆转储快照分析工具</h3><p>JDK 提供 jhat（JVM Heap Analysis Tool）命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。jhat 内置了一个微型的 HTTP / Web 服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则多数人是不会直接使用 jhat 命令来分析堆转储快照文件的，主要原因有两个方面。一是一般不会在部署应用程序的服务器上直接分析堆转储快照，即使可以这样做，也会尽量将堆转储快照文件复制到其他机器<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>上进行分析，因为分析工作是一个耗时而且极为耗费硬件资源的过程，既然都要在其他机器上进行，就没有必要再受命令行工具的限制了。另外一个原因是 jhat 的分析功能相对来说比较简陋，后文将会介绍到的 VisualVM，以及专业用于分析堆转储快照文件的 Eclipse Memory Analyzer、IBM HeapAnalyzer<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>等工具，都能实现比 jhat 更强大专业的分析功能。代码清单4-3 演示了使用 jhat 分析上一节采用 jmap 生成的 Eclipse IDE 的内存快照文件。</p><p>代码清单4-3 使用 jhat 分析 dump 文件</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jhat eclipse.bin
Reading from eclipse.bin...
Dump file created Fri Nov 19 22:07:21 CST 2010 Snapshot read, resolving...
Resolving 1225951 objects...
Chasing references, expect 245 dots....
Eliminating duplicate references...
Snapshot resolved.
Started HTTP server on port 7000 Server is ready.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>屏幕显示 &quot;Server is ready.&quot; 的提示后，用户在浏览器中输入 <a href="http://localhost:7000/" target="_blank" rel="noopener noreferrer">http://localhost:7000/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 可以看到分析结果，如图4-3 所示。</p><p><img src="/assets/图4-3.fc70bd05.png" alt="图4-3" loading="lazy"></p><p>图4-3 jhat 的分析结果</p><p>分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的 &quot;Heap Histogram&quot;（与 jmap -histo 功能一样）与 OQL 页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似 SQL 的语法对内存中的对象进行查询统计。如果读者需要了解具体 OQL 的语法和使用方法，可参见本书附录 D 的内容。</p><h3 id="_4-2-6-jstack-java-堆栈跟踪工具" tabindex="-1"><a class="header-anchor" href="#_4-2-6-jstack-java-堆栈跟踪工具" aria-hidden="true">#</a> 4.2.6 jstack：Java 堆栈跟踪工具</h3><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为 threaddump 或者 javacore 文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过 jstack 来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p><p>jstack 命令格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jstack [ option ] vmid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>option 选项的合法值与具体含义如表4-4 所示。</p><p>表4-4 jstack 工具主要选项</p><p><img src="/assets/表4-4.5f2e62d3.png" alt="表4-4" loading="lazy"></p><p>代码清单4-4 是使用 jstack 查看 Eclipse 线程堆栈的例子，例子中的 3500 是通过 jps 命令查询到的 LVMID。</p><p>代码清单4-4 使用 jstack 查看线程堆栈（部分结果）</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jstack -l 3500
2010-11-19 23:11:26
Full thread dump Java HotSpot(TM) 64-Bit Server VM (17.1-b03 mixed mode):
&quot;[ThreadPool Manager] - Idle Thread&quot; daemon prio=6 tid=0x0000000039dd4000 nid= 0xf50 in Object.wait() [0x000000003c96f000]
    java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x0000000016bdcc60&gt; (a  org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor)
        at java.lang.Object.wait(Object.java:485)
        at org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor.run (Executor.java:106)
        - locked &lt;0x0000000016bdcc60&gt; (a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor)
    Locked ownable synchronizers:
    - None
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 JDK 5 起，java.lang.Thread 类新增了一个 getAllStackTraces() 方法用于获取虚拟机中所有线程的 StackTraceElement 对象。使用这个方法可以通过简单的几行代码完成 jstack 的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈，如代码清单4-5 所示，这也算是笔者的一个小经验。</p><p>代码清单4-5 查看线程状况的 JSP 页面</p><div class="language-jsp ext-jsp line-numbers-mode"><pre class="language-jsp"><code>&lt;%@ page import=&quot;java.util.Map&quot;%&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;服务器线程信息&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;pre&gt;
&lt;%
for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread.getAllStackTraces().entrySet()) { 
    Thread thread = (Thread) stackTrace.getKey();
    StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue(); 
    if (thread.equals(Thread.currentThread())) {
        continue;
    }
    out.print(&quot;\n线程：&quot; + thread.getName() + &quot;\n&quot;); 
    for (StackTraceElement element : stack) {
        out.print(&quot;\t&quot;+element+&quot;\n&quot;);
    }
}
%&gt;
		&lt;/pre&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-7-基础工具总结" tabindex="-1"><a class="header-anchor" href="#_4-2-7-基础工具总结" aria-hidden="true">#</a> 4.2.7 基础工具总结</h3><p>下面表4-5 ~ 表4-14 中罗列了 JDK 附带的全部（包括曾经存在但已经在最新版本中被移除的）工具及其简要用途，限于篇幅，本节只讲解了 6 个常用的命令行工具。笔者选择这几个工具除了因为它们是最基础的命令外，还因为它们已经有很长的历史，能适用于大多数读者工作、学习中使用的 JDK 版本。在高版本的 JDK 中，这些工具大多已有了功能更为强大的替代品，譬如 JCMD、JHSDB 的命令行模式，但使用方法也是相似的，无论 JDK 发展到了什么版本，学习这些基础的工具命令并不会过时和浪费。</p><ul><li><p>基础工具：用于支持基本的程序创建和运行（见表4-5）</p><p>表4-5 基础工具</p><p><img src="/assets/表4-5.ab66a405.png" alt="表4-5" loading="lazy"></p></li><li><p>安全：用于程序签名、设置安全测试等（见表4-6）</p><p>表4-6 安全工具</p><p><img src="/assets/表4-6.18fd74be.png" alt="表4-6" loading="lazy"></p></li><li><p>国际化：用于创建本地语言文件（见表4-7）</p><p>表4-7 国际化工具</p><p><img src="/assets/表4-7.01ad913b.png" alt="表4-7" loading="lazy"></p></li><li><p>远程方法调用：用于跨 Web 或网络的服务交互（见表4-8）</p><p>表4-8 远程方法调用工具</p><p><img src="/assets/表4-8.dc9d0a87.png" alt="表4-8" loading="lazy"></p></li><li><p>Java IDL 与 RMI-IIOP：在 JDK 11 中结束了十余年的 CORBA 支持，这些工具不再提供<sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup>（见表4-9）</p><p>表4-9 Java IDL 与 RMI-IIOP</p><p><img src="/assets/表4-9.0cfadb9e.png" alt="表4-9" loading="lazy"></p></li><li><p>部署工具：用于程序打包、发布和部署（见表4-10）</p><p>表4-10 部署工具</p><p><img src="/assets/表4-10.c7e61eef.png" alt="表4-10" loading="lazy"></p></li><li><p>Java Web Start（见表4-11）</p><p>表4-11 Java Web Start</p><p><img src="/assets/表4-11.1bacae95.png" alt="表4-11" loading="lazy"></p></li><li><p>性能监控和故障处理：用于监控分析 Java 虚拟机运行信息，排查问题（见表4-12）</p><p>表4-12 性能监控和故障处理工具</p><p><img src="/assets/表4-12.8186f21c.png" alt="表4-12" loading="lazy"></p></li><li><p>WebService 工具：与 CORBA 一起在 JDK 11 中被移除（见表4-13）</p><p>表4-13 WebService 工具</p><p><img src="/assets/表4-13.fb4fcb62.png" alt="表4-13" loading="lazy"></p></li><li><p>REPL 和脚本工具（见表4-14）</p><p>表4-14 REPL 和脚本工具</p><p><img src="/assets/表4-14.2ee855b8.png" alt="表4-14" loading="lazy"></p></li></ul><h2 id="_4-3-可视化故障处理工具" tabindex="-1"><a class="header-anchor" href="#_4-3-可视化故障处理工具" aria-hidden="true">#</a> 4.3 可视化故障处理工具</h2><p>JDK 中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化工具，用户可以使用这些可视化工具以更加便捷的方式进行进程故障诊断和调试工作。这类工具主要包括 JConsole、JHSDB、VisualVM 和 JMC 四个。其中，JConsole 是最古老，早在 JDK 5 时期就已经存在的虚拟机监控工具，而 JHSDB 虽然名义上是 JDK 9 中才正式提供，但之前已经以 sa-jdi.jar 包里面的 HSDB（可视化工具）和 CLHSDB（命令行工具）的形式存在了很长一段时间<sup class="footnote-ref"><a href="#footnote9">[9]</a><a class="footnote-anchor" id="footnote-ref9"></a></sup>。它们两个都是 JDK 的正式成员，随着 JDK 一同发布，无须独立下载，使用也是完全免费的。</p><p>VisualVM 在 JDK 6 Update 7 中首次发布，直到J Rockit Mission Control 与 OracleJDK 的融合工作完成之前，它都曾是 Oracle 主力推动的多合一故障处理工具，现在它已经从 OracleJDK 中分离出来，成为一个独立发展的开源项目<sup class="footnote-ref"><a href="#footnote10">[10]</a><a class="footnote-anchor" id="footnote-ref10"></a></sup>。VisualVM 已不是 JDK 中的正式成员，但仍是可以免费下载、使用的。</p><p>Java Mission Control，曾经是大名鼎鼎的来自 BEA 公司的图形化诊断工具，随着 BEA 公司被 Oracle 收购，它便被融合进 OracleJDK 之中。在 JDK 7 Update 40 时开始随 JDK 一起发布，后来 Java SE Advanced 产品线建立，Oracle 明确区分了 Oracle OpenJDK 和 OracleJDK 的差别<sup class="footnote-ref"><a href="#footnote11">[11]</a><a class="footnote-anchor" id="footnote-ref11"></a></sup>，JMC 从 JDK 11 开始又被移除出 JDK。虽然在 2018 年 Oracle 将 JMC 开源并交付给 OpenJDK 组织进行管理，但开源并不意味着免费使用，JMC 需要与 HotSpot 内部的 “飞行记录仪”（Java Flight Recorder，JFR）配合才能工作，而在 JDK 11 以前，JFR 的开启必须解锁 OracleJDK 的商业特性支持（使用 JCMD 的 VM.unlock_commercial_features 或启动时加入 -XX:+UnlockCommercialFeatures 参数），所以这项功能在生产环境中仍然是需要付费才能使用的商业特性。</p><p>为避免本节讲解的内容变成对软件说明文档的简单翻译，笔者准备了一些代码样例，大多数是笔者特意编写的反面教材。稍后将会使用几款工具去监控、分析这些代码存在的问题，算是本节简单的实战演练。读者可以把在可视化工具观察到的数据、现象，与前面两章中讲解的理论知识进行互相验证。</p><h3 id="_4-3-1-jhsdb-基于服务性代理的调试工具" tabindex="-1"><a class="header-anchor" href="#_4-3-1-jhsdb-基于服务性代理的调试工具" aria-hidden="true">#</a> 4.3.1 JHSDB：基于服务性代理的调试工具</h3><p>JDK 中提供了 JCMD 和 JHSDB 两个集成式的多功能工具箱，它们不仅整合了上一节介绍到的所有基础工具所能提供的专项功能，而且由于有着 “后发优势”，能够做得往往比之前的老工具们更好、更强大，表4-15 所示是 JCMD、JHSDB 与原基础工具实现相同功能的简要对比。</p><p>表4-15 JCMD、JHSDB 和基础工具的对比</p><p><img src="/assets/表4-15.b3f0a33d.png" alt="表4-15" loading="lazy"></p><p>本节的主题是可视化的故障处理，所以 JCMD 及 JHSDB 的命令行模式就不再作重点讲解了，读者可参考上一节的基础命令，再借助它们在 JCMD 和 JHSDB 中的 help 去使用，相信是很容易举一反三、触类旁通的。接下来笔者要通过一个实验来讲解 JHSDB 的图形模式下的功能。</p><p>JHSDB 是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。服务性代理是 HotSpot 虚拟机中一组用于映射 Java 虚拟机运行信息的、主要基于 Java 语言（含少量 JNI 代码）实现的 API 集合。服务性代理以 HotSpot 内部的数据结构为参照物进行设计，把这些 C++ 的数据抽象出 Java 模型对象，相当于 HotSpot 的 C++ 代码的一个镜像。通过服务性代理的 API，可以在一个独立的 Java 虚拟机的进程里分析其他 HotSpot 虚拟机的内部数据，或者从 HotSpot 虚拟机进程内存中 dump 出来的转储快照里还原出它的运行状态细节。服务性代理的工作原理跟 Linux 上的 GDB 或者 Windows 上的 Windbg 是相似的。本次，我们要借助 JHSDB 来分析一下代码清单4-6 中的代码<sup class="footnote-ref"><a href="#footnote12">[12]</a><a class="footnote-anchor" id="footnote-ref12"></a></sup>，并通过实验来回答一个简单问题：staticObj、instanceObj、localObj 这三个变量本身（而不是它们所指向的对象）存放在哪里？</p><p>代码清单4-6 JHSDB 测试代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * staticObj、instanceObj、localObj 存放在哪里？
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JHSDB_TestCase</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
        <span class="token keyword">static</span> <span class="token class-name">ObjectHolder</span> staticObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ObjectHolder</span> instanceObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ObjectHolder</span> localObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里设一个断点</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ObjectHolder</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JHSDB_TestCase<span class="token punctuation">.</span>Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案读者当然都知道：staticObj 随着 Test 的类型信息存放在方法区，instanceObj 随着 Test 的对象实例存放在 Java 堆，localObject 则是存放在 foo() 方法栈帧的局部变量表中。这个答案是通过前两章学习的理论知识得出的，现在要做的是通过 JHSDB 来实践验证这一点。</p><p>首先，我们要确保这三个变量已经在内存中分配好，然后将程序暂停下来，以便有空隙进行实验，这只要把断点设置在代码中加粗的打印语句上，然后在调试模式下运行程序即可。由于 JHSDB 本身对压缩指针的支持存在很多缺陷，建议用 64 位系统的读者在实验时禁用压缩指针，另外为了后续操作时可以加快在内存中搜索对象的速度，也建议读者限制一下 Java 堆的大小。本例中，笔者采用的运行参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>程序执行后通过 jps 查询到测试程序的进程 ID，具体如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jps -l
8440 org.jetbrains.jps.cmdline.Launcher
11180 JHSDB_TestCase
15692 jdk.jcmd/sun.tools.jps.Jps
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用以下命令进入 JHSDB 的图形化模式，并使其附加进程 11180：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>jhsdb hsdb --pid 11180
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令打开的 JHSDB 的界面如图4-4 所示。</p><p><img src="/assets/图4-4.79a65c0b.png" alt="图4-4" loading="lazy"></p><p>图4-4 JHSDB 的界面</p><p>阅读代码清单4-6 可知，运行至断点位置一共会创建三个 ObjectHolder 对象的实例，只要是对象实例必然会在 Java 堆中分配，既然我们要查找引用这三个对象的指针存放在哪里，不妨从这三个对象开始着手，先把它们从 Java 堆中找出来。</p><p>首先点击菜单中的 Tools -&gt; Heap Parameters<sup class="footnote-ref"><a href="#footnote13">[13]</a><a class="footnote-anchor" id="footnote-ref13"></a></sup>，结果如图4-5 所示，因为笔者的运行参数中指定了使用的是 Serial 收集器，图中我们看到了典型的 Serial 的分代内存布局，Heap Parameters 窗口中清楚列出了新生代的 Eden、S1、S2 和老年代的容量（单位为字节）以及它们的虚拟内存地址起止范围。</p><p><img src="/assets/图4-5.e47062c3.png" alt="图4-5" loading="lazy"></p><p>图4-5 Serial 收集器的堆布局</p><p>如果读者实践时不指定收集器，即使用 JDK 默认的 G1 的话，得到的信息应该类似如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Heap Parameters:
garbage-first heap [0x00007f32c7800000, 0x00007f32c8200000] region size 1024K
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>请读者注意一下图中各个区域的内存地址范围，后面还要用到它们。打开 Windows -&gt; Console 窗口，使用 scanoops 命令在 Java 堆的新生代（从 Eden 起始地址到 To Survivor 结束地址）范围内查找 ObjectHolder 的实例，结果如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hsdb&gt; scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_TestCase$ObjectHolder
0x00007f32c7a7c458 JHSDB_TestCase$ObjectHolder
0x00007f32c7a7c480 JHSDB_TestCase$ObjectHolder 
0x00007f32c7a7c490  JHSDB_TestCase$ObjectHolder
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>果然找出了三个实例的地址，而且它们的地址都落到了 Eden 的范围之内，算是顺带验证了一般情况下新对象在 Eden 中创建的分配规则。再使用 Tools -&gt; Inspector 功能确认一下这三个地址中存放的对象，结果如图4-6 所示。</p><p><img src="/assets/图4-6.f8037fe1.png" alt="图4-6" loading="lazy"></p><p>图4-6 查看对象实例数据</p><p>Inspector 为我们展示了对象头和指向对象元数据的指针，里面包括了 Java 类型的名字、继承关系、实现接口关系，字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表（vtable）以及接口方法表（itable）等。由于我们的确没有在 ObjectHolder 上定义过任何字段，所以图中并没有看到任何实例字段数据，读者在做实验时不妨定义一些不同数据类型的字段，观察它们在 HotSpot 虚拟机里面是如何存储的。</p><p>接下来要根据堆中对象实例地址找出引用它们的指针，原本 JHSDB 的 Tools 菜单中有 Compute Reverse Ptrs 来完成这个功能，但在笔者的运行环境中一点击它就出现 Swing 的界面异常，看后台日志是报了个空指针，这个问题只是界面层的异常，跟虚拟机关系不大，所以笔者没有继续去深究，改为使用命令来做也很简单，先拿第一个对象来试试看：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hsdb&gt; revptrs 0x00007f32c7a7c458 
Computing reverse pointers...
Done.
Oop for java/lang/Class @ 0x00007f32c7a7b180
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>果然找到了一个引用该对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticObj 的实例字段，如图4-7 所示。</p><p><img src="/assets/图4-7.e9df50c3.png" alt="图4-7" loading="lazy"></p><p>图4-7 Class 对象</p><p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK 7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点<sup class="footnote-ref"><a href="#footnote14">[14]</a><a class="footnote-anchor" id="footnote-ref14"></a></sup>。接下来继续查找第二个对象实例：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hsdb&gt;revptrs 0x00007f32c7a7c480 
Computing reverse pointers...
Done.
Oop for JHSDB_TestCase$Test @ 0x00007f32c7a7c468
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次找到一个类型为 JHSDB_TestCase$Test 的对象实例，在 Inspector 中该对象实例显示如图4-8 所示。</p><p><img src="/assets/图4-8.adeb3101.png" alt="图4-8" loading="lazy"></p><p>图4-8 JHSDB_TestCase$Test 对象</p><p>这个结果完全符合我们的预期，第二个 ObjectHolder 的指针是在 Java 堆中 JHSDB_TestCase$Test 对象的 instanceObj 字段上。但是我们采用相同方法查找第三个 ObjectHolder 实例时，JHSDB 返回了一个 null，表示未查找到任何结果：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hsdb&gt; revptrs 0x00007f32c7a7c490
null
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>看来 revptrs 命令并不支持查找栈上的指针引用，不过没有关系，得益于我们测试代码足够简洁，人工也可以来完成这件事情。在 Java Thread 窗口选中 main 线程后点击 Stack Memory 按钮查看该线程的栈内存，如图4-9 所示。</p><p><img src="/assets/图4-9.00ff3571.png" alt="图4-9" loading="lazy"></p><p>图4-9 main 线程的栈内存</p><p>这个线程只有两个方法栈帧，尽管没有查找功能，但通过肉眼观察在地址0x00007f32e771c998上的值正好就是0x00007f32c7a7c490，而且JHSDB在旁边已经自动生成注释，说明这里确实是引用了一个来自新生代的JHSDB_TestCase$ObjectHolder对象。至此，本次实验中三个对象均已找到，并成功追溯到引用它们的地方，也就实践验证了开篇中提出的这些对象的引用是存储在什么地方的问题。</p><p>JHSDB提供了非常强大且灵活的命令和功能，本节的例子只是其中一个很小的应用，读者在实际开发、学习时，可以用它来调试虚拟机进程或者dump出来的内存转储快照，以积累更多的实际经验。</p><h3 id="_4-3-2-jconsole-java-监视与管理控制台" tabindex="-1"><a class="header-anchor" href="#_4-3-2-jconsole-java-监视与管理控制台" aria-hidden="true">#</a> 4.3.2 JConsole：Java 监视与管理控制台</h3><p>JConsole（Java Monitoring and Management Console）是一款基于 JMX（Java Manage-ment Extensions）的可视化监视、管理工具。它的主要功能是通过 JMX 的 MBean（Managed Bean）对系统进行信息收集和参数动态调整。JMX 是一种开放性的技术，不仅可以用在虚拟机本身的管理上，还可以运行于虚拟机之上的软件中，典型的如中间件大多也基于 JMX 来实现管理与监控。虚拟机对 JMX MBean 的访问也是完全开放的，可以使用代码调用 API、支持 JMX 协议的管理控制台，或者其他符合 JMX 规范的软件进行访问。</p><p><img src="/assets/图4-10.9d4b66e2.png" alt="图4-10" loading="lazy"></p><p>图4-10 JConsole 连接页面</p><ol><li><p>启动 JConsole</p><p>通过 JDK/bin 目录下的 jconsole.exe 启动 JConsole 后，会自动搜索出本机运行的所有虚拟机进程，而不需要用户自己使用 jps 来查询，如图4-10 所示。双击选择其中一个进程便可进入主界面开始监控。JMX 支持跨服务器的管理，也可以使用下面的 “远程进程” 功能来连接远程服务器，对远程虚拟机进行监控。</p><p>图4-10 中可以看到笔者的机器现在运行了 Eclipse、JConsole、MonitoringTest 三个本地虚拟机进程，这里 MonitoringTest 是笔者准备的 “反面教材” 代码之一。双击它进入 JConsole 主界面，可以看到主界面里共包括 “概述”、“内存”、“线程”、“类”、“VM 摘要”、“MBean” 六个页签，如图4-11 所示。</p><p><img src="/assets/图4-11.76ea3c4b.png" alt="图4-11" loading="lazy"></p><p>图4-11 JConsole 主界面</p><p>“概述” 页签里显示的是整个虚拟机主要运行数据的概览信息，包括 “堆内存使用情况”、“线程”、“类”、“CPU 使用情况” 四项信息的曲线图，这些曲线图是后面 “内存”、“线程”、“类” 页签的信息汇总，具体内容将在稍后介绍。</p></li><li><p>内存监控</p><p>“内存” 页签的作用相当于可视化的 jstat 命令，用于监视被收集器管理的虚拟机内存（被收集器直接管理的 Java 堆和被间接管理的方法区）的变化趋势。我们通过运行代码清单4-7 中的代码来体验一下它的监视功能。运行时设置的虚拟机参数为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xms100m -Xmx100m -XX:+UseSerialGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>代码清单4-7 JConsole 监视代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 内存占位符对象，一个 OOMObject 大约占 64KB
 */</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 稍作延时，令监视曲线的变化更加明显</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token function">fillHeap</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的作用是以 64KB / 50ms 的速度向 Java 堆中填充数据，一共填充 1000 次，使用 JConsole 的 “内存” 页签进行监视，观察曲线和柱状指示图的变化。</p><p>程序运行后，在 “内存” 页签中可以看到内存池 Eden 区的运行趋势呈现折线状，如图4-12 所示。监视范围扩大至整个堆后，会发现曲线是一直平滑向上增长的。从柱状图可以看到，在 1000 次循环执行结束，运行了 System.gc() 后，虽然整个新生代 Eden 和 Survivor 区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在 System.gc() 方法执行之后仍然存活。笔者的分析就到此为止，提两个小问题供读者思考一下，答案稍后公布。</p><p>1）虚拟机启动参数只限制了 Java 堆为 100MB，但没有明确使用 -Xmn 参数指定新生代大小，读者能否从监控图中估算出新生代的容量？</p><p>2）为何执行了 System.gc() 之后，图4-12 中代表老年代的柱状图仍然显示峰值状态，代码需要如何调整才能让 System.gc() 回收掉填充到堆中的对象？</p><p><img src="/assets/图4-12.ddb5063f.png" alt="图4-12" loading="lazy"></p><p>图4-12 Eden 区内存变化状况</p><p>问题 1 答案：图4-12 显示 Eden 空间为 27328KB，因为没有设置 -XX:SurvivorRadio 参数，所以 Eden 与 Survivor 空间比例的默认值为 8∶1，因此整个新生代空间大约为 27328KB × 125% = 34160KB。</p><p>问题 2 答案：执行 System.gc() 之后，空间未能回收是因为 List&lt;OOMObject&gt; list 对象仍然存活，fillHeap() 方法仍然没有退出，因此 list 对象在 System.gc() 执行时仍然处于作用域之内<sup class="footnote-ref"><a href="#footnote15">[15]</a><a class="footnote-anchor" id="footnote-ref15"></a></sup>。如果把 System.gc() 移动到 fillHeap() 方法外调用就可以回收掉全部内存。</p></li><li><p>线程监控</p><p>如果说 JConsole 的 “内存” 页签相当于可视化的 jstat 命令的话，那 “线程” 页签的功能就相当于可视化的 jstack 命令了，遇到线程停顿的时候可以使用这个页签的功能进行分析。前面讲解 jstack 命令时提到线程长时间停顿的主要原因有等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待等，代码清单4-8 将分别演示这几种情况。</p><p>代码清单4-8 线程等待演示代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 线程死循环演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment">// 第 41 行</span>
                <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;testBusyThread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 线程锁等待演示
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createLockThread</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Object</span> lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;testLockThread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createBusyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">createLockThread</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序运行后，首先在 “线程” 页签中选择 main 线程，如图4-13 所示。堆栈追踪显示 BufferedReader 的 readBytes() 方法正在等待 <a href="http://System.in" target="_blank" rel="noopener noreferrer">System.in<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 的键盘输入，这时候线程为 Runnable 状态，Runnable 状态的线程仍会被分配运行时间，但 readBytes() 方法检查到流没有更新就会立刻归还执行令牌给操作系统，这种等待只消耗很小的处理器资源。</p><p><img src="/assets/图4-13.e57ad518.png" alt="图4-13" loading="lazy"></p><p>图4-13 main 线程</p><p>接着监控 testBusyThread 线程，如图4-14 所示。testBusyThread 线程一直在执行空循环，从堆栈追踪中看到一直在 MonitoringTest.java 代码的 41 行停留，41 行的代码为 while(true)。这时候线程为 Runnable 状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给它的执行时间，直到线程切换为止，这种等待会消耗大量的处理器资源。</p><p><img src="/assets/图4-14.59aa1fe6.png" alt="图4-14" loading="lazy"></p><p>图4-14 testBusyThread 线程</p><p>图4-15 显示 testLockThread 线程在等待 lock 对象的 notify() 或 notifyAll() 方法的出现，线程这时候处于 WAITING 状态，在重新唤醒前不会被分配执行时间。</p><p><img src="/assets/图4-15.797ed5eb.png" alt="图4-15" loading="lazy"></p><p>图4-15 testLockThread 线程</p><p>testLockThread 线程正处于正常的活锁等待中，只要 lock 对象的 notify() 或 notifyAll() 方法被调用，这个线程便能激活继续执行。代码清单4-9 演示了一个无法再被激活的死锁等待。</p><p>代码清单4-9 死锁代码样例</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 线程死锁等待演示
 */</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynAddRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SynAddRunnable</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunnable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SynAddRunnable</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码开了 200 个线程去分别计算 1 + 2 以及 2 + 1 的值，理论上 for 循环都是可省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到死锁的效果。如果运气不是特别差的话，上面带 for 循环的版本最多运行两三次就会遇到线程死锁，程序无法结束。造成死锁的根本原因是 Integer.valueOf() 方法出于减少对象创建次数和节省内存的考虑，会对数值为 -128 ~ 127 之间的 Integer 对象进行缓存<sup class="footnote-ref"><a href="#footnote16">[16]</a><a class="footnote-anchor" id="footnote-ref16"></a></sup>，如果 valueOf() 方法传入的参数在这个范围之内，就直接返回缓存中的对象。也就是说代码中尽管调用了 200 次 Integer.valueOf() 方法，但一共只返回了两个不同的 Integer 对象。假如某个线程的两个 synchronized 块之间发生了一次线程切换，那就会出现线程 A 在等待被线程 B 持有的 Integer.valueOf(1)，线程 B 又在等待被线程 A 持有的 Integer.valueOf(2)，结果大家都跑不下去的情况。</p><p>出现线程死锁之后，点击 JConsole 线程面板的 “检测到死锁” 按钮，将出现一个新的 “死锁” 页签，如图4-16 所示。</p><p><img src="/assets/图4-16.7eca6872.png" alt="图4-16" loading="lazy"></p><p>图4-16 线程死锁</p><p>图4-16 中很清晰地显示，线程 Thread-43 在等待一个被线程 Thread-12 持有的 Integer 对象，而点击线程 Thread-12 则显示它也在等待一个被线程 Thread-43 持有的 Integer 对象，这样两个线程就互相卡住，除非牺牲其中一个，否则死锁无法释放。</p></li></ol><h3 id="_4-3-3-visualvm-多合一故障处理工具" tabindex="-1"><a class="header-anchor" href="#_4-3-3-visualvm-多合一故障处理工具" aria-hidden="true">#</a> 4.3.3 VisualVM：多合一故障处理工具</h3><p>VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是 Oracle 官方主力发展的虚拟机故障处理工具。Oracle 曾在 VisualVM 的软件说明中写上了 &quot;All-in-One&quot; 的字样，预示着它除了常规的运行监视、故障处理外，还将提供其他方面的能力，譬如性能分析（Profiling）。VisualVM 的性能分析功能比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不遑多让。而且相比这些第三方工具，VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 去运行，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p><ol><li><p>VisualVM 兼容范围与插件安装</p><p>VisualVM 基于 NetBeans 平台开发工具，所以一开始它就具备了通过插件扩展功能的能力，有了插件扩展支持，VisualVM 可以做到：</p><ul><li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li><li>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。</li><li>dump 以及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</li><li>其他插件带来的无限可能性。</li></ul><p>VisualVM 在 JDK 6 Update 7 中首次发布，但并不意味着它只能监控运行于 JDK 6 上的程序，它具备很优秀的向下兼容性，甚至能向下兼容至 2003 年发布的 JDK 1.4.2 版本<sup class="footnote-ref"><a href="#footnote17">[17]</a><a class="footnote-anchor" id="footnote-ref17"></a></sup>，这对无数处于已经完成实施、正在维护的遗留项目很有意义。当然，也并非所有功能都能完美地向下兼容，主要功能的兼容性见表4-16 所示。</p><p>表4-16 VisualVM 主要功能兼容性列表</p><p><img src="/assets/表4-16.872256c3.png" alt="表4-16" loading="lazy"></p><p>首次启动 VisualVM 后，读者先不必着急找应用程序进行监测，初始状态下的 VisualVM 并没有加载任何插件，虽然基本的监视、线程面板的功能主程序都以默认插件的形式提供，但是如果不在 VisualVM 上装任何扩展插件，就相当于放弃它最精华的功能，和没有安装任何应用软件的操作系统差不多。</p><p>VisualVM 的插件可以手工进行安装，在网站<sup class="footnote-ref"><a href="#footnote18">[18]</a><a class="footnote-anchor" id="footnote-ref18"></a></sup>上下载 nbm 包后，点击 “工具 -&gt; 插件 -&gt; 已下载” 菜单，然后在弹出对话框中指定 nbm 包路径便可完成安装。独立安装的插件存储在 VisualVM 的根目录，譬如 JDK 9 之前自带的 VisulalVM，插件安装后是放在 JDK_HOME/lib/visualvm 中的。手工安装插件并不常用，VisualVM 的自动安装功能已可找到大多数所需的插件，在有网络连接的环境下，点击 “工具 -&gt; 插件菜单”，弹出如图4-17 所示的插件页签，在页签的 “可用插件” 及 “已安装” 中列举了当前版本 VisualVM 可以使用的全部插件，选中插件后在右边窗口会显示这个插件的基本信息，如开发者、版本、功能描述等。</p><p><img src="/assets/图4-17.c2b5a2cb.png" alt="图4-17" loading="lazy"></p><p>图4-17 VisualVM 插件页签</p><p>读者可根据自己的工作需要和兴趣选择合适的插件，然后点击 “安装” 按钮，弹出如图4-18 所示的下载进度窗口，跟着提示操作即可完成安装。</p><p><img src="/assets/图4-18.ecd5ebdb.png" alt="图4-18" loading="lazy"></p><p>图4-18 VisualVM 插件安装过程</p><p>选择一个需要监视的程序就可以进入程序的主界面了，如图4-19 所示。由于 VisualVM 的版本以及选择安装插件数量的不同，读者看到的页签可能和笔者的截图有所差别。</p><p><img src="/assets/图4-19.7ebd3215.png" alt="图4-19" loading="lazy"></p><p>图4-19 VisualVM 主界面</p><p>VisualVM 中“概述”、“监视”、“线程”、“MBeans” 的功能与前面介绍的 JConsole 差别不大，读者可根据上一节内容类比使用，这里笔者挑选几个有特色的功能和插件进行简要介绍。</p></li><li><p>生成、浏览堆转储快照</p><p>在 VisualVM 中生成堆转储快照文件有两种方式，可以执行下列任一操作：</p><ul><li>在 “应用程序” 窗口中右键单击应用程序节点，然后选择 “堆 Dump”。</li><li>在 “应用程序” 窗口中双击应用程序节点以打开应用程序标签，然后在 “监视” 标签中单击 “堆 Dump”。</li></ul><p>生成堆转储快照文件之后，应用程序页签会在该堆的应用程序下增加一个以 [heap-dump] 开头的子节点，并且在主页签中打开该转储快照，如图4-20 所示。如果需要把堆转储快照保存或发送出去，就应在 heapdump 节点上右键选择 “另存为” 菜单，否则当 VisualVM 关闭时，生成的堆转储快照文件会被当作临时文件自动清理掉。要打开一个由已经存在的堆转储快照文件，通过文件菜单中的 “装入” 功能，选择硬盘上的文件即可。</p><p><img src="/assets/图4-20.d2f31ef1.png" alt="图4-20" loading="lazy"></p><p>图4-20 浏览 dump 文件</p><p>堆页签中的 “摘要” 面板可以看到应用程序 dump 时的运行时参数、System.getProperties() 的内容、线程堆栈等信息；“类” 面板则是以类为统计口径统计类的实例数量、容量信息；“实例” 面板不能直接使用，因为 VisualVM 在此时还无法确定用户想查看哪个类的实例，所以需要通过 “类” 面板进入，在 “类” 中选择一个需要查看的类，然后双击即可在 “实例” 里面看到此类的其中 500 个实例的具体属性信息；“OQL 控制台” 面板则是运行 OQL 查询语句的，同 jhat 中介绍的 OQL 功能一样。如果读者想要了解具体 OQL 的语法和使用方法，可参见本书附录 D 的内容。</p></li><li><p>分析程序性能</p><p>在 Profiler 页签中，VisualVM 提供了程序运行期间方法级的处理器执行时间分析以及内存分析。做 Profiling 分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境使用这项功能，或者改用 JMC 来完成，JMC 的 Profiling 能力更强，对应用的影响非常轻微。</p><p>要开始性能分析，先选择 “CPU” 和 “内存” 按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM 会记录这段时间中应用程序执行过的所有方法。如果是进行处理器执行时间分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析，则会统计每个方法关联的对象数以及这些对象所占的空间。等要分析的操作执行结束后，点击 “停止” 按钮结束监控过程，如图4-21 所示。</p><p><img src="/assets/图4-21.2a331d25.png" alt="图4-21" loading="lazy"></p><p>图4-21 对应用程序进行 CPU 执行时间分析</p><p><strong>注意</strong>：在 JDK 5 之后，在客户端模式下的虚拟机加入并且自动开启了类共享——这是一个在多虚拟机进程共享 rt.jar 中类数据以提高加载速度和节省内存的优化，而根据相关 Bug 报告的反映，VisualVM 的 Profiler 功能会因为类共享而导致被监视的应用程序崩溃，所以读者进行 Profiling 前，最好在被监视程序中使用 -Xshare:off 参数来关闭类共享优化。</p><p>图4-21 中是对 Eclipse IDE 一段操作的录制和分析结果，读者分析自己的应用程序时，可根据实际业务复杂程度与方法的时间、调用次数做比较，找到最优化价值方法。</p></li><li><p>BTrace 动态日志跟踪</p><p>BTrace<sup class="footnote-ref"><a href="#footnote19">[19]</a><a class="footnote-anchor" id="footnote-ref19"></a></sup>是一个很神奇的 VisualVM 插件，它本身也是一个可运行的独立程序。BTrace 的作用是在不中断目标程序运行的前提下，通过 HotSpot 虚拟机的 Instrument 功能<sup class="footnote-ref"><a href="#footnote20">[20]</a><a class="footnote-anchor" id="footnote-ref20"></a></sup>动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义：如当程序出现问题时，排查错误的一些必要信息时（譬如方法参数、返回值等），在开发时并没有打印到日志之中以至于不得不停掉服务时，都可以通过调试增量来加入日志代码以解决问题。</p><p>在 VisualVM 中安装了 BTrace 插件后，在应用程序面板中右击要调试的程序，会出现 &quot;Trace Application…&quot; 菜单，点击将进入 BTrace 面板。这个面板看起来就像一个简单的 Java 程序开发环境，里面甚至已经有了一小段 Java 代码，如图4-22 所示。</p><p><img src="/assets/图4-22.b607a545.png" alt="图4-22" loading="lazy"></p><p>图4-22 BTrace 动态跟踪</p><p>笔者准备了一段简单的 Java 代码来演示 BTrace 的功能：产生两个 1000 以内的随机整数，输出这两个数字相加的结果，如代码清单4-10 所示。</p><p>代码清单4-10 BTrace 跟踪演示</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BTraceTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">BTraceTest</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BTraceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设这段程序已经上线运行，而我们现在又有了新的需求，想要知道程序中生成的两个随机数是什么，但程序并没有在执行过程中输出这一点。此时，在 VisualVM 中打开该程序的监视，在 BTrace 页签填充 TracingScript 的内容，输入调试代码，如代码清单4-11 所示，即可在不中断程序运行的情况下做到这一点。</p><p>代码清单4-11 BTrace 调试代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/* BTrace Script Template */</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>btrace<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>btrace<span class="token punctuation">.</span></span><span class="token class-name">BTraceUtils</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@BTrace</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TracingScript</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@OnMethod</span><span class="token punctuation">(</span>
        clazz<span class="token operator">=</span><span class="token string">&quot;org.fenixsoft.monitoring.BTraceTest&quot;</span><span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">,</span> location<span class="token operator">=</span><span class="token annotation punctuation">@Location</span><span class="token punctuation">(</span><span class="token class-name">Kind</span><span class="token punctuation">.</span>RETURN<span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Self</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>monitoring<span class="token punctuation">.</span></span>BTraceTest</span> instance<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token annotation punctuation">@Return</span> <span class="token keyword">int</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;调用堆栈:&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">jstack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token string">&quot;方法参数A:&quot;</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token string">&quot;方法参数B:&quot;</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token string">&quot;方法结果:&quot;</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>点击 Start 按钮后稍等片刻，编译完成后，Output 面板中会出现 &quot;BTrace code successfuly deployed&quot; 的字样。当程序运行时将会在 Output 面板输出如图4-23 所示的调试信息。</p><p><img src="/assets/图4-23.13d84990.png" alt="图4-23" loading="lazy"></p><p>图4-23 BTrace 跟踪结果</p><p>BTrace 的用途很广泛，打印调用堆栈、参数、返回值只是它最基础的使用形式，在它的网站上有使用 BTrace 进行性能监视、定位连接泄漏、内存泄漏、解决多线程竞争问题等的使用案例，有兴趣的读者可以去网上了解相关信息。</p><p>BTrace 能够实现动态修改程序行为，是因为它是基于 Java 虚拟机的 Instrument 开发的。Instrument 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface，JVMTI）的重要组件，提供了一套代理（Agent）机制，使得第三方工具程序可以以代理的方式访问和修改 Java 虚拟机内部的数据。阿里巴巴开源的诊断工具 Arthas 也通过 Instrument 实现了与 BTrace 类似的功能。</p></li></ol><h3 id="_4-3-4-java-mission-control-可持续在线的监控工具" tabindex="-1"><a class="header-anchor" href="#_4-3-4-java-mission-control-可持续在线的监控工具" aria-hidden="true">#</a> 4.3.4 Java Mission Control：可持续在线的监控工具</h3><p>除了大家熟知的面向通用计算（General Purpose Computing）可免费使用的 Java SE 外，Oracle 公司还开辟过带商业技术支持的 Oracle Java SE Support 和面向独立软件供应商（ISV）的 Oracle Java SE Advanced &amp; Suite 产品线。</p><p>除去带有 7 × 24 小时的技术支持以及可以为企业专门定制安装包这些非技术类的增强服务外，Oracle Java SE Advanced &amp; Suite<sup class="footnote-ref"><a href="#footnote21">[21]</a><a class="footnote-anchor" id="footnote-ref21"></a></sup>与普通 Oracle Java SE 在功能上的主要差别是前者包含了一系列的监控、管理工具，譬如用于企业 JRE 定制管理的 AMC（Java Advanced Management Console）控制台、JUT（Java Usage Tracker）跟踪系统，用于持续收集数据的 JFR（Java Flight Recorder）飞行记录仪和用于监控 Java 虚拟机的 JMC（Java Mission Control）。这些功能全部都是需要商业授权才能在生产环境中使用，但根据 Oracle Binary Code 协议，在个人开发环境中，允许免费使用 JMC 和 JFR，本节笔者将简要介绍它们的原理和使用。</p><p>JFR 是一套内建在 HotSpot 虚拟机里面的监控和基于事件的信息搜集框架，与其他的监控工具（如 JProfiling）相比，Oracle 特别强调它 “可持续在线”（Always-On）的特性。JFR 在生产环境中对吞吐量的影响一般不会高于 1%（甚至号称是 Zero Performance Overhead），而且 JFR 监控过程的开始、停止都是完全可动态的，即不需要重启应用。JFR 的监控对应用也是完全透明的，即不需要对应用程序的源码做任何修改，或者基于特定的代理来运行。</p><p>JMC 最初是 BEA 公司的产品，因此并没有像 VisualVM 那样一开始就基于自家的 NetBeans 平台来开发，而是选择了由 IBM 捐赠的 Eclipse RCP 作为基础框架，现在的 JMC 不仅可以下载到独立程序，更常见的是作为 Eclipse 的插件来使用。JMC 与虚拟机之间同样采取 JMX 协议进行通信，JMC 一方面作为 JMX 控制台，显示来自虚拟机 MBean 提供的数据；另一方面作为 JFR 的分析工具，展示来自 JFR 的数据。启动后 JMC 的主界面如图4-24 所示。</p><p><img src="/assets/图4-24.62d6db6d.png" alt="图4-24" loading="lazy"></p><p>图4-24 JMC 主界面</p><p>在左侧的 “JVM 浏览器” 面板中自动显示了通过 JDP 协议（Java Discovery Protocol）找到的本机正在运行的 HotSpot 虚拟机进程，如果需要监控其他服务器上的虚拟机，可在 “文件 -&gt; 连接” 菜单中创建远程连接，如图4-25 所示。</p><p><img src="/assets/图4-25.bfecb924.png" alt="图4-25" loading="lazy"></p><p>图4-25 JMC 建立连接界面</p><p>这里要填写的信息应该在被监控虚拟机进程启动的时候以虚拟机参数的形式指定，以下是一份被监控端的启动参数样例：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Dcom.sun.management.jmxremote.port=9999
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
-Djava.rmi.server.hostname=192.168.31.4
-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本地虚拟机与远程虚拟机进程的差别只限于创建连接这个步骤，连接成功创建以后的操作就是完全一样的了。把 “JVM 浏览器” 面板中的进程展开后，可以看到每个进程的数据都有 MBean 和 JFR 两个数据来源。关于 MBean 这部分数据，与 JConsole 和 VisualVM 上取到的内容是一样的，只是展示形式上有些差别，笔者就不再重复了，后面着重介绍 JFR 的数据记录。</p><p>双击 “飞行记录器”，将会出现 “启动飞行记录” 窗口（如果第一次使用，还会收到解锁商业功能的警告窗），如图4-26 所示。</p><p><img src="/assets/图4-26.d0c5fc3f.png" alt="图4-26" loading="lazy"></p><p>图4-26 启用飞行记录</p><p>在启动飞行记录时，可以进行记录时间、垃圾收集器、编译器、方法采样、线程记录、异常记录、网络和文件 I/O、事件记录等选项和频率设定，这部分比较琐碎，笔者就不一一截图讲解了。点击 “完成” 按钮后马上就会开始记录，记录时间结束以后会生成飞行记录报告，如图4-27 所示。</p><p><img src="/assets/图4-27.20aa9b48.png" alt="图4-27" loading="lazy"></p><p>图4-27 飞行记录报告</p><p>飞行记录报告里包含以下几类信息：</p><ul><li>一般信息：关于虚拟机、操作系统和记录的一般信息。</li><li>内存：关于内存管理和垃圾收集的信息。</li><li>代码：关于方法、异常错误、编译和类加载的信息。</li><li>线程：关于应用程序中线程和锁的信息。</li><li>I/O：关于文件和套接字输入、输出的信息。</li><li>系统：关于正在运行Java虚拟机的系统、进程和环境变量的信息。</li><li>事件：关于记录中的事件类型的信息，可以根据线程或堆栈跟踪，按照日志或图形的格式查看。</li></ul><p>JFR 的基本工作逻辑是开启一系列事件的录制动作，当某个事件发生时，这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中，循环日志相当于数据流被保留在一个环形缓存中，所以只有最近发生的事件的数据才是可用的。JMC 从虚拟机内存或者文件中读取并展示这些事件数据，并通过这些数据进行性能分析。</p><p>即使不考虑对被测试程序性能影响方面的优势，JFR 提供的数据质量通常也要比其他工具通过代理形式采样获得或者从 MBean 中取得的数据高得多。以垃圾搜集为例，HotSpot 的 MBean 中一般有各个分代大小、收集次数、时间、占用率等数据（根据收集器不同有所差别），这些都属于 “结果” 类的信息，而 JFR 中还可以看到内存中这段时间分配了哪些对象、哪些在 TLAB 中（或外部）分配、分配速率和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等，这些就是属于 “过程” 类的信息，对排查问题的价值是难以估量的。</p><h2 id="_4-4-hotspot-虚拟机插件及工具" tabindex="-1"><a class="header-anchor" href="#_4-4-hotspot-虚拟机插件及工具" aria-hidden="true">#</a> 4.4 HotSpot 虚拟机插件及工具</h2><p>HotSpot 虚拟机发展了二十余年，现在已经是一套很复杂的软件系统，如果深入挖掘 HotSpot 的源码，可以发现在 HotSpot 的研发过程中，开发团队曾经编写（或者收集）过不少虚拟机的插件和辅助工具，它们存放在 HotSpot 源码 hotspot/src/share/tools 目录下，包括（含曾经有过但新版本中已被移除的）：</p><ul><li>Ideal Graph Visualizer：用于可视化展示 C2 即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li><li>Client Compiler Visualizer<sup class="footnote-ref"><a href="#footnote22">[22]</a><a class="footnote-anchor" id="footnote-ref22"></a></sup>：用于查看 C1 即时编译器生成高级中间表示（HIR），转换成低级中间表示（LIR）和做物理寄存器分配的过程。</li><li>MakeDeps：帮助处理 HotSpot 的编译依赖的工具。</li><li>Project Creator：帮忙生成 Visual Studio 的 .project 文件的工具。</li><li>LogCompilation：将 -XX:+LogCompilation 输出的日志整理成更容易阅读的格式的工具。</li><li>HSDIS：即时编译器的反汇编插件。</li></ul><p>关于 Client Compiler Visualizer 和 Ideal Graph Visualizer，在本书第 11 章会有专门的使用介绍，而 Project Creator、LogCompilation、MakeDeps 这三个工具对本书的讲解和实验帮助有限，最后一个 HSDIS 是学习、实践本书第四部分 “程序编译与代码优化” 的有力辅助工具，借本章讲解虚拟机工具的机会，简要介绍其使用方法。</p><p><strong>HSDIS：JIT 生成代码反汇编</strong></p><p>在《Java 虚拟机规范》里详细定义了虚拟机指令集中每条指令的语义，尤其是执行过程前后对操作数栈、局部变量表的影响。这些细节描述与早期 Java 虚拟机（Sun Classic 虚拟机）高度吻合，但随着技术的发展，高性能虚拟机真正的细节实现方式已经渐渐与《Java 虚拟机规范》所描述的内容产生越来越大的偏差，《Java 虚拟机规范》中的规定逐渐成为 Java 虚拟机实现的 “概念模型”，即实现只保证与规范描述等效，而不一定是按照规范描述去执行。由于这个原因，我们在讨论程序的执行语义问题（虚拟机做了什么）时，在字节码层面上分析完全可行，但讨论程序的执行行为问题（虚拟机是怎样做的、性能如何）时，在字节码层面上分析就没有什么意义了，必须通过其他途径解决。</p><p>至于分析程序如何执行，使用软件调试工具（GDB、Windbg 等）来进行断点调试是一种常见的方式，但是这样的调试方式在 Java 虚拟机中也遇到了很大麻烦，因为大量执行代码是通过即时编译器动态生成到代码缓存中的，并没有特别简单的手段来处理这种混合模式的调试，不得不通过一些曲线的间接方法来解决问题。在这样的背景下，本节的主角——HSDIS 插件就正式登场了。</p><p>HSDIS 是一个被官方推荐的 HotSpot 虚拟机即时编译代码的反汇编插件，它包含在 HotSpot 虚拟机的源码当中<sup class="footnote-ref"><a href="#footnote23">[23]</a><a class="footnote-anchor" id="footnote-ref23"></a></sup>，在 OpenJDK 的网站<sup class="footnote-ref"><a href="#footnote24">[24]</a><a class="footnote-anchor" id="footnote-ref24"></a></sup>也可以找到单独的源码下载，但并没有提供编译后的程序。</p><p>HSDIS 插件的作用是让 HotSpot 的 -XX:+PrintAssembly 指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。读者可以根据自己的操作系统和处理器型号，从网上直接搜索、下载编译好的插件，直接放到 JDK_HOME/jre/bin/server 目录（JDK 9 以下）或 JDK_HOME/lib/amd64/server（JDK 9 或以上）中即可使用。如果读者确实没有找到所采用操作系统的对应编译成品<sup class="footnote-ref"><a href="#footnote25">[25]</a><a class="footnote-anchor" id="footnote-ref25"></a></sup>，那就自己用源码编译一遍（网上能找到各种操作系统下的编译教程）。</p><p>另外还有一点需要注意，如果读者使用的是 SlowDebug 或者 FastDebug 版的 HotSpot，那可以直接通过 -XX:+PrintAssembly 指令使用的插件；如果读者使用的是 Product 版的 HotSpot，则还要额外加入一个 -XX:+UnlockDiagnosticVMOptions 参数才可以工作。笔者以代码清单4-12 中的测试代码为例简单演示一下如何使用这个插件。</p><p>代码清单4-12 测试代码</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译这段代码，并使用以下命令执行：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>java -XX:+PrintAssembly -Xcomp -XX:CompileCommand=dontinline,*Bar.sum -XX:CompileCommand=compileonly,*Bar.sum test.Bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，参数 -Xcomp 是让虚拟机以编译模式执行代码，这样不需要执行足够次数来预热就能触发即时编译。两个 -XX:CompileCommand 的意思是让编译器不要内联 sum() 并且只编译 sum()，-XX:+PrintAssembly 就是输出反汇编内容。如果一切顺利的话，屏幕上会出现类似代码清单4-13 所示的内容。</p><p>代码清单4-13 测试代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Disassembling for mach=&#39;i386&#39;] 
[Entry Point]
[Constants]
     # {method} &#39;sum&#39; &#39;(I)I&#39; in &#39;test/Bar&#39; 
     # this:	ecx	= &#39;test/Bar&#39;
     # parm0:	edx	= int
     #	        [sp+0x20] (sp of caller)
    ...
    0x01cac407: cmp	0x4(%ecx),%eax
    0x01cac40a: jne	0x01c6b050; {runtime_call} 
[Verified Entry Point]
0x01cac410: mov	%eax,-0x8000(%esp) 
0x01cac417: push	%ebp
0x01cac418: sub	$0x18,%esp; *aload_0 
                          ;- test.Bar::sum@0 (line 8)
;; block B0 [0, 10]
0x01cac41b: mov	0x8(%ecx),%eax; *getfield a
                              ;- test.Bar::sum@1 (line 8) 
0x01cac41e: mov	$0x3d2fad8,%esi; {oop(a &#39;java/lang/Class&#39; = &#39;test/Bar&#39;)}
0x01cac423: mov	0x68(%esi),%esi; *getstatic b
                               ; - test.Bar::sum@4 (line 8)
0x01cac426: add	%esi,%eax 
0x01cac428: add	%edx,%eax 
0x01cac42a: add	$0x18,%esp 
0x01cac42d: pop	%ebp
0x01cac42e: test %eax,0x2b0100; {poll_return} 
0x01cac434: ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然是汇编，但代码并不多，我们一句一句来阅读：</p><ol><li>mov%eax, -0x8000(%esp)：检查栈溢。</li><li>push%ebp：保存上一栈帧基址。</li><li>sub$0x18, %esp：给新帧分配空间。</li><li>mov 0x8(%ecx), %eax：取实例变量 a，这里 0x8(%ecx) 就是 ecx + 0x8 的意思，前面代码片段 &quot;[Constants]&quot; 中提示了 &quot;this: ecx=&#39;test/Bar&#39;&quot;，即 ecx 寄存器中放的就是 this 对象的地址。偏移 0x8 是越过 this 对象的对象头，之后就是实例变量 a 的内存位置。这次是访问 Java 堆中的数据。</li><li>mov$0x3d2fad8, %esi：取 test.Bar 在方法区的指针。</li><li>mov 0x68(%esi), %esi：取类变量 b，这次是访问方法区中的数据。</li><li>add%esi, %eax、add%edx, %eax：做 2 次加法，求 a + b + c 的值，前面的代码把 a 放在 eax 中，把 b 放在 esi 中，而 c 在 [Constants] 中提示了，&quot;parm0: edx=int&quot;，说明 c 在 edx 中。</li><li>add$0x18, %esp：撤销栈帧。</li><li>pop%ebp：恢复上一栈帧。</li><li>test%eax, 0x2b0100：轮询方法返回处的 SafePoint。</li><li>ret：方法返回。</li></ol><p>在这个例子中测试代码比较简单，肉眼直接看日志中的汇编输出是可行的，但在正式环境中 -XX:+PrintAssembly 的日志输出量巨大，且难以和代码对应起来，这就必须使用工具来辅助了。</p><p>JITWatch<sup class="footnote-ref"><a href="#footnote26">[26]</a><a class="footnote-anchor" id="footnote-ref26"></a></sup>是 HSDIS 经常搭配使用的可视化的编译日志分析工具，为便于在 JITWatch 中读取，读者可使用以下参数把日志输出到 logfile 文件：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+LogCompilation
-XX:LogFile=/tmp/logfile.log
-XX:+PrintAssembly
-XX:+TraceClassLoading
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JITWatch 中加载日志后，就可以看到执行期间使用过的各种对象类型和对应调用过的方法了，界面如图4-28 所示。</p><p><img src="/assets/图4-28.dd2c36bc.png" alt="图4-28" loading="lazy"></p><p>图4-28 JITWatch 主界面</p><p>选择想要查看的类和方法，即可查看对应的 Java 源代码、字节码和即时编译器生成的汇编代码，如图4-29 所示。</p><p><img src="/assets/图4-29.cf6e2d59.png" alt="图4-29" loading="lazy"></p><p>图4-29 查看方法代码</p><h2 id="_4-5-本章小结" tabindex="-1"><a class="header-anchor" href="#_4-5-本章小结" aria-hidden="true">#</a> 4.5 本章小结</h2><p>本章介绍了随 JDK 发布的 6 个命令行工具与 4 个可视化的故障处理工具，灵活使用这些工具，可以为处理问题带来很大的便利。除了本章涉及的 OpenJDK 中自带的工具之外，还有很多其他监控和故障处理工具，如何进行监控和故障诊断，这并不是《Java 虚拟机规范》中定义的内容，而是取决于虚拟机实现自身的设计，因此每种处理工具都有针对的目标范围，如果读者使用的是非 HotSpot 系的虚拟机，就更需要使用对应的工具进行分析，如：</p><ul><li>IBM 的 Support Assistant<sup class="footnote-ref"><a href="#footnote27">[27]</a><a class="footnote-anchor" id="footnote-ref27"></a></sup>、Heap Analyzer<sup class="footnote-ref"><a href="#footnote28">[28]</a><a class="footnote-anchor" id="footnote-ref28"></a></sup>、Javacore Analyzer<sup class="footnote-ref"><a href="#footnote29">[29]</a><a class="footnote-anchor" id="footnote-ref29"></a></sup>、Garbage Collector Analyzer<sup class="footnote-ref"><a href="#footnote30">[30]</a><a class="footnote-anchor" id="footnote-ref30"></a></sup>适用于 IBM J9 / OpenJ9 VM。</li><li>HP 的 HPjmeter、HPjtune 适用于 HP-UX、SAP、HotSpot VM。</li><li>Eclipse 的 Memory Analyzer Tool<sup class="footnote-ref"><a href="#footnote31">[31]</a><a class="footnote-anchor" id="footnote-ref31"></a></sup>（MAT）适用于 HP-UX、SAP、HotSpot VM，安装 IBM DTFJ<sup class="footnote-ref"><a href="#footnote32">[32]</a><a class="footnote-anchor" id="footnote-ref32"></a></sup>插件后可支持 IBM J9 虚拟机。</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>无论是 GPL、BCL 还是 OTN 协议，JMC 在个人开发环境中使用是免费的。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>这并不意味着永久存在，只是被移除前会有 &quot;deprecated&quot; 的过渡期，正式工具被移除的数量并不比实验性工具来得少。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>图4-2 中展示的是 JDK 9 模块化改造之后的类库形式，在 JDK 9 前，这些代码实现在 jdk\lib\tools.jar 中。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>有一部分工具的实现并不属于 Java SE 的标准 API，如果引入这些类库，就意味着你的程序只能运行于 HotSpot（或一些从 Oracle 买了 JDK 的源码许可证的虚拟机）上面，又或者在部署程序时需要一起部署这些工具类库。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>需要远程主机提供 RMI 支持，JDK 中提供了 jstatd 工具可以很方便地建立远程 RMI 服务器。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p>用于分析的机器一般也是服务器，由于加载 dump 快照文件需要比生成 dump 更大的内存，所以一般在 64 位 JDK、大内存的服务器上进行。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li><li id="footnote7" class="footnote-item"><p>IBM HeapAnalyzer 用于分析 IBM J9 虚拟机生成的映像文件，各个虚拟机产生的映像文件格式并不一致，所以分析工具也不能通用。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p></li><li id="footnote8" class="footnote-item"><p>详细信息见 <a href="http://openjdk.java.net/jeps/320%E3%80%82" target="_blank" rel="noopener noreferrer">http://openjdk.java.net/jeps/320。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p></li><li id="footnote9" class="footnote-item"><p>准确来说是 Linux 和 Solaris 在 OracleJDK 6 就可以使用 HSDB 和 CLHSDB 了，Windows 上要到 OracleJDK 7 才可以用。 <a href="#footnote-ref9" class="footnote-backref">↩︎</a></p></li><li id="footnote10" class="footnote-item"><p>VisualVM 官方站点：<a href="https://visualvm.github.io" target="_blank" rel="noopener noreferrer">https://visualvm.github.io<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。 <a href="#footnote-ref10" class="footnote-backref">↩︎</a></p></li><li id="footnote11" class="footnote-item"><p>详见 <a href="https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later%E3%80%82" target="_blank" rel="noopener noreferrer">https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref11" class="footnote-backref">↩︎</a></p></li><li id="footnote12" class="footnote-item"><p>本小节的原始案例来自 RednaxelaFX 的博客 <a href="https://rednaxelafx.iteye.com/blog/1847971%E3%80%82" target="_blank" rel="noopener noreferrer">https://rednaxelafx.iteye.com/blog/1847971。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref12" class="footnote-backref">↩︎</a></p></li><li id="footnote13" class="footnote-item"><p>效果与在 Windows -&gt; Console 中输入 universe 命令是等价的，JHSDB 的图形界面中所有操作都可以通过命令行完成，读者感兴趣的话，可以在控制台中输入 help 命令查看更多信息。 <a href="#footnote-ref13" class="footnote-backref">↩︎</a></p></li><li id="footnote14" class="footnote-item"><p>在 JDK 7 以前，即还没有开始 “去永久代” 行动时，这些静态变量是存放在永久代上的，JDK 7 起把静态变量、字符常量这些从永久代移除出去。 <a href="#footnote-ref14" class="footnote-backref">↩︎</a></p></li><li id="footnote15" class="footnote-item"><p>准确地说，只有虚拟机使用解释器执行的时候，“在作用域之内” 才能保证它不会被回收，因为这里的回收还涉及局部变量表变量槽的复用、即时编译器介入时机等问题，具体读者可参考第 8 章的代码清单8-1。 <a href="#footnote-ref15" class="footnote-backref">↩︎</a></p></li><li id="footnote16" class="footnote-item"><p>这是《Java 虚拟机规范》中明确要求缓存的默认值，实际值可以调整，具体取决于 java.lang.Integer.IntegerCache.high 参数的设置。 <a href="#footnote-ref16" class="footnote-backref">↩︎</a></p></li><li id="footnote17" class="footnote-item"><p>早于 JDK 6 的平台，需要打开 -Dcom.sun.management.jmxremote 参数才能被 VisualVM 管理。 <a href="#footnote-ref17" class="footnote-backref">↩︎</a></p></li><li id="footnote18" class="footnote-item"><p>插件中心地址：<a href="https://visualvm.github.io/pluginscenters.html%E3%80%82" target="_blank" rel="noopener noreferrer">https://visualvm.github.io/pluginscenters.html。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref18" class="footnote-backref">↩︎</a></p></li><li id="footnote19" class="footnote-item"><p>官方主页：<a href="https://github.com/btraceio/btrace%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/btraceio/btrace。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref19" class="footnote-backref">↩︎</a></p></li><li id="footnote20" class="footnote-item"><p>是 JVMTI 中的主要组成部分，HotSpot 虚拟机允许在不停止运行的情况下，更新已经加载的类的代码。 <a href="#footnote-ref20" class="footnote-backref">↩︎</a></p></li><li id="footnote21" class="footnote-item"><p>Advanced 是 &quot;Advanced Monitoring &amp; Management of Java in the Enterprise&quot; 的缩写。 <a href="#footnote-ref21" class="footnote-backref">↩︎</a></p></li><li id="footnote22" class="footnote-item"><p>不同于 Ideal Graph Visualizer，Client Compiler Visualizer 的源码其实从未进入过 HotSpot 的代码仓库，不过为了 C1、C2 配对，还是把它列在这里。 <a href="#footnote-ref22" class="footnote-backref">↩︎</a></p></li><li id="footnote23" class="footnote-item"><p>OpenJDK 中的源码位置：hotspot/src/share/tools/hsdis/。 <a href="#footnote-ref23" class="footnote-backref">↩︎</a></p></li><li id="footnote24" class="footnote-item"><p>地址：<a href="http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/tip/src/share/tools/hsdis/%E3%80%82%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8" target="_blank" rel="noopener noreferrer">http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/tip/src/share/tools/hsdis/。也可以在<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> GitHub 上搜索 HSDIS 得到。 <a href="#footnote-ref24" class="footnote-backref">↩︎</a></p></li><li id="footnote25" class="footnote-item"><p>HLLVM 圈子中有已编译好的，地址：<a href="http://hllvm.group.iteye.com/%E3%80%82" target="_blank" rel="noopener noreferrer">http://hllvm.group.iteye.com/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref25" class="footnote-backref">↩︎</a></p></li><li id="footnote26" class="footnote-item"><p>下载地址：<a href="https://github.com/AdoptOpenJDK/jitwatch%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/AdoptOpenJDK/jitwatch。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref26" class="footnote-backref">↩︎</a></p></li><li id="footnote27" class="footnote-item"><p><a href="http://www-01.ibm.com/software/support/isa/%E3%80%82" target="_blank" rel="noopener noreferrer">http://www-01.ibm.com/software/support/isa/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref27" class="footnote-backref">↩︎</a></p></li><li id="footnote28" class="footnote-item"><p><a href="http://www.alphaworks.ibm.com/tech/heapanalyzer/download%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.alphaworks.ibm.com/tech/heapanalyzer/download。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref28" class="footnote-backref">↩︎</a></p></li><li id="footnote29" class="footnote-item"><p><a href="http://www.alphaworks.ibm.com/tech/jca/download%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.alphaworks.ibm.com/tech/jca/download。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref29" class="footnote-backref">↩︎</a></p></li><li id="footnote30" class="footnote-item"><p><a href="http://www.alphaworks.ibm.com/tech/pmat/download%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.alphaworks.ibm.com/tech/pmat/download。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref30" class="footnote-backref">↩︎</a></p></li><li id="footnote31" class="footnote-item"><p><a href="http://www.eclipse.org/mat/%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.eclipse.org/mat/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref31" class="footnote-backref">↩︎</a></p></li><li id="footnote32" class="footnote-item"><p><a href="http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.ibm.com/developerworks/java/jdk/tools/dtfj.html。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref32" class="footnote-backref">↩︎</a></p></li></ol></section></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/深入理解Java虚拟机：JVM高级特性与最佳实践/第4章虚拟机性能监控、故障处理工具.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/12 下午5:39:15</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC3%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.html" class="nav-link prev" aria-label="第 3 章 垃圾收集器与内存分配策略"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 3 章 垃圾收集器与内存分配策略</div></a><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC5%E7%AB%A0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link next" aria-label="第 5 章 调优案例分析与实战"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 5 章 调优案例分析与实战<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
