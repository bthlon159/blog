<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 1 章 走近 Java"><meta property="og:type" content="article"><meta property="og:image" content="https://www.cxlsn.cn/"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="第 1 章 走近 Java"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 1 章 走近 Java | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link active" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第一部分 走近 Java</span><!----></p><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 1 章 走近 Java"><!---->第 1 章 走近 Java<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-1-概述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 概述"><!---->1.1 概述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-2-java-技术体系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 Java 技术体系"><!---->1.2 Java 技术体系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-3-java-发展史" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 Java 发展史"><!---->1.3 Java 发展史<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-java-虚拟机家族" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 Java 虚拟机家族"><!---->1.4 Java 虚拟机家族<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-1-虚拟机始祖-sun-classic-exact-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.1 虚拟机始祖：Sun Classic / Exact VM"><!---->1.4.1 虚拟机始祖：Sun Classic / Exact VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-2-武林盟主-hotspot-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.2 武林盟主：HotSpot VM"><!---->1.4.2 武林盟主：HotSpot VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-3-小家碧玉-mobile-embedded-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.3 小家碧玉：Mobile / Embedded VM"><!---->1.4.3 小家碧玉：Mobile / Embedded VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-4-天下第二-bea-jrockit-ibm-j9-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.4 天下第二：BEA JRockit / IBM J9 VM"><!---->1.4.4 天下第二：BEA JRockit / IBM J9 VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-5-软硬合璧-bea-liquid-vm-azul-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.5 软硬合璧：BEA Liquid VM / Azul VM"><!---->1.4.5 软硬合璧：BEA Liquid VM / Azul VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-6-挑战者-apache-harmony-google-android-dalvik-vm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.6 挑战者：Apache Harmony / Google Android Dalvik VM"><!---->1.4.6 挑战者：Apache Harmony / Google Android Dalvik VM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-7-没有成功-但并非失败-microsoft-jvm-及其他" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.7 没有成功，但并非失败：Microsoft JVM 及其他"><!---->1.4.7 没有成功，但并非失败：Microsoft JVM 及其他<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-8-百家争鸣" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.8 百家争鸣"><!---->1.4.8 百家争鸣<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-展望-java-技术的未来" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 展望 Java 技术的未来"><!---->1.5 展望 Java 技术的未来<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-1-无语言倾向" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.1 无语言倾向"><!---->1.5.1 无语言倾向<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-2-新一代即时编译器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.2 新一代即时编译器"><!---->1.5.2 新一代即时编译器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-3-向-native-迈进" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.3 向 Native 迈进"><!---->1.5.3 向 Native 迈进<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-4-灵活的胖子" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.4 灵活的胖子"><!---->1.5.4 灵活的胖子<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-5-语言语法持续增强" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.5 语言语法持续增强"><!---->1.5.5 语言语法持续增强<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-实战-自己编译-jdk" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6 实战：自己编译 JDK"><!---->1.6 实战：自己编译 JDK<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-1-获取源码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.1 获取源码"><!---->1.6.1 获取源码<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-2-系统需求" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.2 系统需求"><!---->1.6.2 系统需求<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-3-构建编译环境" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.3 构建编译环境"><!---->1.6.3 构建编译环境<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-4-进行编译" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.4 进行编译"><!---->1.6.4 进行编译<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-5-在-ide-工具中进行源码调试" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.5 在 IDE 工具中进行源码调试"><!---->1.6.5 在 IDE 工具中进行源码调试<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-7-本章小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7 本章小结"><!---->1.7 本章小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 自动内存管理</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC2%E7%AB%A0Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 Java 内存区域与内存溢出异常"><!---->第 2 章 Java 内存区域与内存溢出异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC3%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 垃圾收集器与内存分配策略"><!---->第 3 章 垃圾收集器与内存分配策略<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC4%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 虚拟机性能监控、故障处理工具"><!---->第 4 章 虚拟机性能监控、故障处理工具<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC5%E7%AB%A0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 调优案例分析与实战"><!---->第 5 章 调优案例分析与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第三部分 虚拟机执行子系统</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC6%E7%AB%A0%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 类文件结构"><!---->第 6 章 类文件结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC7%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 虚拟机类加载机制"><!---->第 7 章 虚拟机类加载机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC8%E7%AB%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 虚拟机字节码执行引擎"><!---->第 8 章 虚拟机字节码执行引擎<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC9%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 类加载及执行子系统的案例与实战"><!---->第 9 章 类加载及执行子系统的案例与实战<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 程序编译与代码优化</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC10%E7%AB%A0%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 前端编译与优化"><!---->第 10 章 前端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC11%E7%AB%A0%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 后端编译与优化"><!---->第 11 章 后端编译与优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第五部分 高效并发</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC12%E7%AB%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 Java 内存模型与线程"><!---->第 12 章 Java 内存模型与线程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC13%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 线程安全与锁优化"><!---->第 13 章 线程安全与锁优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 1 章 走近 Java</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年8月7日</span><meta property="datePublished" content="2022-08-07T15:02:14.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 95 分钟</span><meta property="timeRequired" content="PT95M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年8月7日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 28641 字</span><meta property="wordCount" content="28641"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-1-概述" class="router-link-active router-link-exact-active toc-link level2">1.1 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-2-java-技术体系" class="router-link-active router-link-exact-active toc-link level2">1.2 Java 技术体系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-3-java-发展史" class="router-link-active router-link-exact-active toc-link level2">1.3 Java 发展史</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-java-虚拟机家族" class="router-link-active router-link-exact-active toc-link level2">1.4 Java 虚拟机家族</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-1-虚拟机始祖-sun-classic-exact-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.1 虚拟机始祖：Sun Classic / Exact VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-2-武林盟主-hotspot-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.2 武林盟主：HotSpot VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-3-小家碧玉-mobile-embedded-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.3 小家碧玉：Mobile / Embedded VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-4-天下第二-bea-jrockit-ibm-j9-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.4 天下第二：BEA JRockit / IBM J9 VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-5-软硬合璧-bea-liquid-vm-azul-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.5 软硬合璧：BEA Liquid VM / Azul VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-6-挑战者-apache-harmony-google-android-dalvik-vm" class="router-link-active router-link-exact-active toc-link level3">1.4.6 挑战者：Apache Harmony / Google Android Dalvik VM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-7-没有成功-但并非失败-microsoft-jvm-及其他" class="router-link-active router-link-exact-active toc-link level3">1.4.7 没有成功，但并非失败：Microsoft JVM 及其他</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-4-8-百家争鸣" class="router-link-active router-link-exact-active toc-link level3">1.4.8 百家争鸣</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-展望-java-技术的未来" class="router-link-active router-link-exact-active toc-link level2">1.5 展望 Java 技术的未来</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-1-无语言倾向" class="router-link-active router-link-exact-active toc-link level3">1.5.1 无语言倾向</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-2-新一代即时编译器" class="router-link-active router-link-exact-active toc-link level3">1.5.2 新一代即时编译器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-3-向-native-迈进" class="router-link-active router-link-exact-active toc-link level3">1.5.3 向 Native 迈进</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-4-灵活的胖子" class="router-link-active router-link-exact-active toc-link level3">1.5.4 灵活的胖子</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-5-5-语言语法持续增强" class="router-link-active router-link-exact-active toc-link level3">1.5.5 语言语法持续增强</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-实战-自己编译-jdk" class="router-link-active router-link-exact-active toc-link level2">1.6 实战：自己编译 JDK</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-1-获取源码" class="router-link-active router-link-exact-active toc-link level3">1.6.1 获取源码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-2-系统需求" class="router-link-active router-link-exact-active toc-link level3">1.6.2 系统需求</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-3-构建编译环境" class="router-link-active router-link-exact-active toc-link level3">1.6.3 构建编译环境</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-4-进行编译" class="router-link-active router-link-exact-active toc-link level3">1.6.4 进行编译</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-6-5-在-ide-工具中进行源码调试" class="router-link-active router-link-exact-active toc-link level3">1.6.5 在 IDE 工具中进行源码调试</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E8%BF%91Java.html#_1-7-本章小结" class="router-link-active router-link-exact-active toc-link level2">1.7 本章小结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-1-章-走近-java" tabindex="-1"><a class="header-anchor" href="#第-1-章-走近-java" aria-hidden="true">#</a> 第 1 章 走近 Java</h1><p>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p><h2 id="_1-1-概述" tabindex="-1"><a class="header-anchor" href="#_1-1-概述" aria-hidden="true">#</a> 1.1 概述</h2><p>Java 不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等多种场合，如图1-1 所示。时至今日，Java 技术体系已经吸引了 600 多万软件开发者，这是全球最大的软件开发团队。使用 Java 的设备已经超过了 45 亿，其中包括 8 亿多台个人计算机、21 亿部移动电话及其他手持设备、35 亿个智能卡，以及大量机顶盒、导航系统和其他设备<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。</p><p><img src="/assets/图1-1.83bf498d.png" alt="图1-1" loading="lazy"></p><p>图1-1 Java 技术的广泛应用</p><p>Java 能获得如此广泛的认可，除了它拥有一门结构严谨、面向对象的编程语言之外，还有许多不可忽视的优点：它摆脱了硬件平台的束缚，实现了 “一次编写，到处运行” 的理想；它提供了一种相对安全的内存管理和访问机制，避免了绝大部分内存泄漏和指针越界问题；它实现了热点代码检测和运行时编译及优化，这使得 Java 应用能随着运行时间的增长而获得更高的性能；它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能……Java 带来的这些好处，让软件的开发效率得到了极大的提升。作为一名 Java 程序员，在编写程序时除了尽情发挥 Java 的各种优势外，还会情不自禁地想去了解和思考一下 Java 技术体系中这些优秀的技术特性是如何出现及怎样实现的。认识这些技术运行的本质，是自己思考 “程序这样写好不好” 的必要基础与前提。当我们在使用一门技术时，不再依赖书本和他人就能得到这些问题的答案，那才算升华到了 “不惑” 的境界。</p><p>本书将会与读者一起分析 Java 技术体系中那些最基础、最重要特性的实现原理。在本章中，笔者将重点讲述 Java 技术体系所囊括的内容，以及 Java 的历史、现状和未来的发展趋势。</p><h2 id="_1-2-java-技术体系" tabindex="-1"><a class="header-anchor" href="#_1-2-java-技术体系" aria-hidden="true">#</a> 1.2 Java 技术体系</h2><p>从广义上讲，Kotlin、Clojure、JRuby、Groovy 等运行于 Java 虚拟机上的编程语言及其相关的程序都属于 Java 技术体系中的一员。如果仅从传统意义上来看，JCP 官方<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>所定义的 Java 技术体系包括了以下几个组成部分：</p><ul><li><p>Java 程序设计语言</p></li><li><p>各种硬件平台上的 Java 虚拟机实现</p></li><li><p>Class 文件格式</p></li><li><p>Java 类库 API</p></li><li><p>来自商业机构和开源社区的第三方 Java 类库</p></li></ul><p>我们可以把 Java 程序设计语言、Java 虚拟机、Java 类库这三部分统称为 JDK（Java Development Kit），JDK 是用于支持 Java 程序开发的最小环境，本书中为行文方便，在不产生歧义的地方常以 JDK 来代指整个 Java 技术体系<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>。可以把 Java 类库 API 中的 Java SE API 子集<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>和 Java 虚拟机这两部分统称为 JRE（Java Runtime Environment），JRE 是支持 Java 程序运行的标准环境。图1-2 展示了 Java 技术体系所包括的内容，以及 JDK 和 JRE 所涵盖的范围。</p><p><img src="/assets/图1-2.6ed334c3.png" alt="图1-2" loading="lazy"></p><p>图1-2 Java 技术体系所包括的内容</p><p>以上是根据 Java 各个组成部分的功能来进行划分，如果按照技术所服务的领域来划分，或者按照技术关注的重点业务来划分的话，那 Java 技术体系可以分为以下四条主要的产品线：</p><ul><li><p>Java Card：支持 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。</p></li><li><p>Java ME（Micro Edition）：支持 Java 程序运行在移动终端（手机、PDA）上的平台，对 Java API 有所精简，并加入了移动终端的针对性支持，这条产品线在 JDK 6 以前被称为 J2ME。有一点读者请勿混淆，现在在智能手机上非常流行的、主要使用 Java 语言开发程序的 Android 并不属于 Java ME。</p></li><li><p>Java SE（Standard Edition）：支持面向桌面级应用（如 Windows 下的应用程序）的 Java 平台，提供了完整的 Java 核心 API，这条产品线在 JDK 6 以前被称为 J2SE。</p></li><li><p>Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如 ERP、MIS、CRM 应用）的 Java 平台，除了提供 Java SE API 外，还对其做了大量有针对性的扩充<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>，并提供了相关的部署支持，这条产品线在 JDK 6 以前被称为 J2EE，在 JDK 10 以后被 Oracle 放弃，捐献给 Eclipse 基金会管理，此后被称为 Jakarta EE。</p></li></ul><h2 id="_1-3-java-发展史" tabindex="-1"><a class="header-anchor" href="#_1-3-java-发展史" aria-hidden="true">#</a> 1.3 Java 发展史</h2><p>从 Java 的第一个版本诞生到现在已经有二十余年的时间，白驹过隙，沧海桑田，转眼已过了四分之一个世纪，在图1-3 所示的时间线里，我们看到 JDK 的版本已经发展到了 JDK 13。这二十多年里诞生过无数与 Java 相关的产品、技术与标准。现在让我们走入时间隧道，从孕育 Java 语言的时代开始，再来回顾一下 Java 的发展轨迹和历史变迁。</p><p><img src="/assets/图1-3.9b882c4a.png" alt="图1-3" loading="lazy"></p><p>图1-3 Java 技术发展的时间线</p><p>1991 年 4 月，由 James Gosling 博士领导的绿色计划（Green Project）开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品（如机顶盒、冰箱、收音机等）上运行的程序架构。这个计划的产品就是 Java 语言的前身：Oak（得名于 James Gosling 办公室外的一棵橡树）。Oak 当时在消费品市场上并不算成功，但随着 1995 年互联网潮流的兴起，Oak 迅速找到了最适合自己发展的市场定位并蜕变成为 Java 语言。</p><p>1995 年 5 月 23 日，Oak 语言改名为 Java，并且在 SunWorld 大会上正式发布 Java 1.0 版本。Java 语言第一次提出了 &quot;Write Once, Run Anywhere&quot; 的口号。</p><p>1996 年 1 月 23 日，JDK 1.0 发布，Java 语言有了第一个正式版本的运行环境。JDK 1.0 提供了一个纯解释执行的 Java 虚拟机实现（Sun Classic VM）。JDK 1.0 版本的代表技术包括：Java 虚拟机、Applet、AWT 等。</p><p>1996 年 4 月，十个最主要的操作系统和计算机供应商声明将在其产品中嵌入 Java 技术。同年 9 月，已有大约 8.3 万个网页应用了 Java 技术来制作。在 1996 年 5 月底，Sun 于美国旧金山举行了首届 JavaOne 大会，从此 JavaOne 成为全世界数百万 Java 语言开发者每年一度的技术盛会。</p><p>1997 年 2 月 19 日，Sun 公司发布了 JDK 1.1，Java 里许多最基础的技术支撑点（如 JDBC 等）都是在 JDK 1.1 版本中提出的，JDK 1.1 版的技术代表有：JAR 文件格式、JDBC、JavaBeans、RMI 等。Java 语言的语法也有了一定的增强，如内部类（Inner Class）和反射（Reflection）都是在这时候出现的。</p><p>直到 1999 年 4 月 8 日，JDK 1.1 一共发布了 1.1.0 至 1.1.8 这 9 个版本。从 1.1.4 以后，每个 JDK 版本都有一个属于自己的名字（工程代号），分别为：JDK 1.1.4-Sparkler（宝石）、JDK 1.1.5-Pumpkin（南瓜）、JDK 1.1.6-Abigail（阿比盖尔，女子名）、JDK 1.1.7-Brutus（布鲁图，古罗马政治家和将军）和 JDK 1.1.8-Chelsea（切尔西，城市名）。</p><p>1998 年 12 月 4 日，JDK 迎来了一个里程碑式的重要版本：工程代号为 Playground（竞技场）的 JDK 1.2，Sun 在这个版本中把 Java 技术体系拆分为三个方向，分别是面向桌面应用开发的 J2SE（Java 2 Platform, Standard Edition）、面向企业级开发的 J2EE（Java 2 Platform, Enterprise Edition）和面向手机等移动终端开发的 J2ME（Java 2 Platform, Micro Edition）。在这个版本中出现的代表性技术非常多，如 EJB、Java Plug-in、Java IDL、Swing 等，并且这个版本中 Java 虚拟机第一次内置了 JIT（Just In Time）即时编译器（JDK 1.2 中曾并存过三个虚拟机，Classic VM、HotSpot VM 和 Exact VM，其中 Exact VM 只在 Solaris 平台出现过；后面两款虚拟机都是内置了 JIT 即时编译器的，而之前版本所带的 Classic VM 只能以外挂的形式使用即时编译器）。在语言和 API 层面上，Java 添加了 strictfp 关键字，Java 类库添加了现在 Java 编码之中极为常用的一系列 Collections 集合类等。在 1999 年 3 月和 7 月，分别有 JDK 1.2.1 和 JDK 1.2.2 两个小升级版本发布。</p><p>1999 年 4 月 27 日，HotSpot 虚拟机诞生。HotSpot 最初由一家名为 &quot;Longview Technologies&quot; 的小公司开发，由于 HotSpot 的优异表现，这家公司在 1997 年被 Sun 公司收购。HotSpot 虚拟机刚发布时是作为 JDK 1.2 的附加程序提供的，后来它成为 JDK 1.3 及之后所有 JDK 版本的默认 Java 虚拟机。</p><p>2000 年 5 月 8 日，工程代号为 Kestrel（美洲红隼）的 JDK 1.3 发布。相对于 JDK 1.2，JDK 1.3 的改进主要体现在 Java 类库上（如数学运算和新的 Timer API 等），JNDI 服务从 JDK 1.3 开始被作为一项平台级服务提供（以前 JNDI 仅仅是一项扩展服务），使用 CORBA IIOP 来实现 RMI 的通信协议，等等。这个版本还对 Java 2D 做了很多改进，提供了大量新的 Java 2D API，并且新添加了 JavaSound 类库。JDK 1.3 有 1 个修正版本 JDK 1.3.1，工程代号为 Ladybird（瓢虫），于 2001 年 5 月 17 日发布。</p><p>自从 JDK 1.3 开始，Sun 公司维持着稳定的研发节奏：大约每隔两年发布一个 JDK 的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程代号。</p><p>2002 年 2 月 13 日，JDK 1.4 发布，工程代号为 Merlin（灰背隼）。JDK 1.4 是标志着 Java 真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM 等著名公司都有参与功能规划，甚至实现自己独立发行的 JDK 1.4。哪怕是在近二十年后的今天，仍然有一些主流应用能直接运行在 JDK 1.4 之上，或者继续发布能运行在 1.4 上的版本。JDK 1.4 同样带来了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML 解析器和 XSLT 转换器，等等。JDK 1.4 有两个后续修正版：2002 年 9 月 16 日发布的工程代号为 Grasshopper（蚱蜢）的 JDK 1.4.1 与 2003 年 6 月 26 日发布的工程代号为 Mantis（螳螂）的 JDK 1.4.2。</p><p>2002年前后还发生了一件与Java没有直接关系，但事实上对Java的发展进程影响很大的事件，<a href="http://xn--xft04fy8g41sjm3a.NET" target="_blank" rel="noopener noreferrer">就是微软的.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> Framework发布。这个无论是技术实现还是目标用户上都与Java有很多相近之处的技术平台给Java带来了很多讨论、比较与竞争，.NET平台和Java平台之间声势浩大的孰优孰劣的论战到今天为止都仍然没有完全平息。</p><p>2004 年 9 月 30 日，JDK 5 发布，工程代号为 Tiger（老虎）。Sun 公司从这个版本开始放弃了谦逊的 &quot;JDK 1.x&quot; 的命名方式，将产品版本号修改成了 &quot;JDK x&quot;<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>。从 JDK 1.2 以来，Java 在语法层面上的变动一直很小，而 JDK 5 在 Java 语法易用性上做出了非常大的改进。如：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach 循环）等语法特性都是在 JDK 5 中加入的。在虚拟机和 API 层面上，这个版本改进了 Java 的内存模型（Java Memory Model，JMM）、提供了 java.util.concurrent 并发包等。另外，JDK 5 是官方声明可以支持 Windows 9x 操作系统的最后一个 JDK 版本。</p><p>2006 年 12 月 11 日，JDK 6 发布，工程代号为 Mustang（野马）。在这个版本中，Sun 公司终结了从 JDK 1.2 开始已经有八年历史的 J2EE、J2SE、J2ME 的产品线命名方式，启用 Java EE 6、Java SE 6、Java ME 6 的新命名来代替。JDK 6 的改进包括：提供初步的动态语言支持（通过内置 Mozilla JavaScript Rhino 引擎实现）、提供编译期注解处理器和微型 HTTP 服务器 API，等等。同时，这个版本对 Java 虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的实现都有相当多的改动。</p><p>在 2006 年 11 月 13 日的 JavaOne 大会上，Sun 公司宣布计划要把 Java 开源，在随后的一年多时间内，它陆续地将 JDK 的各个部分在 GPL v2（GNU General Public License v2）协议下公开了源码，并建立了 OpenJDK 组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有权不属于 Sun 公司，Sun 本身也无权进行开源处理）外，OpenJDK 几乎拥有了当时 SunJDK 7 的全部代码，OpenJDK 的质量主管曾经表示在 JDK 7 中，SunJDK 和 OpenJDK 除了代码文件头的版权注释之外，代码几乎是完全一样的，所以 OpenJDK 7 与 SunJDK 7 本质上就是同一套代码库出来的产品。</p><p>JDK 6 发布以后，由于代码复杂性的增加、Java 开源、开发 JavaFX、世界经济危机及 Oracle 对 Sun 的收购案等原因，Sun 公司在发展 Java 以外的事情上耗费了太多精力和资源，JDK 的更新没有能够继续维持两年发布一个主版本的研发速度，这导致了 JDK 6 的生命周期异常的长，一共发布了 211 个更新升级补丁，最后的版本为 Java SE 6 Update 211，于 2018 年 10 月 18 日发布。</p><p>2009 年 2 月 19 日，工程代号为 Dolphin（海豚）的 JDK 7 完成了其第一个里程碑版本。按照 JDK 7 最初的功能规划，一共会设置十个里程碑。最后一个里程碑版本原计划定于 2010 年 9 月 9 日结束，但由于各种原因，JDK 7 最终无法按计划完成。</p><p>从 JDK 7 最原始的功能清单来看，它本应是一个包含许多重要改进的 JDK 版本，其中规划的子项目都为 Java 业界翘首以盼，包括：</p><ul><li>Lambda 项目：支持 Lambda 表达式，支持函数式编程。</li><li>Jigsaw 项目：虚拟机层面的模块化支持。</li><li>动态语言支持：Java 是静态语言，为其他运行在 Java 虚拟机上的动态语言提供支持。</li><li>Garbage-First 收集器。</li><li>Coin 项目：Java 语法细节进化。</li></ul><p>令人惋惜的是，在 JDK 7 开发期间，Sun 公司相继在技术竞争和商业竞争中陷入泥潭，公司的股票市值跌至仅有高峰时期的 3%，已无力推动 JDK 7 的研发工作按计划继续进行。为了尽快结束 JDK 7 长期跳票的问题，Oracle 收购 Sun 公司后随即宣布马上实行 “B 计划”，大幅裁剪了 JDK 7 预定目标，以保证 JDK 7 的正式版能够于 2011 年 7 月 28 日准时发布。“B计划” 的主要措施是把不能按时完成的 Lambda 项目、Jigsaw 项目和 Coin 项目的部分改进延迟到 JDK 8 之中。最终，JDK 7 包含的改进有：提供新的 G1 收集器（G1 在发布时依然处于 Experimental 状态，直至 2012 年 4 月的 Update 4 中才正式商用）、加强对非 Java 语言的调用支持（JSR-292，这项特性在到 JDK 11 还有改动）、可并行的类加载架构等。</p><p>Oracle 公司接手了 JDK 开发工作以后，迅速展现出了完全不同于 Sun 时期的、极具商业化的处事风格。面对 Java 中使用最广泛而又一直免费的 Java SE 产品线，Oracle 很快定义了一套新的 Java SE Support<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>产品计划，把 JDK 的更新支持作为一项商业服务。JDK 7 发布的前 80 个更新仍然免费面向所有用户提供，但后续的其他更新包，用户<sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup>只能从 “将 Java SE 升级到 Java SE Support” 与 “将 JDK 7 升级到最新版本” 两个选项里挑一个。JDK 7 计划维护至 2022 年，迄今（面向付费用户）已发布了超过两百个更新补丁，最新版本为 JDK 7 Update 221。</p><p>对于 JDK 7，还有一点值得提起的是，从 JDK 7 Update 4 起，Java SE 的核心功能正式开始为 Mac OS X 操作系统提供支持，并在 JDK 7 Update 6 中达到所有功能与 Mac OS X 完全兼容的程度；同时，JDK 7 Update 6 还对 ARM 指令集架构提供了支持。至此，官方提供的 JDK 可以运行于 Windows（不含 Windows 9x）、Linux、Solaris 和 Mac OS X 操作系统上，支持 ARM、x86、x86-64 和 SPARC 指令集架构，JDK 7 也是可以支持 Windows XP 操作系统的最后一个版本<sup class="footnote-ref"><a href="#footnote9">[9]</a><a class="footnote-anchor" id="footnote-ref9"></a></sup>。</p><p>2009 年 4 月 20 日，Oracle 宣布正式以 74 亿美元的价格收购市值曾超过 2000 亿美元的 Sun 公司，传奇的 Sun Microsystems 从此落幕成为历史，Java 商标正式划归 Oracle 所有（Java 语言本身并不属于哪间公司所有，它由 JCP 组织进行管理，尽管在 JCP 中 Sun 及后来的 Oracle 的话语权很大）。由于此前 Oracle 已经收购了另外一家大型的中间件企业 BEA 公司，当完成对 Sun 公司的收购之后，Oracle 分别从 BEA 和 Sun 手中取得了世界三大商用虚拟机的其中两个：JRockit 和 HotSpot。当时 Oracle 宣布要在未来一至两年的时间内，把这两个优秀的 Java 虚拟机合二为一<sup class="footnote-ref"><a href="#footnote10">[10]</a><a class="footnote-anchor" id="footnote-ref10"></a></sup>。两者合并的结果只能说差强人意，JRockit 的监控工具 Java Mission Control 被移植到了 HotSpot，作为收费功能提供给购买了 Java SE Advanced 产品计划的用户，其他功能由于两者架构的差异性明显，HotSpot 能够直接借鉴融合的功能寥寥无几<sup class="footnote-ref"><a href="#footnote11">[11]</a><a class="footnote-anchor" id="footnote-ref11"></a></sup>。</p><p>JDK 8 的第一个正式版本原定于 2013 年 9 月发布，最终还是跳票到了 2014 年 3 月 18 日，尽管仍然是没有赶上正点，但比起 JDK 7 那种以年作为计时单位、直接把公司跳崩的研发状况已是大有改善。为了保证日后 JDK 研发能更顺利地进行，从 JDK 8 开始，Oracle 启用 JEP（JDK Enhancement Proposals）来定义和管理纳入新版 JDK 发布范围的功能特性。JDK 8 提供了那些曾在 JDK 7 中规划过，但最终未能在 JDK 7 中完成的功能，主要包括：</p><ul><li>JEP 126：对 Lambda 表达式的支持，这让 Java 语言拥有了流畅的函数式表达能力。</li><li>JEP 104：内置 Nashorn JavaScript 引擎的支持。</li><li>JEP 150：新的时间、日期 API。</li><li>JEP 122：彻底移除 HotSpot 的永久代。</li><li>……</li></ul><p>“B计划” 中原本说好的会在 JDK 8 提供的 Jigsaw 模块化功能再次被延期到了 JDK 9，不得不说，即使放到整个 Java 发展史里看，Jigsaw 都能算是天字第一号的大坑。Java 的模块化系统本身面临的技术挑战就很艰巨，从微软的 DLL 技术开始，到 Java 自己的 JAR，再到 .NET 的 Assembly，工程庞大起来都无一例外会陷入 “模块地狱”<sup class="footnote-ref"><a href="#footnote12">[12]</a><a class="footnote-anchor" id="footnote-ref12"></a></sup>的困境之中，而 Jigsaw 面临的更大困难是厂商之间以标准话语权为目的，以技术为 “找茬” 手段的激烈竞争。</p><p>原本 JDK 9 是计划在 2016 年发布的，但在 2016 年伊始，Oracle 就宣布 JDK 9 肯定要延期至 2017 年，后来又连续经过了两次短时间的跳票，最终到 2017 年 9 月 21 日才得以艰难面世。后两次跳票的原因是以 IBM 和 RedHat 为首<sup class="footnote-ref"><a href="#footnote13">[13]</a><a class="footnote-anchor" id="footnote-ref13"></a></sup>的十三家企业在 JCP 执行委员会上联手否决了 Oracle 提出的 Jigsaw 作为 Java 模块化规范进入 JDK 9 发布范围的提案<sup class="footnote-ref"><a href="#footnote14">[14]</a><a class="footnote-anchor" id="footnote-ref14"></a></sup>。凭良心说，Java 确实有模块化的刚需，不论是 JDK 自身（例如拆分出 Java SE Embedded 这样规模较小的产品）抑或是 Java 应用都需要用到模块化。这方面 IBM 本身就是各大 Java 发行厂商中做得最好的，它不仅让自家的 JDK 实现了高度模块化，还带头成立了 OSGi 联盟，制订了 Java 框架层面模块化的事实标准，所以它当然会想把 OSGi 推到 Java 规范里去争个 “名份”，而不是被 Jigsaw 革掉 “性命”。可是 Oracle 对此没有丝毫退让，不惜向 JCP 发去公开信<sup class="footnote-ref"><a href="#footnote15">[15]</a><a class="footnote-anchor" id="footnote-ref15"></a></sup>，直言如果提案最后无法通过，那 Oracle 将摒弃 JSR 专家组，独立发展带 Jigsaw 的 Java 版本，Java 顿时面临如 Python 2 与 Python 3 那般分裂的危机。</p><p>不论如何，经过前后六轮投票，经历桌上桌下的斗争与妥协，Java 没有分裂，JDK 9 总算是带着 Jigsaw 最终发布了，除了 Jigsaw 外，JDK 9 还增强了若干工具（JS Shell、JLink、JHSDB 等），整顿了 HotSpot 各个模块各自为战的日志系统，支持 HTTP 2 客户单 API 等 91 个 JEP。</p><p>JDK 9 发布后，Oracle 随即宣布 Java 将会以持续交付的形式和更加敏捷的研发节奏向前推进，以后 JDK 将会在每年的 3 月和 9 月各发布一个大版本<sup class="footnote-ref"><a href="#footnote16">[16]</a><a class="footnote-anchor" id="footnote-ref16"></a></sup>，目的就是为避免众多功能特性被集中捆绑到一个 JDK 版本上而引发交付风险。这次改革确实从根源上解决了跳票问题，但也为 Java 的用户和发行商带来了颇大的压力，不仅程序员感慨 “Java 新版本还没开始用就已经过时了”，Oracle 自己对着一堆 JDK 版本分支也在挠头，不知道该如何维护更新，该如何提供技术支持。Oracle 的解决方案是顺理成章地终结掉 “每个 JDK 版本最少维护三年” 的优良传统，从此以后，每六个 JDK 大版本中才会被划出一个长期支持（Long Term Support，LTS）版，只有 LTS 版的 JDK 能够获得为期三年的支持和更新，普通版的 JDK 就只有短短六个月的生命周期。JDK 8 和 JDK 11 会是 LTS 版，再下一个就到 2021 年发布的 JDK 17 了。</p><p>2018 年 3 月 20 日，JDK 10 如期发布，这版本的主要研发目标是内部重构，诸如统一源仓库、统一垃圾收集器接口、统一即时编译器接口（JVMCI 在 JDK 9 已经有了，这里是引入新的 Graal 即时编译器）等，这些都将会是对未来 Java 发展大有裨益的改进，但对普通用户来说 JDK 10 的新特性就显得乏善可陈，毕竟它只包含了 12 个 JEP，而且其中只有本地类型推断这一个编码端可见的改进。尽管 JDK 10 可见的改进有限，但 2018 这一年 Java 圈丝毫不缺乏谈资，相继发生了几件与 “金钱” 相关的历史性大事件。</p><p>首先是 2018 年 3 月 27 日，Android 的 Java 侵权案有了最终判决，法庭裁定 Google 赔偿 Oracle 合计 88 亿美元，要知道 2009 年 Oracle 收购 Sun 也就只花了 74 亿，收购完成后随即就用 Sun 的专利把 Google 告上了法庭，经过 Oracle 法务部的几轮神操作，一场官司的赔偿让收购 Sun 公司等同免费。对此事 Java 技术圈多数吃瓜群众是站在 Google 这边的，认为 Oracle 这样做是自绝 Java 的发展前景，毕竟当年 Android 刚刚起步的时候可是 Sun 向 Google 抛去的橄榄枝，Android 的流行也巩固了 Java “第一编程语言” 的行业地位。摒弃对企业的好恶情感，就事论事，Google 采用 Java 的语法和 API 类库，开发出来的程序却不能运行在其他 Java 虚拟机之上，这事情无论怎样都是有违 Java 技术的精神原旨的，也肯定违反了 Java 的使用协议<sup class="footnote-ref"><a href="#footnote17">[17]</a><a class="footnote-anchor" id="footnote-ref17"></a></sup>。如果说 Oracle 控告 Google “不厚道”，那当年微软用 J++ 做了同样的事情（借用语法和 API，但程序不兼容标准 Java 虚拟机），被 Sun 告到登报道歉，一边赔款一边割地，声明放弃 J++ 语言和 Windows 平台上的内置虚拟机，这又该找谁说理去？</p><p>按常理说 Java 刚给 Oracle 赚了 88 亿美金，该颇为受宠才对，可 Oracle 是典型只谈利益不讲情怀的公司，InfoWorld 披露的一封 Oracle 高管邮件表明<sup class="footnote-ref"><a href="#footnote18">[18]</a><a class="footnote-anchor" id="footnote-ref18"></a></sup>，Java 体系中被认为无法盈利也没有太多战略前景的部分会逐渐被 “按计划报废”（Planned Obsolescence）。这事的第一刀落下是在 2018 年 3 月，Oracle 正式宣告 Java EE 成为历史名词。虽然 Java SE、Java EE 和 Java ME 三条产品线里确实只有 Java SE 称得上成功，但 Java EE 毕竟无比辉煌过，现在其中还持有着 JDBC、JMS、Servlet 等使用极为广泛的基础组件，然而 Oracle 仍选择把它 “扫地出门”，所有权直接赠送给 Eclipse 基金会，唯一的条件是以后不准再使用 &quot;Java&quot; 这个商标<sup class="footnote-ref"><a href="#footnote19">[19]</a><a class="footnote-anchor" id="footnote-ref19"></a></sup>，所以取而代之的将是 Jakarta EE。</p><p>2018 年 10 月，JavaOne 2018 在旧金山举行，此前没有人想过这会是最后一届 JavaOne 大会，这个在 1996 年伴随着 Java 一同诞生、成长的开发者年度盛会，竟是 Oracle 下一个裁撤的对象<sup class="footnote-ref"><a href="#footnote20">[20]</a><a class="footnote-anchor" id="footnote-ref20"></a></sup>，此外还有 Java Mission Control 的开发团队，也在 2018 年 6 月被 Oracle 解散。</p><p>2018 年 9 月 25 日，JDK 11 发布，这是一个 LTS 版本的 JDK，包含 17 个 JEP，其中有 ZGC 这样的革命性的垃圾收集器出现，也有把 JDK 10 中的类型推断加入 Lambda 语法这种可见的改进，但都比不过它发布时爆出来的谣言轰动：“Java 要开始收费啦！”</p><p>随着 JDK 11 发布，Oracle 同时调整了 JDK 的授权许可证，里面包含了好几个动作。首先，Oracle 从 JDK 11 起把以前的商业特性<sup class="footnote-ref"><a href="#footnote21">[21]</a><a class="footnote-anchor" id="footnote-ref21"></a></sup>全部开源给 OpenJDK，这样 OpenJDK 11 和 OracleJDK 11 的代码和功能，在本质上就是完全相同的（官方原文是 Essentially Identical）<sup class="footnote-ref"><a href="#footnote22">[22]</a><a class="footnote-anchor" id="footnote-ref22"></a></sup>。然后，Oracle 宣布以后将会同时发行两个 JDK：一个是以 GPLv2 + CE 协议下由 Oracle 发行的 OpenJDK（本书后面章节称其为 Oracle OpenJDK），另一个是在新的 OTN 协议下发行的传统的 OracleJDK，这两个 JDK 共享绝大部分源码，在功能上是几乎一样的<sup class="footnote-ref"><a href="#footnote23">[23]</a><a class="footnote-anchor" id="footnote-ref23"></a></sup>，核心差异是前者可以免费在开发、测试或生产环境中使用，但是只有半年时间的更新支持；后者个人依然可以免费使用，但若在生产环境中商用就必须付费，可以有三年时间的更新支持。如果说由此能得出 “Java 要收费” 的结论，那是纯属标题党，最多只能说 Oracle 在迫使商业用户要么不断升级 JDK 的版本，要么就去购买商业支持<sup class="footnote-ref"><a href="#footnote24">[24]</a><a class="footnote-anchor" id="footnote-ref24"></a></sup>。</p><p>2019 年 2 月，在 JDK 12 发布前夕，Oracle 果然如之前宣布那样在六个月之后就放弃了对上一个版本 OpenJDK 的维护，RedHat 同时从 Oracle 手上接过 OpenJDK 8 和 OpenJDK 11 的管理权利和维护职责<sup class="footnote-ref"><a href="#footnote25">[25]</a><a class="footnote-anchor" id="footnote-ref25"></a></sup>。Oracle 不愿意在旧版本上继续耗费资源，而 RedHat 或者说它背后的 IBM 又乐意扩大自己在 Java 社区的影响力，这是一笔双赢的交易。RedHat 代替 Oracle 成为 JDK 历史版本的维护者，应该有利于 Java 的持续稳定，但从技术发展角度来看，这并不能为 Oracle 领导 Java 社区的局面带来根本性的改变，毕竟要添加新的或实验性的功能，仅会针对 Java 的最新版本，而不会在旧版本上动手。</p><p>2019 年 3 月 20 日，JDK 12 发布，只包含 8 个 JEP，其中主要有 Switch 表达式、Java 微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由 RedHat 领导开发的 Shenandoah 垃圾收集器。Shenandoah 作为首个由非 Oracle 开发的垃圾收集器，其目标又与 Oracle 在 JDK 11 中发布的 ZGC 几乎完全一致，两者天生就存在竞争。Oracle 马上用实际行动抵制了这个新收集器，在 JDK 11 发布时才说应尽可能保证 OracleJDK 和 OpenJDK 的兼容一致，转眼就在 OracleJDK 12 里把 Shenandoah 的代码通过条件编译强行剔除掉，使其成为历史上唯一进入了 OpenJDK 发布清单，但在 OracleJDK 中无法使用的功能。</p><p>Oracle 收购 Sun 是 Java 发展历史上一道明显的分界线。在 Sun 掌舵的前十几年里，Java 获得巨大成功，同时也渐渐显露出来语言演进的缓慢与社区决策的老朽；而在 Oracle 主导 Java 后，引起竞争的同时也带来新的活力，Java 发展的速度要显著高于 Sun 时代。Java 的未来是继续向前、再攀高峰，还是由盛转衰、锋芒挫缩，你我拭目以待。</p><p>Java 面临的危机挑战前所未有的艰巨，属于 Java 的未来也从未如此充满想象与可能。</p><h2 id="_1-4-java-虚拟机家族" tabindex="-1"><a class="header-anchor" href="#_1-4-java-虚拟机家族" aria-hidden="true">#</a> 1.4 Java 虚拟机家族</h2><p>上一节我们以 JDK 版本演进过程为线索，回顾了 Java 技术的发展历史，体会过其中企业与技术的成败兴衰，现在，我们将聚焦到本书的主题 “Java 虚拟机”。许多 Java 程序员都会潜意识地把 Java 虚拟机与 OracleJDK 的 HotSpot 虚拟机等同看待，也许还有一些程序员会注意到 BEA JRockit 和 IBM J9 虚拟机，但绝大多数人对 Java 虚拟机的认识就仅限于此了。从 1996 年初 Sun 发布的 JDK 1.0 中包含的 Sun Classic 虚拟机到今天，曾经涌现、湮灭过许多或经典，或优秀，或有特色，或有争议的虚拟机实现，在这一节中，我们仍先把代码与技术放下，一起来回顾 Java 虚拟机家族的发展轨迹和历史变迁。</p><h3 id="_1-4-1-虚拟机始祖-sun-classic-exact-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-1-虚拟机始祖-sun-classic-exact-vm" aria-hidden="true">#</a> 1.4.1 虚拟机始祖：Sun Classic / Exact VM</h3><p>以今天的视角来看，Sun Classic 虚拟机的技术已经相当原始，这款虚拟机的使命也早已终结。但仅凭它 “世界上第一款商用 Java 虚拟机” 的头衔，就足够有令历史记住它的理由。</p><p>1996 年 1 月 23 日，Sun 发布 JDK 1.0，Java 语言首次拥有了商用的正式运行环境，这个 JDK 中所带的虚拟机就是 Classic VM。这款虚拟机只能使用纯解释器方式来执行 Java 代码，如果要使用即时编译器那就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。在 JDK 1.2 及之前，用户用 Classic 虚拟机执行 java -version 命令，将会看到类似下面这行的输出：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>java version &quot;1.2.2&quot;
Classic VM (build JDK-1.2.2-001, green threads, sunwjit)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 &quot;sunwjit&quot;（Sun Workshop JIT）就是 Sun 提供的外挂编译器，其他类似的外挂编译器还有 Symantec JIT 和 shuJIT 等。由于解释器和编译器不能配合工作，这就意味着如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机虽然用了即时编译器输出本地代码，其执行效率也和传统的 C / C++ 程序有很大差距，“Java 语言很慢” 的印象就是在这阶段开始在用户心中树立起来的。</p><p>Sun 的虚拟机团队努力去解决 Classic 虚拟机所面临的各种问题，提升运行效率，在 JDK 1.2 时，曾在 Solaris 平台上发布过一款名为 Exact VM 的虚拟机，它的编译执行系统已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。</p><p>Exact VM 因它使用准确式内存管理（Exact Memory Management，也可以叫 Non-Con-servative / Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个 32bit 的整数 123456，虚拟机将有能力分辨出它到底是一个指向了 123456 的内存地址的引用类型还是一个数值为 123456 的整数，准确分辨出哪些内存是引用类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。由于使用了准确式内存管理，Exact VM 可以抛弃掉以前 Classic VM 基于句柄（Handle）的对象查找方式（原因是垃圾收集后对象将可能会被移动位置，如果地址为 123456 的对象移动到 654321，在没有明确信息表明内存中哪些数据是引用类型的前提下，那虚拟机肯定是不敢把内存中所有为 123456 的值改成 654321 的，所以要使用句柄来保持引用值的稳定），这样每次定位对象都少了一次间接查找的开销，显著提升执行性能。</p><p>虽然 Exact VM 的技术相对 Classic VM 来说先进了许多，但是它的命运显得十分英雄气短，在商业应用上只存在了很短暂的时间就被外部引进的 HotSpot VM 所取代，甚至还没有来得及发布 Windows 和 Linux 平台下的商用版本。而 Classic VM 的生命周期则相对要长不少，它在 JDK 1.2 之前是 JDK 中唯一的虚拟机，在 JDK 1.2 时，它与 HotSpot VM 并存，但默认是使用 Classic VM（用户可用 java -hotspot 参数切换至 HotSpot VM），而在 JDK 1.3 时，HotSpot VM 成为默认虚拟机，它仍作为虚拟机的 “备用选择” 发布（使用 java -classic 参数切换），直到 JDK 1.4 的时候，Classic VM 才完全退出商用虚拟机的历史舞台，与 Exact VM 一起进入了 Sun Labs Research VM 之中。</p><h3 id="_1-4-2-武林盟主-hotspot-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-2-武林盟主-hotspot-vm" aria-hidden="true">#</a> 1.4.2 武林盟主：HotSpot VM</h3><p>相信所有 Java 程序员都听说过 HotSpot 虚拟机，它是 Sun / OracleJDK 和 OpenJDK 中的默认 Java 虚拟机，也是目前使用范围最广的 Java 虚拟机。但不一定所有人都知道的是，这个在今天看起来 “血统纯正” 的虚拟机在最初并非由 Sun 公司所开发，而是由一家名为 &quot;Longview Technologies&quot; 的小公司设计；甚至这个虚拟机最初并非是为 Java 语言而研发的，它来源于 Strongtalk 虚拟机，而这款虚拟机中相当多的技术又是来源于一款为支持 Self 语言实现 “达到 C 语言 50% 以上的执行效率” 的目标而设计的 Self 虚拟机，最终甚至可以追溯到 20 世纪 80 年代中期开发的 Berkeley Smalltalk 上。Sun 公司注意到这款虚拟机在即时编译等多个方面有着优秀的理念和实际成果，在 1997 年收购了 Longview Technologies 公司，从而获得了 HotSpot 虚拟机。</p><p>HotSpot 既继承了 Sun 之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的 HotSpot 指的就是它的热点代码探测技术（这里的描写带有 “历史由胜利者书写” 的味道，其实 HotSpot 与 Exact 虚拟机基本上是同时期的独立产品，HotSpot 出现得还稍早一些，一开始 HotSpot 就是基于准确式内存管理的，而 Exact VM 之中也有与 HotSpot 几乎一样的热点探测技术，为了 Exact VM 和 HotSpot VM 哪个该成为 Sun 主要支持的虚拟机，在 Sun 公司内部还争吵过一场，HotSpot 击败 Exact 并不能算技术上的胜利），HotSpot 虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为<sup class="footnote-ref"><a href="#footnote26">[26]</a><a class="footnote-anchor" id="footnote-ref26"></a></sup>。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更复杂的代码优化技术，输出质量更高的本地代码。</p><p>2006 年，Sun 陆续将 SunJDK 的各个部分在 GPLv2 协议下开放了源码，形成了 OpenJDK 项目，其中当然也包括 HotSpot 虚拟机。HotSpot 从此成为 Sun / OracleJDK 和 OpenJDK 两个实现极度接近的 JDK 项目的共同虚拟机。Oracle 收购 Sun 以后，建立了 HotRockit 项目来把原来 BEA JRockit 中的优秀特性融合到 HotSpot 之中。到了 2014 年的 JDK 8 时期，里面的 HotSpot 就已是两者融合的结果，HotSpot 在这个过程里移除掉永久代，吸收了 JRockit 的 Java Mission Control 监控工具等功能。</p><p>得益于 Sun / OracleJDK 在 Java 应用中的统治地位，HotSpot 理所当然地成为全世界使用最广泛的 Java 虚拟机，是虚拟机家族中毫无争议的 “武林盟主”。</p><h3 id="_1-4-3-小家碧玉-mobile-embedded-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-3-小家碧玉-mobile-embedded-vm" aria-hidden="true">#</a> 1.4.3 小家碧玉：Mobile / Embedded VM</h3><p>Sun / Oracle 公司所研发的虚拟机可不仅包含前面介绍到的服务器、桌面领域的商用虚拟机，面对移动和嵌入式市场，也有专门的 Java 虚拟机产品。</p><p>由于 Java ME 产品线的发展相对 Java SE 来说并不那么成功，所以 Java ME 中的 Java 虚拟机相比 HotSpot 要低调得多。Oracle 公司在 Java ME 这条产品线上的虚拟机名为CDC-HI（C Virtual Machine，CVM）和 CLDC-HI（Monty VM）。其中 CDC / CLDC 全称是 Connected（Limited）Device Configuration，这是一组在 JSR-139 及 JSR-218 规范中进行定义的 Java API 子集，这组规范希望能够在手机、电子书、PDA 等移动设备上建立统一的 Java 编程接口，CDC-HI VM 和 CLDC-HI VM 就是 JSR-139 及 JSR-218 规范的参考实现，后面的 HI 则是 HotSpot Implementation 的缩写，但它们并不是由 HotSpot 直接裁剪而来，只是借鉴过其中一些技术，并没有血缘关系，充其量能叫有所渊源。</p><p>Java ME 中的 Java 虚拟机现在处于比较尴尬的位置，所面临的局面远不如服务器和桌面领域乐观，它最大的一块市场——智能手机已被 Android 和 iOS 二分天下<sup class="footnote-ref"><a href="#footnote27">[27]</a><a class="footnote-anchor" id="footnote-ref27"></a></sup>，现在 CDC 在智能手机上略微有点声音的产品是 Oracle ADF Mobile，原本它提出的卖点是智能手机上的跨平台（&quot;Developing with Java on iOS and Android&quot;），不过用 Java 在 Android 上开发应用还要再安装个 CDC 虚拟机，这事情听着就觉得别扭，有多此一举的嫌疑，在 iOS 上倒确实还有一些人在用。</p><p>而在嵌入式设备上，Java ME Embedded 又面临着自家 Java SE Embedded（eJDK）的直接竞争和侵蚀，主打高端的 CDC-HI 经过多年来的扩充，在核心部分其实已经跟 Java SE 非常接近，能用 Java SE 的地方大家自然就不愿意用 Java ME，所以市场在快速萎缩，Oracle 也基本上砍掉了 CDC-HI 的所有项目，把它们都划归到了 Java SE Embedded 下。Java SE Embedded 里带的 Java 虚拟机当然还是 HotSpot，但这是为了适应嵌入式环境专门定制裁剪的版本，尽可能在支持完整的 Java SE 功能的前提下向着减少内存消耗的方向优化，譬如只留下了客户端编译器（C1），去掉了服务端编译器（C2）；只保留 Serial / Serial Old 垃圾收集器，去掉了其他收集器等。</p><p>面向更低端设备的 CLDC-HI 倒是在智能控制器、传感器等领域还算能维持自己的一片市场，现在也还在继续发展，但前途并不乐观。目前 CLDC 中活得最好的产品反而是原本早该被 CLDC-HI 淘汰的 KVM，国内的老人手机和出口到经济欠发达国家的功能手机（Feature Phone）还在广泛使用这种更加简单、资源消耗也更小的上一代 Java ME 虚拟机。</p><h3 id="_1-4-4-天下第二-bea-jrockit-ibm-j9-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-4-天下第二-bea-jrockit-ibm-j9-vm" aria-hidden="true">#</a> 1.4.4 天下第二：BEA JRockit / IBM J9 VM</h3><p>前面三节介绍的都是由 Sun / Oracle 公司研发的 Java 虚拟机，历史上除了 Sun / Oracle 公司以外，也有其他组织、公司开发过虚拟机的实现。如果说 HotSpot 是天下第一的武林盟主，那曾经与 HotSpot 并称 “三大商业 Java 虚拟机” 的另外两位，毫无疑问就该是天下第二了，它们分别是 BEA System 公司的 JRockit 与 IBM 公司的 IBM J9。</p><p>JRockit 虚拟机曾经号称是 “世界上速度最快的 Java 虚拟机”（广告词，IBM J9 虚拟机也这样宣传过，总体上三大虚拟机的性能是交替上升的），它是 BEA 在 2002 年从 Appeal Virtual Machines 公司收购获得的 Java 虚拟机。BEA 将其发展为一款专门为服务器硬件和服务端应用场景高度优化的虚拟机，由于专注于服务端应用，它可以不太关注于程序启动速度，因此 JRockit 内部不包含解释器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit 的垃圾收集器和 Java Mission Control 故障处理套件等部分的实现，在当时众多的 Java 虚拟机中也处于领先水平。JRockit 随着 BEA 被 Oracle 收购，现已不再继续发展，永远停留在 R28 版本，这是 JDK 6 版 JRockit 的代号。</p><p>IBM J9 虚拟机并不是 IBM 公司唯一的 Java 虚拟机，不过目前 IBM 主力发展无疑就是 J9。J9 这个名字最初只是内部开发代号而已，开始选定的正式名称是 &quot;IBM Technology for Java Virtual Machine&quot;，简称 IT4J，但这个名字太拗口，接受程度远不如 J9。J9 虚拟机最初是由 IBM Ottawa 实验室的一个 SmallTalk 虚拟机项目扩展而来，当时这个虚拟机有一个 Bug 是因为 8KB 常量值定义错误引起，工程师们花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就被称为 K8，后来由其扩展而来、支持 Java 语言的虚拟机就被命名为 J9。与 BEA JRockit 只专注于服务端应用不同，IBM J9 虚拟机的市场定位与 HotSpot 比较接近<sup class="footnote-ref"><a href="#footnote28">[28]</a><a class="footnote-anchor" id="footnote-ref28"></a></sup>，它是一款在设计上全面考虑服务端、桌面应用，再到嵌入式的多用途虚拟机，开发 J9 的目的是作为 IBM 公司各种 Java 产品的执行平台，在和 IBM 产品（如 IBM WebSphere 等）搭配以及在 IBM AIX 和 z/OS 这些平台上部署 Java 应用。</p><p>IBM J9 直至今天仍旧非常活跃，IBM J9 虚拟机的职责分离与模块化做得比 HotSpot 更优秀，由 J9 虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了 IBM OMR 项目，可以在其他语言平台如 Ruby、Python 中快速组装成相应的功能。从 2016 年起，IBM 逐步将 OMR 项目和 J9 虚拟机进行开源，完全开源后便将它们捐献给了 Eclipse 基金会管理，并重新命名为 Eclipse OMR 和 OpenJ9<sup class="footnote-ref"><a href="#footnote29">[29]</a><a class="footnote-anchor" id="footnote-ref29"></a></sup>。如果为了学习虚拟机技术而去阅读源码，更加模块化的 OpenJ9 代码其实是比 HotSpot 更好的选择。如果为了使用 Java 虚拟机时多一种选择，那可以通过 AdoptOpenJDK 来获得采用 OpenJ9 搭配上 OpenJDK 其他类库组成的完整 JDK。</p><p>除 BEA 和 IBM 公司外，其他一些大公司也号称有自己的专属 JDK 和虚拟机，但是它们要么是通过从 Sun / Oracle 公司购买版权的方式获得的（如 HP、SAP 等），要么是基于 OpenJDK 项目改进而来的（如阿里巴巴、Twitter 等），都并非自己独立开发。</p><h3 id="_1-4-5-软硬合璧-bea-liquid-vm-azul-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-5-软硬合璧-bea-liquid-vm-azul-vm" aria-hidden="true">#</a> 1.4.5 软硬合璧：BEA Liquid VM / Azul VM</h3><p>我们平时所提及的 “高性能Java虚拟机” 一般是指 HotSpot、JRockit、J9 这类在通用硬件平台上运行的商用虚拟机，但其实还有一类与特定硬件平台绑定、软硬件配合工作的专有虚拟机，往往能够实现更高的执行性能，或提供某些特殊的功能特性。这类专有虚拟机的代表是 BEA Liquid VM 和 Azul VM。</p><p>Liquid VM 也被称为 JRockit VE（Virtual Edition，VE），它是 BEA 公司开发的可以直接运行在自家 Hypervisor 系统上的 JRockit 虚拟机的虚拟化版本，Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态 / 用户态的切换，这样可以最大限度地发挥硬件的能力，提升 Java 程序的执行性能。随着 JRockit 虚拟机终止开发，Liquid VM 项目也已经停止了。</p><p>Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机，每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 的内存的硬件资源，并提供在巨大内存范围内停顿时间可控的垃圾收集器（即业内赫赫有名的 PGC 和 C4 收集器），为专有硬件优化的线程调度等优秀特性。2010 年起，Azul 公司的重心逐渐开始从硬件转向软件，发布了自己的 Zing 虚拟机，可以在通用 x86 平台上提供接近于 Vega 系统的性能和一致的功能特性。</p><p>随着虚拟机技术的不断发展，Java 虚拟机变得越来越强大的同时也越来越复杂，要推动在专有硬件上的 Java 虚拟机升级发展，难以直接借助开源社区的力量，往往需要耗费更高昂的成本，在商业上的缺陷使得专有虚拟机逐渐没落，Azul Systems 公司最终也放弃了 Vega 产品线，把全部精力投入到 Zing 和 Zulu 产品线中。</p><p>Zing 虚拟机是一个从 HotSpot 某旧版代码分支基础上独立出来重新开发的高性能 Java 虚拟机，它可以运行在通用的 Linux / x86-64 平台上。Azul 公司为它编写了新的垃圾收集器，也修改了 HotSpot 内的许多实现细节，在要求低延迟、快速预热等场景中，Zing VM 都要比 HotSpot 表现得更好。Zing 的 PGC、C4 收集器可以轻易支持 TB 级别的 Java 堆内存，而且保证暂停时间仍然可以维持在不超过 10 毫秒的范围里，HotSpot 要一直到 JDK 11 和 JDK 12 的 ZGC 及 Shenandoah 收集器才达到了相同的目标，而且目前效果仍然远不如 C4。Zing 的 ReadyNow! 功能可以利用之前运行时收集到的性能监控数据，引导虚拟机在启动后快速达到稳定的高性能水平，减少启动后从解释执行到即时编译的等待时间。Zing 自带的 ZVision / ZVRobot 功能可以方便用户监控 Java 虚拟机的运行状态，从找出代码热点到对象分配监控、锁竞争监控等。Zing 能让普通用户无须了解垃圾收集等底层调优，就可以使得 Java 应用享有低延迟、快速预热、易于监控的功能，这是 Zing 的核心价值和卖点，很多 Java 应用都可以通过长期努力在应用、框架层面优化来提升性能，但使用 Zing 的话就可以把精力更多集中在业务方面。</p><h3 id="_1-4-6-挑战者-apache-harmony-google-android-dalvik-vm" tabindex="-1"><a class="header-anchor" href="#_1-4-6-挑战者-apache-harmony-google-android-dalvik-vm" aria-hidden="true">#</a> 1.4.6 挑战者：Apache Harmony / Google Android Dalvik VM</h3><p>这节介绍的 Harmony 虚拟机（准确地说是 Harmony 里的 DRLVM）和 Dalvik 虚拟机只能称作 “虚拟机”，而不能称作 “Java 虚拟机”，但是这两款虚拟机以及背后所代表的技术体系曾经对 Java 世界产生了非常大的影响和挑战，当时甚至有悲观的人认为成熟的 Java 生态系统都有分裂和崩溃的可能。</p><p>Apache Harmony 是一个 Apache 软件基金会旗下以 Apache License 协议开源的实际兼容于 JDK 5 和 JDK 6 的 Java 程序运行平台，它含有自己的虚拟机和 Java 类库 API，用户可以在上面运行 Eclipse、Tomcat、Maven 等常用的 Java 程序。但是，它并没有通过 TCK 认证，所以我们不得不用一长串冗长拗口的语言来介绍它，而不能用一句 “Apache 的 JDK” 或者 “Apache 的 Java 虚拟机” 来直接代指。</p><p>如果一个公司要宣称自己的运行平台 “兼容于 Java 技术体系”，那该运行平台就必须要通过 TCK（Technology Compatibility Kit）的兼容性测试，Apache 基金会曾要求当时的 Sun 公司提供 TCK 的使用授权，但是一直遭到各种理由的拖延和搪塞，直到 Oracle 收购了 Sun 公司之后，双方关系越闹越僵，最终导致 Apache 基金会愤然退出 JCP 组织，这是 Java 社区有史以来最严重的分裂事件之一。</p><p>当 Sun 公司把自家的 JDK 开源形成 OpenJDK 项目之后，Apache Harmony 开源的优势被极大地抵消，以至于连 Harmony 项目的最大参与者 IBM 公司也宣布辞去 Harmony 项目管理主席的职位，转而参与 OpenJDK 的开发。虽然 Harmony 没有真正地被大规模商业运用过，但是它的许多代码（主要是 Java 类库部分的代码）被吸纳进 IBM 的 JDK 7 实现以及 Google Android SDK 之中，尤其是对 Android 的发展起了很大推动作用。</p><p>说到 Android，这个时下最热门的移动数码设备平台在最近十年所取得的成果已经远远超越了 Java ME 在过去二十多年所获得的成果，Android 让 Java 语言真正走进了移动数码设备领域，只是走得并非 Sun 公司原本想象的那一条路。</p><p>Dalvik 虚拟机曾经是 Android 平台的核心组成部分之一，它的名字来源于冰岛一个名为 Dalvik 的小渔村。Dalvik 虚拟机并不是一个 Java 虚拟机，它没有遵循《Java 虚拟机规范》，不能直接执行 Java 的 Class 文件，使用寄存器架构而不是 Java 虚拟机中常见的栈架构。但是它与 Java 却又有着千丝万缕的联系，它执行的 DEX（Dalvik Executable）文件可以通过 Class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用绝大部分的 Java API 等。在 Android 发展的早期，Dalvik 虚拟机随着 Android 的成功迅速流行，在 Android 2.2 中开始提供即时编译器实现，执行性能又有了进一步提高。不过到了 Android 4.4 时代，支持提前编译（Ahead of Time Compilation，AOT）的 ART 虚拟机迅速崛起，在当时性能还不算特别强大的移动设备上，提前编译要比即时编译更容易获得高性能，所以在 Android 5.0 里 ART 就全面代替了 Dalvik 虚拟机。</p><h3 id="_1-4-7-没有成功-但并非失败-microsoft-jvm-及其他" tabindex="-1"><a class="header-anchor" href="#_1-4-7-没有成功-但并非失败-microsoft-jvm-及其他" aria-hidden="true">#</a> 1.4.7 没有成功，但并非失败：Microsoft JVM 及其他</h3><p>在 Java 虚拟机二十几年的发展历程中，除去上面介绍的那些被大规模商业应用过的 Java 虚拟机外，还有许多虚拟机是不为人知地默默沉寂，或者曾经绚丽过但最终夭折湮灭的。我们以其中 Microsoft 公司的 Java 虚拟机为代表来介绍一下。</p><p>在 Java 语言诞生的初期（1996 年 ~ 1998 年，以 JDK1.2 发布之前为分界），它的主要应用之一是在浏览器中运行 Java Applets 程序，微软为了在 Internet Explorer 3 浏览器中支持 Java Applets 应用而开发了自己的 Java 虚拟机，虽然这款虚拟机只有 Windows 平台的版本，“一次编译，到处运行” 根本无从谈起，但却是当时 Windows 系统下性能最好的 Java 虚拟机，它在 1997 年和 1998 年连续获得了《PC Magazine》杂志的 “编辑选择奖”。但是好景不长，在 1997 年 10 月，Sun 公司正式以侵犯商标、不正当竞争等罪名控告微软，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证据之一被呈送法庭。官司的结果是微软向 Sun 公司（最终微软因垄断赔偿给 Sun 公司的总金额高达 10 亿美元）赔偿 2000 万美金，承诺终止其 Java 虚拟机的发展，并逐步在产品中移除 Java 虚拟机相关功能。而最令人感到讽刺的是，到后来在 Windows XP SP3 中 Java 虚拟机被完全抹去的时候，Sun 公司却又到处登报希望微软不要这样做<sup class="footnote-ref"><a href="#footnote30">[30]</a><a class="footnote-anchor" id="footnote-ref30"></a></sup>。Windows XP高级产品经理 Jim Cullinan 称：“我们花费了三年的时间和 Sun 公司打官司，当时他们试图阻止我们在 Windows 中支持 Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。”</p><p>我们试想一下，如果当年 Sun 公司没有起诉微软公司，微软继续保持着对 Java 技术的热情，那 Java 的世界会变得更好还是更坏？.NET 技术是否还会发展起来？</p><h3 id="_1-4-8-百家争鸣" tabindex="-1"><a class="header-anchor" href="#_1-4-8-百家争鸣" aria-hidden="true">#</a> 1.4.8 百家争鸣</h3><p>还有一些 Java 虚拟机天生就注定不会应用在主流领域，或者不是单纯为了用于生产，甚至在设计之初就没有抱着商用的目的，仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现。这些虚拟机对于大多数不从事相关领域开发的 Java 程序员来说可能比较陌生，笔者列举几款较为有影响的：</p><ul><li><p>KVM<sup class="footnote-ref"><a href="#footnote31">[31]</a><a class="footnote-anchor" id="footnote-ref31"></a></sup></p><p>KVM 中的 K 是 &quot;Kilobyte&quot; 的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。在 Android、iOS 等智能手机操作系统出现前曾经在手机平台上得到非常广泛应用。</p></li><li><p>Java Card VM</p><p>JCVM 是 Java 虚拟机很小的一个子集，裁减了许多模块但通常支持绝大多数的常用加密算法。JCVM 必须精简到能放入智能卡、SIM 卡、银行信用卡、借记卡内，负责对 Java Applet 程序进行解释执行。</p></li><li><p>Squawk VM</p><p>Squawk VM 是由 Sun 开发，运行于 Sun SPOT（Sun Small Programmable Object Technology，一种手持的 Wi-Fi 设备），也曾经运用于 Java Card。这是一个 Java 代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是用 Java 语言完成的，仅仅靠 C 语言来编写设备 I/O 和必要的本地代码。</p></li><li><p>JavaInJava</p><p>JavaInJava 是 Sun 公司在 1997 年 ~ 1998 年间所研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以 Java 语言来实现 Java 语言本身的运行环境，既所谓的 “元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）虚拟机。它必须运行在另外一个宿主虚拟机之上，内部没有即时编译器，代码只能以解释模式执行。在上世纪末主流原生的 Java 虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度大家可想而知，不过通过元循环证明一门语言可以自举，是具有它的研究价值的。</p></li><li><p>Maxine VM</p><p>Maxine VM 和上面的 JavaInJava 非常相似，它也是一个几乎全部以 Java 代码实现（只有用于启动 Java 虚拟机的加载器使用 C 语言编写）的元循环 Java 虚拟机。这个项目于 2005 年开始，到现在仍然在发展之中，比起 JavaInJava，Maxine VM 的执行效率就显得靠谱得多，它有先进的即时编译器和垃圾收集器，可在宿主模式或独立模式下执行，其执行效率已经接近 HotSpot 虚拟机 Client 模式的水平。后来有了从 C1X 编译器演进而来的 Graal 编译器的支持，就更加如虎添翼，执行效率有了进一步飞跃。Graal 编译器现在已经是 HotSpot 的默认组件，是未来代替 HotSpot 中服务端编译器的希望。</p></li><li><p>Jikes RVM</p><p>Jikes RVM是 IBM 开发的专门用来研究 Java 虚拟机实现技术的项目。曾用名为 Jalapeño。与 JavaInJava 和 Maxine 一样，它也是一个元循环虚拟机。</p></li><li><p><a href="http://IKVM.NET" target="_blank" rel="noopener noreferrer">IKVM.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>这是一个基于微软 .NET 框架实现的 Java 虚拟机，并借助 Mono 获得一定的跨平台能力。<a href="http://IKVM.NET" target="_blank" rel="noopener noreferrer">IKVM.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 的目标第一眼看起来的确很奇怪，可能在某些特殊情况下，在 .NET 上使用某些流行的 Java 库也许真的不算是伪需求？<a href="http://IKVM.NET" target="_blank" rel="noopener noreferrer">IKVM.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 可以将 Class 文件编译成 .NET Assembly，在任意的 CLI 上运行。</p></li></ul><p>其他在本文中没有介绍到的 Java 虚拟机还有许多，笔者将自己所知的列举如下：</p><ul><li><p>JamVM：<a href="http://jamvm.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://jamvm.sourceforge.net/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>CacaoVM：<a href="http://www.cacaovm.org/" target="_blank" rel="noopener noreferrer">http://www.cacaovm.org/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>SableVM：<a href="http://www.sablevm.org/" target="_blank" rel="noopener noreferrer">http://www.sablevm.org/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>Kaffe：<a href="http://www.kaffe.org/" target="_blank" rel="noopener noreferrer">http://www.kaffe.org/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>Jelatine JVM：<a href="http://jelatine.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://jelatine.sourceforge.net<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>/</p></li><li><p>NanoVM：<a href="http://www.harbaum.org/till/nanovm/index.shtml" target="_blank" rel="noopener noreferrer">http://www.harbaum.org/till/nanovm/index.shtm<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>l</p></li><li><p>MRP：<a href="https://github.com/codehaus/mrp" target="_blank" rel="noopener noreferrer">https://github.com/codehaus/mrp<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>Moxie JVM：<a href="http://moxie.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://moxie.sourceforge.net/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ul><h2 id="_1-5-展望-java-技术的未来" tabindex="-1"><a class="header-anchor" href="#_1-5-展望-java-技术的未来" aria-hidden="true">#</a> 1.5 展望 Java 技术的未来</h2><p>本书第 1、2 版中的 “展望 Java 技术的未来” 分别成文于 2011 年和 2013 年，将近十年时间已经过去，当时畅想的 Java 新发展新变化全部如约而至，这部分内容已不再有 “展望” 的价值。笔者在更新第 3 版时重写了本节全部内容，并把第 2 版的 “展望” 的原文挪到附录之中。倘若 Java 的未来依旧灿烂精彩，倘若下一个十年本书还更新第 4、第 5 版，亦希望届时能在附录中回首今日，去回溯哪些预测成为现实，哪些改进中途夭折。</p><p>如 1.3 节结尾所言，今天的 Java 正处于机遇与挑战并存的时期，Java 未来能否继续壮大发展，某种程度上取决于如何应对当下已出现的挑战，本文将按照这个脉络来组织，向读者介绍现在仍处于 Oracle Labs 中的 Graal VM、Valhalla、Amber、Loom、Panama 等面向未来的研究项目。</p><h3 id="_1-5-1-无语言倾向" tabindex="-1"><a class="header-anchor" href="#_1-5-1-无语言倾向" aria-hidden="true">#</a> 1.5.1 无语言倾向</h3><p>网上每隔一段时间就能见到几条 “未来 X 语言将会取代 Java” 的新闻，此处 &quot;X&quot; 可以用 Kotlin、Golang、Dart、JavaScript、Python 等各种编程语言来代入。这大概就是长期占据编程语言榜单第一位<sup class="footnote-ref"><a href="#footnote32">[32]</a><a class="footnote-anchor" id="footnote-ref32"></a></sup>的烦恼，天下第一总避免不了挑战者相伴。</p><p>如果 Java 有拟人化的思维，它应该从来没有惧怕过被哪一门语言所取代，Java “天下第一” 的底气不在于语法多么先进好用，而是来自它庞大的用户群和极其成熟的软件生态，这在朝夕之间难以撼动。不过，既然有那么多新、旧编程语言的兴起躁动，说明必然有其需求动力所在，譬如互联网之于 JavaScript、人工智能之于 Python，微服务风潮之于 Golang 等。大家都清楚不太可能有哪门语言能在每一个领域都尽占优势，Java 已是距离这个目标最接近的选项，但若 “天下第一” 还要百尺竿头更进一步的话，似乎就只能忘掉 Java 语言本身，踏入无招胜有招的境界。</p><p>2018 年 4 月，Oracle Labs 新公开了一项黑科技：Graal VM，如图1-4 所示，从它的口号 &quot;Run Programs Faster Anywhere&quot; 就能感觉到一颗蓬勃的野心，这句话显然是与 1995 年 Java 刚诞生时的 &quot;Write Once, Run Anywhere&quot; 在遥相呼应。</p><p><img src="/assets/图1-4.acd95034.png" alt="图1-4" loading="lazy"></p><p>图1-4 Graal VM</p><p>Graal VM 被官方称为 &quot;Universal VM&quot; 和 &quot;Polyglot VM&quot;，这是一个在 HotSpot 虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为 “任何语言” 的运行平台使用，这里 “任何语言” 包括了 Java、Scala、Groovy、Kotlin 等基于 Java 虚拟机之上的语言，还包括了 C、C++、Rust 等基于 LLVM 的语言，同时支持其他像 JavaScript、Ruby、Python 和 R 语言等。Graal VM 可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对象，也能够支持这些语言使用已经编写好的本地库文件。</p><p>Graal VM 的基本工作原理是将这些语言的源代码（例如 JavaScript）或源代码编译后的中间格式（例如 LLVM 字节码）通过解释器转换为能被 Graal VM 接受的中间表示（Intermediate Representation，IR），譬如设计一个解释器专门对 LLVM 输出的字节码进行转换来支持 C 和 C++ 语言，这个过程称为程序特化（Specialized，也常被称为 Partial Evaluation）。Graal VM 提供了 Truffle 工具集来快速构建面向一种新语言的解释器，并用它构建了一个称为 Sulong 的高性能 LLVM 字节码解释器。</p><p>从更严格的角度来看，Graal VM 才是真正意义上与物理计算机相对应的高级语言虚拟机，理由是它与物理硬件的指令集一样，做到了只与机器特性相关而不与某种高级语言特性相关。Oracle Labs 的研究总监 Thomas Wuerthinger 在接受 InfoQ 采访时谈到：“随着 GraalVM 1.0 的发布，我们已经证明了拥有高性能的多语言虚拟机是可能的，并且实现这个目标的最佳方式不是通过类似 Java 虚拟机和微软 CLR 那样带有语言特性的字节码<sup class="footnote-ref"><a href="#footnote33">[33]</a><a class="footnote-anchor" id="footnote-ref33"></a></sup>。” 对于一些本来就不以速度见长的语言运行环境，由于 Graal VM 本身能够对输入的中间表示进行自动优化，在运行时还能进行即时编译优化，因此使用 Graal VM 实现往往能够获得比原生编译器更优秀的执行效率，譬如 Graal.js 要优于 Node.js<sup class="footnote-ref"><a href="#footnote34">[34]</a><a class="footnote-anchor" id="footnote-ref34"></a></sup>，Graal.Python 要优于 CPtyhon<sup class="footnote-ref"><a href="#footnote35">[35]</a><a class="footnote-anchor" id="footnote-ref35"></a></sup>，TruffleRuby 要优于 Ruby MRI，FastR 要优于 R 语言等。</p><p>对 Java 而言，Graal VM 本来就是在 HotSpot 基础上诞生的，天生就可作为一套完整的符合 Java SE 8 标准的 Java 虚拟机来使用。它和标准的 HotSpot 的差异主要在即时编译器上，其执行效率、编译质量目前与标准版的 HotSpot 相比也是互有胜负。但现在 Oracle Labs 和美国大学里面的研究院所做的最新即时编译技术的研究全部都迁移至基于 Graal VM 之上进行了，其发展潜力令人期待。如果 Java 语言或者 HotSpot 虚拟机真的有被取代的一天，那从现在看来 Graal VM 是希望最大的一个候选项，这场革命很可能会在 Java 使用者没有明显感觉的情况下悄然而来，Java 世界所有的软件生态都没有发生丝毫变化，但天下第一的位置已经悄然更迭。</p><h3 id="_1-5-2-新一代即时编译器" tabindex="-1"><a class="header-anchor" href="#_1-5-2-新一代即时编译器" aria-hidden="true">#</a> 1.5.2 新一代即时编译器</h3><p>对需要长时间运行的应用来说，由于经过充分预热，热点代码会被 HotSpot 的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中 Java 的运行效率很大程度上取决于即时编译器所输出的代码质量。</p><p>HotSpot 虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为 C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为 C2），通常它们会在分层编译机制下与解释器互相配合来共同构成 HotSpot 虚拟机的执行子系统（这部分具体内容将在本书第 11 章展开讲解）。</p><p>自 JDK 10 起，HotSpot 中又加入了一个全新的即时编译器：Graal 编译器，看名字就可以联想到它是来自于前一节提到的 Graal VM。Graal 编译器是以 C2 编译器替代者的身份登场的。C2 的历史已经非常长了，可以追溯到 Cliff Click 大神读博士期间的作品，这个由 C++ 写成的编译器尽管目前依然效果拔群，但已经复杂到连 Cliff Click 本人都不愿意继续维护的程度。而 Graal 编译器本身就是由 Java 语言写成，实现时又刻意与 C2 采用了同一种名为 &quot;Sea-of-Nodes&quot; 的高级中间表示（High IR）形式，使其能够更容易借鉴 C2 的优点。Graal 编译器比 C2 编译器晚了足足二十年面世，有着极其充沛的后发优势，在保持输出相近质量的编译代码的同时，开发效率和扩展性上都要显著优于 C2 编译器，这决定了 C2 编译器中优秀的代码优化技术可以轻易地移植到 Graal 编译器上，但是反过来 Graal 编译器中行之有效的优化在 C2 编译器里实现起来则异常艰难。这种情况下，Graal 的编译效果短短几年间迅速追平了 C2，甚至某些测试项中开始逐渐反超 C2 编译器。Graal 能够做比 C2 更加复杂的优化，如 “部分逃逸分析”（Partial Escape Analysis），也拥有比 C2 更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。</p><p>今天的 Graal 编译器尚且年幼，还未经过足够多的实践验证，所以仍然带着 “实验状态” 的标签，需要用开关参数去激活<sup class="footnote-ref"><a href="#footnote36">[36]</a><a class="footnote-anchor" id="footnote-ref36"></a></sup>，这让笔者不禁联想起 JDK 1.3 时代，HotSpot 虚拟机刚刚横空出世时的场景，同样也是需要用开关激活，也是作为 Classic 虚拟机的替代品的一段历史。</p><p>Graal 编译器未来的前途可期，作为 Java 虚拟机执行代码的最新引擎，它的持续改进，会同时为 HotSpot 与 Graal VM 注入更快更强的驱动力。</p><h3 id="_1-5-3-向-native-迈进" tabindex="-1"><a class="header-anchor" href="#_1-5-3-向-native-迈进" aria-hidden="true">#</a> 1.5.3 向 Native 迈进</h3><p>对不需要长时间运行的，或者小型化的应用而言，Java（而不是指 Java ME）天生就带有一些劣势，这里并不只是指跑个 HelloWorld 也需要百多兆的 JRE 之类的问题，更重要的是指近几年在从大型单体应用架构向小型微服务应用架构发展的技术潮流下，Java 表现出来的不适应。</p><p>在微服务架构的视角下，应用拆分后，单个微服务很可能就不再需要面对数十、数百 GB 乃至 TB 的内存，有了高可用的服务集群，也无须追求单个服务要 7 × 24 小时不间断地运行，它们随时可以中断和更新；但相应地，Java 的启动时间相对较长，需要预热才能达到最高性能等特点就显得相悖于这样的应用场景。在无服务架构中，矛盾则可能会更加突出，比起服务，一个函数的规模通常会更小，执行时间会更短，当前最热门的无服务运行环境 AWS Lambda 所允许的最长运行时间仅有 15 分钟。</p><p>一直把软件服务作为重点领域的 Java 自然不可能对此视而不见，在最新的几个 JDK 版本的功能清单中，已经陆续推出了跨进程的、可以面向用户程序的类型信息共享（Application Class Data Sharing，AppCDS，允许把加载解析后的类型信息缓存起来，从而提升下次启动速度，原本 CDS 只支持 Java 标准库，在 JDK 10 时的 AppCDS 开始支持用户的程序代码）、无操作的垃圾收集器（Epsilon，只做内存分配而不做回收的收集器，对于运行完就退出的应用十分合适）等改善措施。而酝酿中的一个更彻底的解决方案，是逐步开始对提前编译（Ahead of Time Compilation，AOT）提供支持。</p><p>提前编译是相对于即时编译的概念，提前编译能带来的最大好处是 Java 虚拟机加载这些已经预编译成二进制库之后就能够直接调用，而无须再等待即时编译器在运行时将其编译成二进制机器码。理论上，提前编译可以减少即时编译带来的预热时间，减少 Java 应用长期给人带来的 “第一次运行慢” 的不良体验，可以放心地进行很多全程序的分析行为，可以使用时间压力更大的优化措施<sup class="footnote-ref"><a href="#footnote37">[37]</a><a class="footnote-anchor" id="footnote-ref37"></a></sup>。</p><p>但是提前编译的坏处也很明显，它破坏了 Java “一次编写，到处运行” 的承诺，必须为每个不同的硬件、操作系统去编译对应的发行包；也显著降低了 Java 链接过程的动态性，必须要求加载的代码在编译期就是全部已知的，而不能在运行期才确定，否则就只能舍弃掉已经提前编译好的版本，退回到原来的即时编译执行状态。</p><p>早在 JDK 9 时期，Java 就提供了实验性的 Jaotc 命令来进行提前编译，不过多数人试用过后都颇感失望，大家原本期望的是类似于 Excelsior JET 那样的编译过后能生成本地代码完全脱离 Java 虚拟机运行的解决方案，但 Jaotc 其实仅仅是代替即时编译的一部分作用而已，仍需要运行于 HotSpot 之上。</p><p>直到 Substrate VM 出现，才算是满足了人们心中对 Java 提前编译的全部期待。Substrate VM 是在 Graal VM 0.20 版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和 JNI 访问等组件，目标是代替 HotSpot 用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器（Native Image Generator），用于为用户程序建立基于 Substrate VM 的本地运行时镜像。这个构造器采用指针分析（Points-To Analysis）技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM 就可以直接从目标程序开始运行，而无须重复进行 Java 虚拟机的初始化过程。但相应地，原理上也决定了 Substrate VM 必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM 才能探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法。</p><p>Substrate VM 带来的好处是能显著降低内存占用及启动时间，由于 HotSpot 本身就会有一定的内存消耗（通常约几十 MB），这对最低也从几 GB 内存起步的大型单体应用来说并不算什么，但在微服务下就是一笔不可忽视的成本。根据 Oracle 官方给出的测试数据，运行在 Substrate VM 上的小规模应用，其内存占用和启动时间与运行在 HotSpot 上相比有 5 倍到 50 倍的下降，具体结果如图1-5 和图1-6 所示。</p><p><img src="/assets/图1-5.dc5908d9.png" alt="图1-5" loading="lazy"></p><p>图1-5 内存占用对比</p><p><img src="/assets/图1-6.80e8bc44.png" alt="图1-6" loading="lazy"></p><p>图1-6 启动时间对比</p><p>Substrate VM 补全了 Graal VM &quot;Run Programs Faster Anywhere&quot; 愿景蓝图里的最后一块拼图，让 Graal VM 支持其他语言时不会有重量级的运行负担。譬如运行 JavaScript 代码，Node.js 的 V8 引擎执行效率非常高，但即使是最简单的 HelloWorld，它也要使用约 20MB 的内存，而运行在 Substrate VM 上的 Graal.js，跑一个 HelloWorld 则只需要 4.2MB 内存，且运行速度与 V8 持平。Substrate VM 的轻量特性，使得它十分适合嵌入其他系统，譬如 Oracle 自家的数据库就已经开始使用这种方式支持用不同的语言代替 PL/SQL 来编写存储过程<sup class="footnote-ref"><a href="#footnote38">[38]</a><a class="footnote-anchor" id="footnote-ref38"></a></sup>。在本书第 11 章还会再详细讨论提前编译的相关内容。</p><h3 id="_1-5-4-灵活的胖子" tabindex="-1"><a class="header-anchor" href="#_1-5-4-灵活的胖子" aria-hidden="true">#</a> 1.5.4 灵活的胖子</h3><p>即使 HotSpot 最初设计时考虑得再长远，大概也不会想到这个虚拟机将在未来的二十年内一直保持长盛不衰。这二十年间有无数改进和功能被不断地添加到 HotSpot 的源代码上，致使它成长为今天这样的庞然大物。</p><p>HotSpot 的定位是面向各种不同应用场景的全功能 Java 虚拟机<sup class="footnote-ref"><a href="#footnote39">[39]</a><a class="footnote-anchor" id="footnote-ref39"></a></sup>，这是一个极高的要求，仿佛是让一个胖子能拥有敏捷的身手一样的矛盾。如果是持续跟踪近几年 OpenJDK 的代码变化的人，相信都感觉到了 HotSpot 开发团队正在持续地重构着 HotSpot 的架构，让它具有模块化的能力和足够的开放性。模块化<sup class="footnote-ref"><a href="#footnote40">[40]</a><a class="footnote-anchor" id="footnote-ref40"></a></sup>方面原本是 HotSpot 的弱项，监控、执行、编译、内存管理等多个子系统的代码相互纠缠。而 IBM 的 J9 就一直做得就非常好，面向 Java ME 的 J9 虚拟机与面向 Java EE 的 J9 虚拟机可以是完全由同一套代码库编译出来的产品，只有编译时选择的模块配置有所差别。</p><p>现在，HotSpot 虚拟机也有了与 J9 类似的能力，能够在编译时指定一系列特性开关，让编译输出的 HotSpot 虚拟机可以裁剪成不同的功能，譬如支持哪些编译器，支持哪些收集器，是否支持 JFR、AOT、CDS、NMT 等都可以选择。能够实现这些功能特性的组合拆分，反映到源代码不仅仅是条件编译，更关键的是接口与实现的分离。</p><p>早期（JDK 1.4 时代及之前）的 HotSpot 虚拟机为了提供监控、调试等不会在《Java 虚拟机规范》中约定的内部功能和数据，就曾开放过 Java 虚拟机信息监控接口（Java Virtual Machine Profiler Interface，JVMPI）与 Java 虚拟机调试接口（Java Virtual Machine Debug Interface，JVMDI）供运维和性能监控、IDE 等外部工具使用。到了 JDK 5 时期，又抽象出了层次更高的 Java 虚拟机工具接口（Java Virtual Machine Tool Interface，JVMTI）来为所有 Java 虚拟机相关的工具提供本地编程接口集合，到 JDK 6 时 JVMTI 就完全整合代替了 JVMPI 和 JVMDI 的作用。</p><p>在 JDK 9 时期，HotSpot 虚拟机开放了 Java 语言级别的编译器接口<sup class="footnote-ref"><a href="#footnote41">[41]</a><a class="footnote-anchor" id="footnote-ref41"></a></sup>（Java Virtual Machine Compiler Interface，JVMCI），使得在 Java 虚拟机外部增加、替换即时编译器成为可能，这个改进实现起来并不费劲，但比起之前 JVMPI、JVMDI 和 JVMTI 却是更深层次的开放，它为不侵入 HotSpot 代码而增加或修改 HotSpot 虚拟机的固有功能逻辑提供了可行性。Graal 编译器就是通过这个接口植入到 HotSpot 之中。</p><p>到了 JDK 10，HotSpot 又重构了 Java 虚拟机的垃圾收集器接口<sup class="footnote-ref"><a href="#footnote42">[42]</a><a class="footnote-anchor" id="footnote-ref42"></a></sup>（Java Virtual Machine Compiler Interface），统一了其内部各款垃圾收集器的公共行为。有了这个接口，才可能存在日后（今天尚未）某个版本中的 CMS 收集器退役，和 JDK 12 中 Shenandoah 这样由 Oracle 以外其他厂商领导开发的垃圾收集器进入 HotSpot 中的事情。如果未来这个接口完全开放的话，甚至有可能会出现其他独立于 HotSpot 的垃圾收集器实现。</p><p>经过一系列的重构与开放，HotSpot 虚拟机逐渐从时间的侵蚀中挣脱出来，虽然代码复杂度还在增长，体积仍在变大，但其架构并未老朽，而是拥有了越来越多的开放性和扩展性，使得 HotSpot 成为一个能够联动外部功能，能够应对各种场景，能够学会十八般武艺的身手灵活敏捷的 “胖子”。</p><h3 id="_1-5-5-语言语法持续增强" tabindex="-1"><a class="header-anchor" href="#_1-5-5-语言语法持续增强" aria-hidden="true">#</a> 1.5.5 语言语法持续增强</h3><p>笔者将语言的功能特性和语法放到最后来讲，因为它是相对最不重要的改进点，毕竟连 JavaScript 这种 “反人类” 的语法都能获得如此巨大的成功，而比 Java 语法先进优雅得多的挑战者 C# 现在已经 “江湖日下”，成了末路英雄<sup class="footnote-ref"><a href="#footnote43">[43]</a><a class="footnote-anchor" id="footnote-ref43"></a></sup>。</p><p>但一门语言的功能、语法又是影响语言生产力和效率的重要因素，很多语言特性和语法糖不论有没有，程序也照样能写，但即使只是可有可无的语法糖，也是直接影响语言使用者的幸福感程度的关键指标。JDK 7 的 Coins 项目结束以后，Java 社区又创建了另外一个新的语言特性改进项目 Amber，JDK 10 至 13 里面提供的新语法改进基本都来自于这个项目，譬如：</p><ul><li>JEP 286：Local-Variable Type Inference，在 JDK 10 中提供，本地类型变量推断。</li><li>JEP 323：Local-Variable Syntax for Lambda Parameters，在 JDK 11 中提供，JEP 286 的加强，使它可以用在 Lambda 中。</li><li>JEP 325：Switch Expressions，在 JDK 13 中提供，实现 switch 语句的表达式支持。</li><li>JEP 335：Text Blocks，在 JDK 13 中提供，支持文本块功能，可以节省拼接 HTML、SQL 等场景里大量的 &quot;+&quot; 操作。</li></ul><p>还有一些是仍然处于草稿状态或者暂未列入发布范围的 JEP，可供我们窥探未来 Java 语法的变化，譬如：</p><ul><li>JEP 301：Enhanced Enums，允许常量类绑定数据类型，携带额外的信息。</li><li>JEP 302：Lambda Leftovers，用下划线来表示 Lambda 中的匿名参数。</li><li>JEP 305：Pattern Matching for instanceof，用 instanceof 判断过的类型，在条件分支里面可以不需要做强类型转换就能直接使用。</li></ul><p>除语法糖以外，语言的功能也在持续改进之中，以下几个项目是目前比较明确的，也是受到较多关注的功能改进计划：</p><ul><li><p>Project Loom：现在的 Java 做并发处理的最小调度单位是线程，Java 线程的调度是直接由操作系统内核提供的（这方面的内容可见本书第 12 章），会有核心态、用户态的切换开销。而很多其他语言都提供了更加轻量级的、由软件自身进行调度的用户线程（曾经非常早期的 Java 也有绿色线程），譬如 Golang 的Groutine、D 语言的 Fiber 等。Loom 项目就准备提供一套与目前 Thread 类 API 非常接近的 Fiber 实现。</p></li><li><p>Project Valhalla：提供值类型和基本类型的泛型支持，并提供明确的不可变类型和非引用类型的声明。值类型的作用和价值在本书第 10 章会专门讨论，而不可变类型在并发编程中能带来很多好处，没有数据竞争风险带来了更好的性能。一些语言（如 Scala）就有明确的不可变类型声明，而 Java 中只能在定义类时将全部字段声明为 final 来间接实现。基本类型的范型支持是指在泛型中引用基本数据类型不需要自动装箱和拆箱，避免性能损耗。</p></li><li><p>Project Panama：目的是消弭 Java 虚拟机与本地代码之间的界线。现在 Java 代码可以通过 JNI 来调用本地代码，这点在与硬件交互频繁的场合尤其常用（譬如 Android）。但是 JNI 的调用方式充其量只能说是达到能用的标准而已，使用起来仍相当烦琐，频繁执行的性能开销也非常高昂，Panama 项目的目标就是提供更好的方式让 Java 代码与本地代码进行调用和传输数据。</p></li></ul><p>随着 Java 每半年更新一次的节奏，新版本的 Java 中会出现越来越多其他语言里已有的优秀特性，相信博采众长的 Java，还能继续保持现在的勃勃生机相当长时间。</p><h2 id="_1-6-实战-自己编译-jdk" tabindex="-1"><a class="header-anchor" href="#_1-6-实战-自己编译-jdk" aria-hidden="true">#</a> 1.6 实战：自己编译 JDK</h2><p>想要窥探 Java 虚拟机内部的实现原理，最直接的一条路径就是编译一套自己的 JDK，通过阅读和跟踪调试 JDK 源码来了解 Java 技术体系的运作，虽然这样门槛会比阅读资料更高一点，但肯定也会比阅读各种文章、书籍来得更加贴近本质。此外，Java 类库里的很多底层方法都是 Native 的，在了解这些方法的运作过程，或对 JDK 进行 Hack（根据需要进行定制微调）的时候，都需要有能自行编译、调试虚拟机代码的能力。</p><p>现在网络上有不少开源的 JDK 实现可以供我们选择，但毫无疑问 OpenJDK 是使用得最广泛的 JDK，我们也将选择 OpenJDK 来进行这次编译实战。</p><h3 id="_1-6-1-获取源码" tabindex="-1"><a class="header-anchor" href="#_1-6-1-获取源码" aria-hidden="true">#</a> 1.6.1 获取源码</h3><p>编译源码之前，我们要先明确 OpenJDK 和 OracleJDK 之间、OpenJDK 的各个不同版本之间存在什么联系，这有助于确定接下来编译要使用的 JDK 版本和源码分支，也有助于理解我们编译出来的 JDK 与 Oracle 官方提供的 JDK 有什么差异。</p><p>从前面介绍的 Java 发展史中我们已经知道 OpenJDK 是 Sun 公司在 2006 年年末把 Java 开源而形成的项目，这里的 “开源” 是通常意义上的源码开放形式，即源码是可被复用的，例如 OracleJDK、Oracle OpenJDK、AdoptOpenJDK、Azul Zulu、SAP SapMachine、Amazon Corretto、IcedTea、UltraViolet 等都是从 OpenJDK 源码衍生出的发行版。但如果仅从 “开源” 字面意义（开放可阅读的源码）上讲的话，其实 Sun 公司自 JDK 5 时代起就曾经以 JRL（Java Research License）的形式公开过 Java 的源码，主要是开放给研究人员阅读使用，这种 JRL 许可证的开放源码一直持续到 JDK 6 Update 23 才因 OpenJDK 项目日渐成熟而终止。如果拿 OpenJDK 中的源码跟对应版本的 JRL 许可证形式开放的 Sun / OracleJDK 源码互相比较的话，会发现除了文件头的版权注释之外，其余代码几乎都是相同的，只有少量涉及引用第三方的代码存在差异，如字体栅格化渲染，这部分内容 OracleJDK 采用了商业实现，源码版权不属于 Oracle 自己，所以也无权开源，而 OpenJDK 中使用的是同样开源的 FreeType 代替。</p><p>当然，笔者说的“代码相同 ”必须建立在两者共有的组件基础之上，OpenJDK 中的源码仓库只包含了标准 Java SE 的源代码，而一些额外的模块，典型的如 JavaFX，虽然后来也是被 Oracle 开源并放到 OpenJDK 组织进行管理（OpenJFX 项目），但是它是存放在独立的源码仓库中，因此 OracleJDK 的安装包中会包含 JavaFX 这种独立的模块，而用 OpenJDK 的话则需要单独下载安装。</p><p>此外，在 JDK 11 以前，OracleJDK 中还会存在一些 OpenJDK 没有的、闭源的功能，即 OracleJDK 的 “商业特性”。例如 JDK 8 起从 JRockit 移植改造而来的 Java Flight Recorder 和 Java Mission Control 组件、JDK 10 中的应用类型共享功能（AppCDS）和 JDK 11 中的 ZGC 收集器，这些功能在 JDK 11 时才全部开源到了 OpenJDK 中。到了这个阶段，我们已经可以认为 OpenJDK 与 OracleJDK 代码实质上<sup class="footnote-ref"><a href="#footnote44">[44]</a><a class="footnote-anchor" id="footnote-ref44"></a></sup>已达到完全一致的程度。</p><p>根据 Oracle 的项目发布经理 Joe Darcy 在 OSCON 大会上对两者关系的介绍<sup class="footnote-ref"><a href="#footnote45">[45]</a><a class="footnote-anchor" id="footnote-ref45"></a></sup>也证实了 OpenJDK 和 OracleJDK 在程序上是非常接近的，两者共用了绝大部分相同的代码（如图1-7 所示，注意图中的英文提示了两者共同代码的占比要远高于图形上看到的比例），所以我们编译的 OpenJDK，基本上可以认为性能、功能和执行逻辑上都和官方的 OracleJDK 是一致的。</p><p><img src="/assets/图1-7.da74f4a7.png" alt="图1-7" loading="lazy"></p><p>图1-7 OpenJDK 和 OracleJDK 之间的关系</p><p>下面再来看一下 OpenJDK 内部不同版本之间的关系，在 OpenJDK 接收 Sun 公司移交的 JDK 源码时，Java 正处于 JDK 6 时代的初期，JDK 6 Update 1 才刚刚发布不久，JDK 7 则还完全处于研发状态的半成品。OpenJDK 的第一个版本就是来自于当时 Sun 公司正在开发的 JDK 7，考虑到 OpenJDK 7 的状况在当时完全不足以支持实际的生产部署，因此又在 OpenJDK 7 Build 22 的基础上建立了一条新的 OpenJDK 6 分支，剥离掉所有 JDK 7 新功能的代码，形成一个可以通过 TCK 6 测试的独立分支，先把 OpenJDK 6 发布出去给公众使用。等到 OpenJDK 7 达到了可正式对外发布的状态之后，就从 OpenJDK 7 的主分支延伸出用于研发下一代 Java 版本的 OpenJDK 8 以及用于发布更新补丁的 OpenJDK 7 Update 两条子分支，按照开发习惯，新的功能或 Bug 修复通常是在最新分支上进行的，当功能或修复在最新分支上稳定之后会同步到其他老版本的维护分支上。后续的 JDK 8 和 JDK 9 都重复延续着类似的研发流程。通过图1-8（依然是从 Joe Darcy 的 OSCON 演示稿截取的图片）可以比较清楚地理解不同版本分支之间的关系。</p><p><img src="/assets/图1-8.bed9c64a.png" alt="图1-8" loading="lazy"></p><p>图1-8 OpenJDK 版本之间的关系</p><p>到了 JDK 10 及以后的版本，在组织上出现了一些新变化，此时全部开发工作统一归属到 JDK 和 JDK Updates 两条主分支上，主分支不再带版本号，在内部再用子分支来区分具体的 JDK 版本。OpenJDK 不同版本的源码都可以在它们的主页（<a href="http://openjdk.java.net/%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%EF%BC%8C%E5%9C%A8%E6%9C%AC%E6%AC%A1%E7%BC%96%E8%AF%91%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E7%AC%94%E8%80%85%E9%80%89%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF" target="_blank" rel="noopener noreferrer">http://openjdk.java.net/）上找到，在本次编译实践中，笔者选用的版本是<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> OpenJDK 12。</p><p>获取 OpenJDK 源码有两种方式。一是通过 Mercurial 代码版本管理工具从 Repository 中直接取得源码（Repository 地址：<a href="https://hg.openjdk.java.net/jdk/jdk12%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B%E5%A6%82%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%80%E7%A4%BA%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://hg.openjdk.java.net/jdk/jdk12），获取过程如以下命令所示：<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hg clone https://hg.openjdk.java.net/jdk/jdk12
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是直接取得 OpenJDK 源码的方式，从版本管理中看变更轨迹也能够更精确地了解到 Java 代码发生的变化，但弊端是在中国访问的速度实在太慢，虽然代码总量只有几百 MB，无奈文件数量将近十万，而且仓库没有国内的 CDN 节点。以笔者的网络状况，不科学上网的话，全部复制到本地需要耗费数小时时间。另外，考虑到 Mercurial 远不如 Git 常用，甚至普及程度还不如 SVN、ClearCase 以及更古老的 CVS 等版本控制工具，对于大多数读者，笔者建议采用第二种方式，即直接在仓库中打包出源码压缩包，再进行下载。</p><p>读者可以直接访问准备下载的 JDK 版本的仓库页面（譬如本例中 OpenJDK 12 的页面为 <a href="https://hg.openjdk.java.net/jdk/jdk12/%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E5%B7%A6%E8%BE%B9%E8%8F%9C%E5%8D%95%E4%B8%AD%E7%9A%84" target="_blank" rel="noopener noreferrer">https://hg.openjdk.java.net/jdk/jdk12/），然后点击左边菜单中的<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> &quot;Browse&quot;，将显示如图1-9 的源码根目录页面。</p><p><img src="/assets/图1-9.d5f4c26a.png" alt="图1-9" loading="lazy"></p><p>图1-9 JDK 12 的根目录</p><p>此时点击左边的 &quot;zip&quot; 链接即可下载当前版本打包好的源码，到本地直接解压即可。在国内使用这种方式下载比起从 Mercurial 复制一堆零散文件要快非常多。笔者下载的 OpenJDK 12 源码包大小为 171MB，解压之后约为 579MB。</p><h3 id="_1-6-2-系统需求" tabindex="-1"><a class="header-anchor" href="#_1-6-2-系统需求" aria-hidden="true">#</a> 1.6.2 系统需求</h3><p>如果可能，笔者建议尽量在 Linux 或者 MacOS 上构建 OpenJDK，这两个系统在准备构建工具链和依赖项上要比在 Windows 或 Solaris 平台上要容易许多，本篇实践中笔者将以 Ubuntu 18.04 LTS 为平台进行构建。如果读者确实有在 Windows 平台上完成编译的需求，或需要编译较老版本的 OpenJDK，可参考本书附录 A，这篇附录是本书第 1 版中介绍如何在 Windows 下编译 OpenJDK 6 的实践例子，虽然里面的部分内容已经过时了（例如安装 Plug 部分），但对 Windows 上构建安装环境和较老版本的 OpenJDK 编译还是有一定参考意义的，所以笔者并没有把它删除掉，而是挪到附录之中。</p><p>无论在什么平台下进行编译，都建议读者认真阅读一遍源码中的 doc/building.html 文档，编译过程中需要注意的细节较多，如果读者是第一次编译 OpenJDK，那有可能会在一些小问题上耗费许多时间。在本次编译中采用的是 64 位操作系统，默认参数下编译出来的也是 64 位的 OpenJDK，如果需要编译 32 位版本，笔者同样推荐在 64 位的操作系统上进行，理由是编译过程可以使用更大内存（32 位系统受 4G 内存限制），通过编译参数（--with-target-bits=32）来指定需要生成 32 位编译结果即可。在官方文档上要求编译 OpenJDK 至少需要 2 ~ 4 GB的内存空间（CPU 核心数越多，需要的内存越大），而且至少要 6 ~ 8 GB的空闲磁盘空间，不要看 OpenJDK 源码的大小只有不到 600MB，要完成编译，过程中会产生大量的中间文件，并且编译出不同优化级别（Product、FastDebug、SlowDebug）的 HotSpot 虚拟机可能要重复生成这些中间文件，这都会占用大量磁盘空间。</p><p>对系统环境的最后一点建议是，所有的文件，包括源码和依赖项目，都不要放在包含中文的目录里面，这样做不是一定会产生不可解决的问题，只是没有必要给自己找麻烦。</p><h3 id="_1-6-3-构建编译环境" tabindex="-1"><a class="header-anchor" href="#_1-6-3-构建编译环境" aria-hidden="true">#</a> 1.6.3 构建编译环境</h3><p>在 MacOS<sup class="footnote-ref"><a href="#footnote46">[46]</a><a class="footnote-anchor" id="footnote-ref46"></a></sup>和 Linux 上构建 OpenJDK 编译环境相对简单，对于 MacOS，需要 MacOS X 10.13 版本以上，并安装好最新版本的 XCode 和 Command Line Tools for XCode（在 Apple Developer 网站<sup class="footnote-ref"><a href="#footnote47">[47]</a><a class="footnote-anchor" id="footnote-ref47"></a></sup>上可以免费下载），这两个 SDK 提供了 OpenJDK 所需的 CLang 编译器以及 Makefile 中用到的其他外部命令。</p><p>对于 Linux 系统，要准备的依赖与 MacOS 类似，在 MacOS 中 CLang 编译器来源于 XCode SDK，而 Ubuntu 里用户可以自行选择安装 GCC 或 CLang 来进行编译，但必须确保最低的版本为 GCC 4.8 或者 CLang 3.2 以上，官方推荐使用 GCC 7.8 或者 CLang 9.1 来完成编译。在 Ubuntu 系统上安装 GCC 的命令为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>sudo apt-get install build-essential
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在编译过程中需要依赖 FreeType、CUPS 等若干第三方库，OpenJDK 全部的依赖库已在表1-1 中列出，读者可执行相应的安装命令完成安装。</p><p>表1-1 OpenJDK 编译依赖库</p><p><img src="/assets/表1-1.596bf631.png" alt="表1-1" loading="lazy"></p><p>最后，假设要编译大版本号为 N 的 JDK，我们还要另外准备一个大版本号至少为 N - 1 的、已经编译好的 JDK，这是因为 OpenJDK 由多个部分（HotSpot、JDK 类库、JAXWS、JAXP……）构成，其中一部分（HotSpot）代码使用 C、C++ 编写，而更多的代码则是使用 Java 语言来实现，因此编译这些 Java 代码就需要用到另一个编译期可用的 JDK，官方称这个 JDK 为 &quot;Bootstrap JDK&quot;。编译 OpenJDK 12 时，Bootstrap JDK 必须使用 JDK 11 及之后的版本。在 Ubuntu 中使用以下命令安装 OpenJDK 11：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>sudo apt-get install openjdk-11-jdk
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1-6-4-进行编译" tabindex="-1"><a class="header-anchor" href="#_1-6-4-进行编译" aria-hidden="true">#</a> 1.6.4 进行编译</h3><p>需要下载的编译环境和依赖项目都齐备后，我们就可以按照默认配置来开始编译了，但通常我们编译 OpenJDK 的目的都不仅仅是为了得到在自己机器中诞生的编译成品，而是带着调试、定制化等需求，这样就必须了解 OpenJDK 提供的编译参数才行，这些参数可以使用 &quot;bash configure--help&quot; 命令查询到，笔者对它们中最有用的部分简要说明如下：</p><ul><li>--with-debug-level=&lt;level&gt;：设置编译的级别，可选值为 release、fastdebug、slowdebug，越往后进行的优化措施就越少，带的调试信息就越多。还有一些虚拟机调试参数必须在特定模式下才可以使用。默认值为 release。</li><li>--enable-debug：等效于 --with-debug-level=fastdebug。</li><li>--with-native-debug-symbols=&lt;method&gt;：确定调试符号信息的编译方式，可选值为 none、internal、external、zipped。</li><li>--with-version-string=&lt;string&gt;：设置编译 JDK 的版本号，譬如 java -version 的输出就会显示该信息。这个参数还有 --with-version-&lt;part&gt;=&lt;value&gt; 的形式，其中 part 可以是 pre、opt、build、major、minor、security、patch 之一，用于设置版本号的某一个部分。</li><li>--with-jvm-variants=&lt;variant&gt;[, &lt;variant&gt;...]：编译特定模式（Variants）的 HotSpot 虚拟机，可以多个模式并存，可选值为 server、client、minimal、core、zero、custom。</li><li>--with-jvm-features=&lt;feature&gt;[, &lt;feature&gt;...]：针对 --with-jvm-variants=custom 时的自定义虚拟机特性列表（Features），可以多个特性并存，由于可选值较多，请参见 help 命令输出。</li><li>--with-target-bits=&lt;bits&gt;：指明要编译 32 位还是 64 位的 Java 虚拟机，在 64 位机器上也可以通过交叉编译生成 32 位的虚拟机。</li><li>--with-&lt;lib&gt;=&lt;path&gt;：用于指明依赖包的具体路径，通常使用在安装了多个不同版本的 Bootstrap JDK 和依赖包的情况。其中lib的可选值包括 boot-jd、freetype、cups、x、alsa、libffi、jtreg、libjpeg、giflib、libpng、lcms、zlib。</li><li>--with-extra-&lt;flagtype&gt;=&lt;flags&gt;：用于设定 C、C++ 和 Java 代码编译时的额外编译器参数，其中 flagtype 可选值为 cflags、cxxflags、ldflags，分别代表 C、C++ 和 Java 代码的参数。</li><li>--with-conf-name=&lt;name&gt;：指定编译配置名称，OpenJDK 支持使用不同的配置进行编译，默认会根据编译的操作系统、指令集架构、调试级别自动生成一个配置名称，譬如 &quot;linux-x86_64-server-release&quot;，如果在这些信息都相同的情况下保存不同的编译参数配置，就需要使用这个参数来自定义配置名称。</li></ul><p>以上是 configure 命令的部分参数，其他未介绍到的可以使用 &quot;bash configure --help&quot; 来查看，所有参数均通过以下形式使用：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>bash configure [options]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>譬如，编译 FastDebug 版、仅含 Server 模式的 HotSpot 虚拟机，命令应为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>bash configure --enable-debug --with-jvm-variants=server
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>configure 命令承担了依赖项检查、参数配置和构建输出目录结构等多项职责，如果编译过程中需要的工具链或者依赖项有缺失，命令执行后将会得到明确的提示，并且给出该依赖的安装命令，这比编译旧版 OpenJDK 时的 &quot;make sanity&quot; 检查要友好得多，譬如以下例子所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>configure: error: Could not find fontconfig! You might be able to fix this by running &#39;sudo apt-get inst configure exiting with result code 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果一切顺利的话，就会收到配置成功的提示，并且输出调试级别，Java 虚拟机的模式、特性，使用的编译器版本等配置摘要信息，如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>A new configuration has been successfully created in
/home/icyfenix/develop/java/jdk12/build/linux-x86_64-server-release 
using default settings.

Configuration summary:
 * Debug level:	release
 * HS debug level: product
 * JVM variants:	server
 * JVM features:	server: &#39;aot cds cmsgc compiler1 compiler2 epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc&#39;
 * OpenJDK target: OS: linux, CPU architecture: x86, address length: 64
 * Version string: 12-internal+0-adhoc.icyfenix.jdk12 (12-internal)

Tools summary:
 * Boot JDK:	openjdk version &quot;11.0.3&quot; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-Ubuntu-1ubuntu218.04.1) OpenJDK 64-Bit Server VM (build 11.0.3+7-Ubuntu-1ubuntu218.04.1, mixed mode, sharing)  (at /usr/lib/jvm/java-11-openjdk-amd64)
 * Toolchain:	gcc (GNU Compiler Collection)
 * C Compiler:	Version 7.4.0 (at /usr/bin/gcc)
 * C++ Compiler:	Version 7.4.0 (at /usr/bin/g++)

Build performance summary:
 * Cores to use:	4
 * Memory limit:	7976 MB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 configure 命令以及后面的 make 命令的执行过程中，会在 “build/配置名称” 目录下产生如下目录结构。不常使用 C / C++ 的读者要特别注意，如果多次编译，或者目录结构成功产生后又再次修改了配置，必须先使用 &quot;make clean&quot; 和 &quot;make distclean&quot; 命令清理目录，才能确保新的配置生效。编译产生的目录结构以及用途如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>buildtools/：用于生成、存放编译过程中用到的工具
hotspot/：HotSpot 虚拟机编译的中间文件
images/：使用 make *-image 产生的镜像存放在这里
jdk/：编译后产生的 JDK 就放在这里
support/：存放编译时产生的中间文件
test-results/：存放编译后的自动化测试结果
configure-support/：这三个目录是存放执行 configure、make 和 test 的临时文件
make-support/
test-support/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依赖检查通过后便可以输入 &quot;make images&quot; 执行整个 OpenJDK 编译了，这里 &quot;images&quot; 是 &quot;product-images&quot; 编译目标（Target）的简写别名，这个目标的作用是编译出整个 JDK 镜像，除了 &quot;product-images&quot; 以外，其他编译目标还有：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>hotspot：只编译 HotSpot 虚拟机
hotspot-&lt;variant&gt;：只编译特定模式的 HotSpot 虚拟机
docs-image：产生 JDK 的文档镜像
test-image：产生 JDK 的测试镜像
all-images：相当于连续调用 product、docs、test 三个编译目标
bootcycle-images：编译两次 JDK，其中第二次使用第一次的编译结果作为 Bootstrap JDK 
clean：清理 make 命令产生的临时文件
dist-clean：清理 make 和 configure 命令产生的临时文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>笔者使用 Oracle VM VirtualBox 虚拟机，启动 4 条编译线程，8GB 内存，全量编译整个 OpenJDK 12 大概需近 15 分钟时间，如果之前已经全量编译过，只是修改了少量文件的话，增量编译可以在数十秒内完成。编译完成之后，进入 OpenJDK 源码的 &quot;build/配置名称/jdk” 目录下就可以看到 OpenJDK 的完整编译结果了，把它复制到 JAVA_HOME 目录，就可以作为一个完整的 JDK 来使用，如果没有人为设置过 JDK 开发版本的话，这个 JDK 的开发版本号里默认会带上编译的机器名，如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&gt; ./java -version
openjdk version &quot;12-internal&quot; 2019-03-19
OpenJDK Runtime Environment (build 12-internal+0-adhoc.icyfenix.jdk12)
OpenJDK 64-Bit Server VM (build 12-internal+0-adhoc.icyfenix.jdk12, mixed mode)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-6-5-在-ide-工具中进行源码调试" tabindex="-1"><a class="header-anchor" href="#_1-6-5-在-ide-工具中进行源码调试" aria-hidden="true">#</a> 1.6.5 在 IDE 工具中进行源码调试</h3><p>我们在阅读 OpenJDK 源码的过程中，肯定会运行和跟踪调试程序来帮助理解。现在我们已学会了如何编译一个可调试版本 HotSpot 虚拟机，并禁用优化，带有符号信息，这样的编译结果已经可以直接使用 GDB 在命令行中进行调试了。据笔者所知，不少对 Java 虚拟机研发接触比较多的开发人员确实就是使用 GDB 和 VIM 编辑器来开发、修改 HotSpot 源码的，不过相信大多数读者都还是更倾向于在 IDE 环境而不是纯文本下阅读、跟踪 HotSpot 源码。为此，本节将会讲解如何在 IDE 中进行 HotSpot 源码调试。</p><p>在本次实战里，笔者采用的 IDE 是 JetBrains 的 CLion 2019.1，读者可以在 JetBrains 网站<sup class="footnote-ref"><a href="#footnote48">[48]</a><a class="footnote-anchor" id="footnote-ref48"></a></sup>上直接下载并免费使用 30 天，如果希望使用其他 IDE，譬如 Eclipst CDT 或者 NetBeans，可以参考本书第 2 版中相同章节的内容，为节省篇幅笔者就没有把它放到附录中了。</p><p>CLion 安装后，新建一个项目，选择 &quot;New CMake Project from Sources&quot;，在源码文件夹中填入 OpenJDK 源码根目录，此时，CLion 已经自动选择好了需要导入的源码，如图1-10 所示。点击 OK 按钮就会导入源码并自动创建好 CMakeLists.txt 文件。</p><p><img src="/assets/图1-10.b67beb1d.png" alt="图1-10" loading="lazy"></p><p>图1-10 在 CLion 中创建 HotSpot 项目 (1)</p><p>这份自动生成的 CMakeLists.txt 并不能直接使用，OpenJDK 本身也没有为任何 IDE 提供支持，但如果只是为了能够在 CLion 中跟踪、阅读源码，而不需要修改重新编译的话，那直接在 Run / Debug Configurations 中增加一个 CMake Application，然后 Executable 选择我们刚才编译出来的 FastDebug 或者 SlowDebug 版的 java 命令，运行参数加上 -version 或者某个 Class 文件的路径，再把 Before launch 里面的 Build 去掉，就可以开始运行调试了，如图1-11 所示。</p><p><img src="/assets/图1-11.e3c9bb75.png" alt="图1-11" loading="lazy"></p><p>图1-11 在 CLion 中创建 HotSpot 项目 (2)</p><p>不过如果读者需要在 CLion 中修改源码，并重新编译产生新的 JDK，又或者不想阅读时看见一堆头文件缺失提示的话，那还是需要把 CMakeLists.txt 修好，在 GitHub 上已经有现成的<sup class="footnote-ref"><a href="#footnote49">[49]</a><a class="footnote-anchor" id="footnote-ref49"></a></sup>参考，读者可以直接下载，内容较多，篇幅所限，笔者就不在本文中列出了。</p><p>读者在调试 Java 代码执行时，如果要跟踪具体 Java 代码在虚拟机中是如何执行的，一开始可能会觉得有些无处入手，因为目前 HotSpot 在主流的操作系统上，都采用模板解释器来执行字节码，它与即时编译器一样，最终执行的汇编代码都是运行期间产生的，无法直接设置断点，所以 HotSpot 增加了以下参数来方便开发人员调试解释器：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+TraceBytecodes -XX:StopInterpreterAt=&lt;n&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这组参数的作用是当遇到序号为 &lt;n&gt; 的字节码指令时，便会中断程序执行，进入断点调试。调试解释器部分代码时，把这两个参数加到 java 命令的参数后面即可。</p><p>完成以上配置之后，一个可修改、编译、调试的 HotSpot 工程就完全建立起来了，HotSpot 虚拟机启动器的执行入口是 java.c 的 JavaMain() 方法，读者可以设置断点单步跟踪，如图1-12 所示。</p><p><img src="/assets/图1-12.91e9355b.png" alt="图1-12" loading="lazy"></p><p>图1-12 在 CLion 中创建 HotSpot 项目 (3)</p><h2 id="_1-7-本章小结" tabindex="-1"><a class="header-anchor" href="#_1-7-本章小结" aria-hidden="true">#</a> 1.7 本章小结</h2><p>本章介绍了 Java 技术体系的过去、现在和未来的发展趋势，并在实践中介绍了如何自己编译一个 OpenJDK 12。作为全书的引言部分，本章建立了后文研究所必需的环境。在了解 Java 技术的来龙去脉后，后面章节将分为四部分去介绍 Java 在 “自动内存管理”、“Class 文件结构与执行引擎”、“编译器优化” 及 “多线程并发” 方面的实现原理。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>这些数据是 Java 的广告词，它们来源于：<a href="http://www.java.com/zh_CN/about/%E3%80%82" target="_blank" rel="noopener noreferrer">http://www.java.com/zh_CN/about/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>JCP：Java Community Process，就是人们常说的 “Java 社区”，这是一个由业界多家技术巨头组成的社区组织，用于定义和发展 Java 的技术规范。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>本书将以 OpenJDK / OracleJDK 中的 HotSpot 虚拟机为主脉络进行讲述，这是目前业界占统治地位的 JDK 和虚拟机，但它们并非唯一的选择，当本书中涉及其他厂商的 JDK 和其他 Java 虚拟机的内容时，笔者会指明上下文中 JDK 的全称。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>Java SE API 范围：<a href="https://docs.oracle.com/en/java/javase/12/docs/api/index.html%E3%80%82" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/12/docs/api/index.html。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>这些扩展一般以 javax.* 作为包名，而以 java.* 为包名的包都是 Java SE API 的核心包，但由于历史原因，一部分曾经是扩展包的 API 后来进入了核心包中，因此核心包中也包含了不少 javax.* 开头的包名。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p>Java 从 1.5 版本开始，官方在正式文档与宣传上已经不再使用类似 &quot;JDK 1.5&quot; 的命名，只有程序员内部使用的开发版本号（Developer Version，例如 java -version 的输出）中才继续沿用 1.5、1.6、1.7 这样的版本号，而公开版本号（Product Version）则是改为 JDK 5.0、JDK 6、JDK 7 的命名方式，JDK 5.0 中 &quot;.0&quot; 的后缀从 JDK 6 起也被移除掉，本书为了行文统一，同样以 JDK 5 来指代 JDK 5.0。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li><li id="footnote7" class="footnote-item"><p>除了 Java SE Support 外，还有面向独立软件提供商的 Java SE Advanced &amp; Suite 产品线，差别是后者带有 JMC 等监控工具，详细内容可以参见本书第 4 章。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p></li><li id="footnote8" class="footnote-item"><p>特指商业用户，个人使用仍然是可以免费获得这些更新包的。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p></li><li id="footnote9" class="footnote-item"><p>这是官方的声明，而事实上直到 JDK 8 Update 21 之前在 Windows XP 上仍可正常运行。 <a href="#footnote-ref9" class="footnote-backref">↩︎</a></p></li><li id="footnote10" class="footnote-item"><p>&quot;HotRockit&quot; 项目的相关介绍：<a href="http://hirt.se/presentations/WhatToExpect.ppt%E3%80%82" target="_blank" rel="noopener noreferrer">http://hirt.se/presentations/WhatToExpect.ppt。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref10" class="footnote-backref">↩︎</a></p></li><li id="footnote11" class="footnote-item"><p>除了 JMC 和 JFR，HotSpot 用本地内存代替永久代实现方法区，支持本地内存使用情况追踪（NMT）等功能是从 JRockit 借鉴过来的。 <a href="#footnote-ref11" class="footnote-backref">↩︎</a></p></li><li id="footnote12" class="footnote-item"><p>来自于以前的 &quot;DLL Hell&quot;，如果读者不清楚什么是模块地狱的话，打开你计算机的 windows 目录或者 windows\system32 目录就明白了。 <a href="#footnote-ref12" class="footnote-backref">↩︎</a></p></li><li id="footnote13" class="footnote-item"><p>其实就是以 IBM 为首，IBM 一直与 RedHat 有密切合作，2018 年 IBM 以 340 亿美元天价收购了 RedHat。 <a href="#footnote-ref13" class="footnote-backref">↩︎</a></p></li><li id="footnote14" class="footnote-item"><p>投票记录：<a href="https://jcp.org/en/jsr/results?id=5959%E3%80%82" target="_blank" rel="noopener noreferrer">https://jcp.org/en/jsr/results?id=5959。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref14" class="footnote-backref">↩︎</a></p></li><li id="footnote15" class="footnote-item"><p>公开信：<a href="https://www.infoq.cn/article/2017/05/jigsaw-open-letter%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/2017/05/jigsaw-open-letter。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref15" class="footnote-backref">↩︎</a></p></li><li id="footnote16" class="footnote-item"><p>也改掉了在开发版号中 1.7、1.8 的命名，从 JDK 10 后将是年份加月份作为开发版本号，譬如 18.3，即表示 2018 年 3 月的大版本。 <a href="#footnote-ref16" class="footnote-backref">↩︎</a></p></li><li id="footnote17" class="footnote-item"><p>Oracle 与 Google 的官司主要焦点在于 Java API 的版权问题，而不在程序是否能运行在标准 Java 虚拟机上。 <a href="#footnote-ref17" class="footnote-backref">↩︎</a></p></li><li id="footnote18" class="footnote-item"><p>资料来源：<a href="https://www.infoworld.com/article/2987529/insider-oracle-lost-interest-in-java.html%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.infoworld.com/article/2987529/insider-oracle-lost-interest-in-java.html。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref18" class="footnote-backref">↩︎</a></p></li><li id="footnote19" class="footnote-item"><p>最大的争议点是 Oracle 要求包名中不能出现 java 字样，导致一堆 javax.* 开头的包一旦修改或添加新代码，就必须重新命名，这将让用到它们的代码都受到影响。资料来源：<a href="https://www.infoq.cn/article/2018/02/from-javaee-to-jakartaee%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/2018/02/from-javaee-to-jakartaee。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref19" class="footnote-backref">↩︎</a></p></li><li id="footnote20" class="footnote-item"><p>Java One 大会从 2019 年起停办，合并入 Oracle CodeOne 大会中。 <a href="#footnote-ref20" class="footnote-backref">↩︎</a></p></li><li id="footnote21" class="footnote-item"><p>需要使用 +XX:+UnlockCommercialFeatures 解锁的特性，包括 JMC、JFR、NMT、AppCDS 和 ZGC 等。 <a href="#footnote-ref21" class="footnote-backref">↩︎</a></p></li><li id="footnote22" class="footnote-item"><p>资料来源：<a href="https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later%E3%80%82" target="_blank" rel="noopener noreferrer">https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref22" class="footnote-backref">↩︎</a></p></li><li id="footnote23" class="footnote-item"><p>JDK 11 中仅有的微小差别是 OpenJDK 少了几个 Module（如 JavaFX），且不提供安装包，以压缩包形式发行。但在 JDK 12 又产生了新的分歧，OpenJDK 的 Shenandoah 垃圾收集器被排除在 OracleJDK 之外，详见第 4 章的相关内容。 <a href="#footnote-ref23" class="footnote-backref">↩︎</a></p></li><li id="footnote24" class="footnote-item"><p>这里的商业支持不限定于 Oracle 公司，如 Azul ZingJDK、AdoptOpenJDK 等都能提供商业支持。 <a href="#footnote-ref24" class="footnote-backref">↩︎</a></p></li><li id="footnote25" class="footnote-item"><p>Red Hat 此前已经是 OpenJDK 6（自 2013 年起）和 OpenJDK 7（自 2015 年起）的维护者。 <a href="#footnote-ref25" class="footnote-backref">↩︎</a></p></li><li id="footnote26" class="footnote-item"><p>在本书第 11 章会专门讲解即时编译的内容。 <a href="#footnote-ref26" class="footnote-backref">↩︎</a></p></li><li id="footnote27" class="footnote-item"><p>严格来说这种提法并不十分准确，笔者写下这段文字时（2019 年），在中国，传音手机的出货量超过小米、OPPO、VIVO 等智能手机巨头，仅次于华为（含荣耀品牌）排行全国第二。传音手机做的是功能机，销售市场主要在非洲，上面仍然用着 Java ME 的 KVM。 <a href="#footnote-ref27" class="footnote-backref">↩︎</a></p></li><li id="footnote28" class="footnote-item"><p>严格来说，J9 能够支持的市场定位比 HotSpot 更加广泛，J9 最初是为嵌入式领域设计的，后来逐渐扩展为 IBM 所有平台共用的虚拟机，嵌入式、桌面、服务器端都用它，而 HotSpot 在嵌入式领域使用的是 CDC / CLDC 以及 Java SE Embedded，这也从侧面体现了 J9 的模块化和通用性做得非常好。 <a href="#footnote-ref28" class="footnote-backref">↩︎</a></p></li><li id="footnote29" class="footnote-item"><p>尽管 OpenJ9 名称上看起来与 OpenJDK 类似，但它只是一个单独的 Java 虚拟机，不包括 JDK 中的其他内容，实际应该与 HotSpot 相对应。 <a href="#footnote-ref29" class="footnote-backref">↩︎</a></p></li><li id="footnote30" class="footnote-item"><p>Sun 公司在《纽约时报》、《圣约瑟商业新闻》和《华尔街周刊》上刊登了整页的广告，在广告词中 Sun 公司号召消费者 “要求微软公司继续在其 Windows XP 系统包括 Java 平台”。 <a href="#footnote-ref30" class="footnote-backref">↩︎</a></p></li><li id="footnote31" class="footnote-item"><p>这里把 Java ME 里面的虚拟机列为 “少数派” 是从大多数 Java 程序员的了解程度出发的，从虚拟机部署数量来讲，Java ME 远比 Java SE、Java EE 的虚拟机多，毕竟服务器应用是无法在数量上和移动、嵌入式设备比较的。 <a href="#footnote-ref31" class="footnote-backref">↩︎</a></p></li><li id="footnote32" class="footnote-item"><p>参见 TIOBE 编程语言排行榜：<a href="https://www.tiobe.com/tiobe-index/%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.tiobe.com/tiobe-index/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref32" class="footnote-backref">↩︎</a></p></li><li id="footnote33" class="footnote-item"><p>资料来源：<a href="https://www.infoq.com/news/2018/04/oracle-graalvm-v1/%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.infoq.com/news/2018/04/oracle-graalvm-v1/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref33" class="footnote-backref">↩︎</a></p></li><li id="footnote34" class="footnote-item"><p>Graal.js 能否比 Node.js 更快目前为止还存有很大争议，Node.js 背靠 Google 的 V8 引擎、执行性能优异，要超越绝非易事。 <a href="#footnote-ref34" class="footnote-backref">↩︎</a></p></li><li id="footnote35" class="footnote-item"><p>Python 的运行环境 PyPy 其实做了与 Graal VM 差不多的工作，只是仅针对 Python 而没有为其他高级语言提供解释器。 <a href="#footnote-ref35" class="footnote-backref">↩︎</a></p></li><li id="footnote36" class="footnote-item"><p>使用 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler 参数来启用 Graal 编译器。 <a href="#footnote-ref36" class="footnote-backref">↩︎</a></p></li><li id="footnote37" class="footnote-item"><p>由于 AOT 编译没有运行时的监控信息，很多由运行信息统计进行向导的优化措施不能使用，所以尽管没有编译时间的压力，效果也不一定就比 JIT 更好。 <a href="#footnote-ref37" class="footnote-backref">↩︎</a></p></li><li id="footnote38" class="footnote-item"><p>Oracle Database MLE，从 Oracle 12c 开始支持，详见 <a href="https://oracle.github.io/oracle-db-mle%E3%80%82" target="_blank" rel="noopener noreferrer">https://oracle.github.io/oracle-db-mle。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref38" class="footnote-backref">↩︎</a></p></li><li id="footnote39" class="footnote-item"><p>定位 J9 做到了，HotSpot 实际上并未做到，譬如在 Java ME 中的虚拟机就不是 HotSpot，而是 CDC-HI / CLDC-HI。 <a href="#footnote-ref39" class="footnote-backref">↩︎</a></p></li><li id="footnote40" class="footnote-item"><p>这里指虚拟机本身的模块化，与 Jigsaw 无关。 <a href="#footnote-ref40" class="footnote-backref">↩︎</a></p></li><li id="footnote41" class="footnote-item"><p>并不是指内部代码上统一 C1、C2 的编译器接口，而是特指会开放给外部的、使用 Java 语言实现的编译器接口。 <a href="#footnote-ref41" class="footnote-backref">↩︎</a></p></li><li id="footnote42" class="footnote-item"><p>这个接口目前只在 HotSpot 内部使用，并未对外开放，所以也就没有 JVMGI 的提法。 <a href="#footnote-ref42" class="footnote-backref">↩︎</a></p></li><li id="footnote43" class="footnote-item"><p>笔者个人观点，读者请勿从 “反人类”、“江湖日下” 这些词语中挑起语言战争。毕竟 “PHP 是世界上最好的语言”（梗）。 <a href="#footnote-ref43" class="footnote-backref">↩︎</a></p></li><li id="footnote44" class="footnote-item"><p>严格来说，这里 “实质上” 可以理解为除去一些版权信息（如 java -version 的输出）、除去针对 Oracle 自身特殊硬件平台的适配、除去 JDK 12 中 OracleJDK 排除了 Shenandoah 这类特意设置的差异之外是一致的。 <a href="#footnote-ref44" class="footnote-backref">↩︎</a></p></li><li id="footnote45" class="footnote-item"><p>全文地址：<a href="https://blogs.oracle.com/darcy/resource/OSCON/oscon2011_OpenJDKState.pdf%E3%80%82" target="_blank" rel="noopener noreferrer">https://blogs.oracle.com/darcy/resource/OSCON/oscon2011_OpenJDKState.pdf。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref45" class="footnote-backref">↩︎</a></p></li><li id="footnote46" class="footnote-item"><p>注意，在 OpenJDK 7u4 和之后的版本才能编译出 MacOS 系统下的 JDK 包，之前的版本虽然在源码和编译脚本中也包含了 MacOS 目录，但是尚未完善。 <a href="#footnote-ref46" class="footnote-backref">↩︎</a></p></li><li id="footnote47" class="footnote-item"><p><a href="https://developer.apple.com/%E3%80%82" target="_blank" rel="noopener noreferrer">https://developer.apple.com/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref47" class="footnote-backref">↩︎</a></p></li><li id="footnote48" class="footnote-item"><p>官网地址：<a href="https://www.jetbrains.com/clion/%E3%80%82" target="_blank" rel="noopener noreferrer">https://www.jetbrains.com/clion/。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref48" class="footnote-backref">↩︎</a></p></li><li id="footnote49" class="footnote-item"><p><a href="https://github.com/ojdkbuild/ojdkbuild/blob/master/src/java-12-openjdk/CMakeLists.txt%E3%80%82" target="_blank" rel="noopener noreferrer">https://github.com/ojdkbuild/ojdkbuild/blob/master/src/java-12-openjdk/CMakeLists.txt。<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> <a href="#footnote-ref49" class="footnote-backref">↩︎</a></p></li></ol></section></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/深入理解Java虚拟机：JVM高级特性与最佳实践/第1章走近Java.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
