<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 4 章 对象的组合"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-07-28T13:05:06.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-07-28T13:05:06.000Z"><title>第 4 章 对象的组合 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link active" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java 并发编程实战</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E4%BB%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 简介"><!---->第 1 章 简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第一部分 基础知识</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 线程安全"><!---->第 2 章 线程安全<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC3%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对象的共享"><!---->第 3 章 对象的共享<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 4 章 对象的组合"><!---->第 4 章 对象的组合<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-设计线程安全的类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 设计线程安全的类"><!---->4.1 设计线程安全的类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-2-依赖状态的操作" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1.2 依赖状态的操作"><!---->4.1.2 依赖状态的操作<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-3-状态的所有权" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1.3 状态的所有权"><!---->4.1.3 状态的所有权<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-实例封闭" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 实例封闭"><!---->4.2 实例封闭<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-1-java-监视器模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.1 Java 监视器模式"><!---->4.2.1 Java 监视器模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-2-示例-车辆追踪" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.2 示例：车辆追踪"><!---->4.2.2 示例：车辆追踪<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-线程安全性的委托" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 线程安全性的委托"><!---->4.3 线程安全性的委托<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-1-示例-基于委托的车辆追踪器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.1 示例：基于委托的车辆追踪器"><!---->4.3.1 示例：基于委托的车辆追踪器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-2-独立的状态变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.2 独立的状态变量"><!---->4.3.2 独立的状态变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-3-当委托失效时" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.3 当委托失效时"><!---->4.3.3 当委托失效时<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-4-发布底层的状态变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.4 发布底层的状态变量"><!---->4.3.4 发布底层的状态变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-5-示例-发布状态的车辆追踪器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.5 示例：发布状态的车辆追踪器"><!---->4.3.5 示例：发布状态的车辆追踪器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-在现有的线程安全类中添加功能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 在现有的线程安全类中添加功能"><!---->4.4 在现有的线程安全类中添加功能<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-1-客户端加锁机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4.1 客户端加锁机制"><!---->4.4.1 客户端加锁机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-2-组合" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4.2 组合"><!---->4.4.2 组合<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-5-将同步策略文档化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5 将同步策略文档化"><!---->4.5 将同步策略文档化<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC5%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 基础构建模块"><!---->第 5 章 基础构建模块<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 结构化并发应用程序</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC6%E7%AB%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 任务执行"><!---->第 6 章 任务执行<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC7%E7%AB%A0%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 取消与关闭"><!---->第 7 章 取消与关闭<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC8%E7%AB%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 线程池的使用"><!---->第 8 章 线程池的使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC9%E7%AB%A0%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 图形用户界面应用程序"><!---->第 9 章 图形用户界面应用程序<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第三部分 活跃性、性能与测试</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 避免活跃性危险"><!---->第 10 章 避免活跃性危险<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC11%E7%AB%A0%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 性能与可伸缩性"><!---->第 11 章 性能与可伸缩性<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC12%E7%AB%A0%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%8B%E8%AF%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 并发程序的测试"><!---->第 12 章 并发程序的测试<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 高级主题</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC13%E7%AB%A0%E6%98%BE%E5%BC%8F%E9%94%81.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 显式锁"><!---->第 13 章 显式锁<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC14%E7%AB%A0%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 14 章 构建自定义的同步工具"><!---->第 14 章 构建自定义的同步工具<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC15%E7%AB%A0%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 15 章 原子变量与非阻塞同步机制"><!---->第 15 章 原子变量与非阻塞同步机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC16%E7%AB%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 16 章 Java 内存模型简介"><!---->第 16 章 Java 内存模型简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 4 章 对象的组合</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月1日</span><meta property="datePublished" content="2022-07-01T01:25:00.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 46 分钟</span><meta property="timeRequired" content="PT46M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 13692 字</span><meta property="wordCount" content="13692"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-设计线程安全的类" class="router-link-active router-link-exact-active toc-link level2">4.1 设计线程安全的类</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-2-依赖状态的操作" class="router-link-active router-link-exact-active toc-link level3">4.1.2 依赖状态的操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-1-3-状态的所有权" class="router-link-active router-link-exact-active toc-link level3">4.1.3 状态的所有权</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-实例封闭" class="router-link-active router-link-exact-active toc-link level2">4.2 实例封闭</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-1-java-监视器模式" class="router-link-active router-link-exact-active toc-link level3">4.2.1 Java 监视器模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-2-2-示例-车辆追踪" class="router-link-active router-link-exact-active toc-link level3">4.2.2 示例：车辆追踪</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-线程安全性的委托" class="router-link-active router-link-exact-active toc-link level2">4.3 线程安全性的委托</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-1-示例-基于委托的车辆追踪器" class="router-link-active router-link-exact-active toc-link level3">4.3.1 示例：基于委托的车辆追踪器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-2-独立的状态变量" class="router-link-active router-link-exact-active toc-link level3">4.3.2 独立的状态变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-3-当委托失效时" class="router-link-active router-link-exact-active toc-link level3">4.3.3 当委托失效时</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-4-发布底层的状态变量" class="router-link-active router-link-exact-active toc-link level3">4.3.4 发布底层的状态变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-3-5-示例-发布状态的车辆追踪器" class="router-link-active router-link-exact-active toc-link level3">4.3.5 示例：发布状态的车辆追踪器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-在现有的线程安全类中添加功能" class="router-link-active router-link-exact-active toc-link level2">4.4 在现有的线程安全类中添加功能</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-1-客户端加锁机制" class="router-link-active router-link-exact-active toc-link level3">4.4.1 客户端加锁机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-4-2-组合" class="router-link-active router-link-exact-active toc-link level3">4.4.2 组合</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html#_4-5-将同步策略文档化" class="router-link-active router-link-exact-active toc-link level2">4.5 将同步策略文档化</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-4-章-对象的组合" tabindex="-1"><a class="header-anchor" href="#第-4-章-对象的组合" aria-hidden="true">#</a> 第 4 章 对象的组合</h1><p>到目前为止，我们已经介绍了关于线程安全与同步的一些基础知识。然而，我们并不希望对每一次内存访问都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。本章将介绍一些组合模式，这些模式能够使一个类更容易成为线程安全的，并且在维护这些类时不会无意中破坏类的安全性保证。</p><h2 id="_4-1-设计线程安全的类" tabindex="-1"><a class="header-anchor" href="#_4-1-设计线程安全的类" aria-hidden="true">#</a> 4.1 设计线程安全的类</h2><p>在线程安全的程序中，虽然可以将程序的所有状态都保存在公有的静态域中，但与那些将状态封装起来的程序相比，这些程序的线程安全性更难以得到验证，并且在修改时也更难以始终确保其线程安全性。通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。</p><p>在设计线程安全类的过程中，需要包含以下三个基本要素：</p><ul><li><p>找出构成对象状态的所有变量。</p></li><li><p>找出约束状态变量的不变性条件。</p></li><li><p>建立对象状态的并发访问管理策略。</p></li></ul><p>要分析对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。程序清单4-1 中的 Counter 只有一个域 value，因此这个域就是 Counter 的全部状态。对于含有 n 个基本类型域的对象，其状态就是这些域构成的 n 元组。例如，二维点的状态就是它的坐标值 (x, y)。如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，LinkedList 的状态就包括该链表中所有节点对象的状态。</p><p>程序清单4-1 使用 Java 监视器模式的线程安全计数器</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">&quot;counter overflow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">++</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步策略（Synchronization Policy）定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。</p><h4 id="_4-1-1-收集同步需求" tabindex="-1"><a class="header-anchor" href="#_4-1-1-收集同步需求" aria-hidden="true">#</a> 4.1.1 收集同步需求</h4><p>要确保类的线程安全性，就需要确保它的不变性条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final 类型的域使用得越多，就越能简化对象可能状态的分析过程。（在极端的情况中，不可变对象只有唯一的状态。）</p><p>在许多类中都定义了一些不可变条件，用于判断状态是有效的还是无效的。Counter 中的 value 域是 long 类型的变量，其状态空间为从 Long.MIN_VALUE 到 Long.MAX_VALUE，但 Counter 中 value 在取值范围上存在着一个限制，即不能是负值。</p><p>同样，在操作中还会包含一些后验条件来判断状态迁移是否是有效的。如果 Counter 的当前状态为 17，那么下一个有效状态只能是 18。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量之前的状态并不会影响计算结果。</p><p>由于不变性条件以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装。如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。另外，如果在类中没有施加这种约束，那么就可以放宽封装性或序列化等需求，以便获得更高的灵活性或性能。</p><p>在类中也可以包含同时约束多个状态变量的不变性条件。在一个表示数值范围的类（例如程序清单4-10 中的 NumberRange）中可以包含两个状态变量，分别表示范围的上界和下界。这些变量必须遵循的约束是，下界值应该小于或等于上界值。类似于这种包含多个变量的不变性条件将带来原子性需求：这些相关的变量必须在单个原子操作中进行读取或更新。不能首先更新一个变量，然后释放锁并再次获得锁，然后再更新其他的变量。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。</p><p>如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。</p><h3 id="_4-1-2-依赖状态的操作" tabindex="-1"><a class="header-anchor" href="#_4-1-2-依赖状态的操作" aria-hidden="true">#</a> 4.1.2 依赖状态的操作</h3><p>类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（Precondition）。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处于 “非空的” 状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。</p><p>在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。</p><p>在 Java 中，等待某个条件为真的各种内置机制（包括等待和通知等机制）都与内置加锁机制紧密关联，要想正确地使用它们并不容易。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如阻塞队列[Blocking Queue]或信号量[Semaphore]）来实现依赖状态的行为。第 5 章将介绍一些阻塞类，例如 BlockingQueue、Semaphore 以及其他的同步工具类。第 14 章将介绍如何使用在平台与类库中提供的各种底层机制来创建依赖状态的类。</p><h3 id="_4-1-3-状态的所有权" tabindex="-1"><a class="header-anchor" href="#_4-1-3-状态的所有权" aria-hidden="true">#</a> 4.1.3 状态的所有权</h3><p>4.1 节曾指出，如果以某个对象为根节点构造一张对象图，那么该对象的状态将是对象图中所有对象包含的域的一个子集。为什么是一个 “子集”？在从对象可以达到的所有域中，需要满足哪些条件才不属于对象状态的一部分？</p><p>在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。所有权（Ownership）在 Java 中并没有得到充分的体现，而是属于类设计中的一个要素。如果分配并填充了一个 HashMap 对象，那么就相当于创建了多个对象：HashMap 对象，在 HashMap 对象中包含的多个对象，以及在 Map.Entry 中可能包含的内部对象。HashMap 对象的逻辑状态包括所有的 Map.Entry 对象以及内部对象，即使这些对象都是一些独立的对象。</p><p>无论如何，垃圾回收机制使我们避免了如何处理所有权的问题。在 C++ 中，当把一个对象传递给某个方法时，必须认真考虑这种操作是否传递对象的所有权，是短期的所有权还是长期的所有权。在 Java 中同样存在这些所有权模型，只不过垃圾回收器为我们减少了许多在引用共享方面常见的错误，因此降低了在所有权处理上的开销。</p><p>许多情况下，所有权与封装性总是相互关联的：对象封装它拥有的状态，反之也成立，即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁协议来维持变量状态的完整性。所有权意味着控制权。然而，如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是 “共享控制权”。对于从构造函数或者从方法中传递进来的对象，类通常并不拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权（例如，同步容器封装器的工厂方法）。</p><p>容器类通常表现出一种 “所有权分离” 的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。Servlet 框架中的 ServletContext 就是其中一个示例。ServletContext 为 Servlet 提供了类似于 Map 形式的对象容器服务，在 ServletContext 中可以通过名称来注册（setAttribute）或获取（getAttribute）应用程序对象。由 Servlet 容器实现的 ServletContext 对象必须是线程安全的，因为它肯定会被多个线程同时访问。当调用 setAttribute 和 getAttribute 时，Servlet 不需要使用同步，但当使用保存在 ServletContext 中的对象时，则可能需要使用同步。这些对象由应用程序拥有，Servlet 容器只是替应用程序保管它们。与所有共享对象一样，它们必须安全地被共享。为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变的对象，或者由锁来保护的对象。<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p><h2 id="_4-2-实例封闭" tabindex="-1"><a class="header-anchor" href="#_4-2-实例封闭" aria-hidden="true">#</a> 4.2 实例封闭</h2><p>如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护对该对象的所有访问。</p><p>封装简化了线程安全类的实现过程，它提供了一种实例封闭机制（Instance Confinement），通常也简称为 “封闭”[CPJ 2.3.3]。当一个对象被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。</p><p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p><p>被封闭对象一定不能超出它们既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是在多个线程之间共享该对象）。当然，对象本身不会逸出——出现逸出情况的原因通常是由于开发人员在发布对象时超出了对象既定的作用域。</p><p>程序清单4-2 中的 PersonSet 说明了如何通过封闭与加锁等机制使一个类成为线程安全的（即使这个类的状态变量并不是线程安全的）。PersonSet 的状态由 HashSet 来管理的，而 HashSet 并非线程安全的。但由于 mySet 是私有的并且不会逸出，因此 HashSet 被封闭在 PersonSet 中。唯一能访问 mySet 的代码路径是 addPerson 与 containsPerson，在执行它们时都要获得 PersonSet 上的锁。PersonSet 的状态完全由它的内置锁保护，因而 PersonSet 是一个线程安全的类。</p><p>程序清单4-2 通过封闭机制来确保线程安全</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonSet</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addPerson</span><span class="token punctuation">(</span><span class="token class-name">Person</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mySet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">containsPerson</span><span class="token punctuation">(</span><span class="token class-name">Person</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mySet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个示例并未对 Person 的线程安全性做任何假设，但如果 Person 类是可变的，那么在访问从 PersonSet 中获得的 Person 对象时，还需要额外的同步。要想安全地使用 Person 对象，最可靠的方法就是使 Person 成为一个线程安全的类。另外，也可以使用锁来保护 Person 对象，并确保所有客户代码在访问 Person 对象之前都已经获得正确的锁。</p><p>实例封闭是构建线程安全类的一个最简单方式，它还使得在锁策略的选择上拥有了更多的灵活性。在 PersonSet 中使用了它的内置锁来保护它的状态，但对于其他形式的锁来说，只要自始至终都使用同一个锁，就可以保护状态。实例封闭还使得不同的状态变量可以由不同的锁来保护（后面章节的 ServerStatus 中就使用了多个锁来保护类的状态）。</p><p>在 Java 平台的类库中还有很多线程封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。一些基本的容器类并非线程安全的，例如 ArrayList 和 HashMap，但类库提供了包装器工厂方法（例如 Collections.synchronizedList 及其类似方法），使得这些非线程安全的类可以在多线程环境中安全地使用。这些工厂方法通过 “装饰器（Decorator）” 模式（Gamma et al.，1995）将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。只要包装器对象拥有对底层容器对象的唯一引用（即把底层容器对象封闭在包装器中），那么它就是线程安全的。在这些方法的 Javadoc 中指出，对底层容器对象的所有访问必须通过包装器来进行。</p><p>当然，如果将一个本该被封闭的对象发布出去，那么也能破坏封闭性。如果一个对象本应该封闭在特定的作用域内，那么让该对象逸出作用域就是一个错误。当发布其他对象时，例如迭代器或内部的类实例，可能会间接地发布被封闭对象，同样会使被封闭对象逸出。</p><p>封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。</p><h3 id="_4-2-1-java-监视器模式" tabindex="-1"><a class="header-anchor" href="#_4-2-1-java-监视器模式" aria-hidden="true">#</a> 4.2.1 Java 监视器模式</h3><p>从线程封闭原则及其逻辑推论可以得出 Java 监视器模式<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。遵循 Java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。</p><p>在程序清单4-1 的 Counter 中给出了这种模式的一个典型示例。在 Counter 中封装了一个状态变量 value，对该变量的所有访问都需要通过 Counter 的方法来执行，并且这些方法都是同步的。</p><p>在许多类中都使用了 Java 监视器模式，例如 Vector 和 Hashtable。在某些情况下，程序需要一种更复杂的同步策略。第 11 章将介绍如何通过细粒度的加锁策略来提高可伸缩性。Java 监视器模式的主要优势就在于它的简单性。</p><p>Java 监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态。程序清单4-3 给出了如何使用私有锁来保护状态。</p><p>程序清单4-3 通过一个私有锁来保护状态</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrivateLock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> myLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;myLock&quot;</span><span class="token punctuation">)</span>
    <span class="token class-name">Widget</span> widget<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>myLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 访问或修改 Widget 的状态</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁），有许多优点。私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或者不正确地）参与到它的同步策略中。如果客户代码错误地获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个的类。</p><h3 id="_4-2-2-示例-车辆追踪" tabindex="-1"><a class="header-anchor" href="#_4-2-2-示例-车辆追踪" aria-hidden="true">#</a> 4.2.2 示例：车辆追踪</h3><p>程序清单4-1 中的 Counter 是一个简单但用处不大的 Java 监视器模式示例。我们来看一个更有用处的示例：一个用于调度车辆的 “车辆追踪器”，例如出租车、警车、货车等。首先使用监视器模式来构建车辆追踪器，然后再尝试放宽某些封装性需求同时又保持线程安全性。</p><p>每台车都由一个 String 对象来标识，并且拥有一个相应的位置坐标 (x, y)。在 VehicleTracker 类中封装了车辆的标识和位置，因而它非常适合作为基于 MVC（Model-View-Controller，模型-视图-控制器）模式的 GUI 应用程序中的数据模型，并且该模型将由一个视图线程和多个执行更新操作的线程共享。视图线程会读取车辆的名字和位置，并将它们显示在界面上：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> locations <span class="token operator">=</span> vehicles<span class="token punctuation">.</span><span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> locations<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">renderVehicle</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似地，执行更新操作的线程通过从 GPS 设备上获取的数据或者调度员从 GUI 界面上输入的数据来修改车辆的位置。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">vehicleMoved</span><span class="token punctuation">(</span><span class="token class-name">VehicleMovedEvent</span> evt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Point</span> loc <span class="token operator">=</span> evt<span class="token punctuation">.</span><span class="token function">getNewLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vehicles<span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span><span class="token function">getVehicleId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loc<span class="token punctuation">.</span>x<span class="token punctuation">,</span> loc<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>视图线程与执行更新操作的线程将并发地访问数据模型，因此该模型必须是线程安全的。程序清单4-4 给出了一个基于 Java 监视器模式实现的 “车辆追踪器”，其中使用了程序清单4-5 中的 MutablePoint 来表示车辆的位置。</p><p>程序清单4-4 基于监视器模式的车辆追踪</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MonitorVehicleTracker</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> locations<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MonitorVehicleTracker</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> locations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>locations <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>locations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> <span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>locations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">MutablePoint</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MutablePoint</span> loc <span class="token operator">=</span> locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> loc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MutablePoint</span> loc <span class="token operator">=</span> locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loc <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;No such ID:&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        loc<span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        loc<span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> id <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
            result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MutablePoint</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
    程序清单4-5
    */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然类 MutablePoint 不是线程安全的，但追踪器类是线程安全的。它所包含的 Map 对象和可变的 Point 对象都未曾发布。当需要返回车辆的位置时，通过 MutablePoint 拷贝构造函数或者 deepCopy 方法来复制正确的值，从而生成一个新的 Map 对象，并且该对象中的值与原有 Map 对象中的 key 值和 value 值都相同。<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></p><p>程序清单4-5 与 Java.awt.Point 类似的可变 Point 类（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@NotThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MutablePoint</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">MutablePoint</span><span class="token punctuation">(</span><span class="token class-name">MutablePoint</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> p<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在某种程度上，这种实现方式是通过在返回客户代码之前复制可变的数据来维持线程安全性的。通常情况下，这并不存在性能问题，但在车辆容器非常大的情况下将极大地降低性能<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>。此外，由于每次调用 getLocation 就要复制数据，因此将出现一种错误情况——虽然车辆的实际位置发生了变化，但返回的信息却保持不变。这种情况是好还是坏，要取决于你的需求。如果在 location 集合上存在内部的一致性需求，那么这就是优点，在这种情况下返回一致的快照就非常重要。然而，如果调用者需要每辆车的最新信息，那么这就是缺点，因为这需要非常频繁地刷新快照。</p><h2 id="_4-3-线程安全性的委托" tabindex="-1"><a class="header-anchor" href="#_4-3-线程安全性的委托" aria-hidden="true">#</a> 4.3 线程安全性的委托</h2><p>大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java 监视器模式是非常有用的。但是，如果类中的各个组件都已经是线程安全的，会是什么情况呢？我们是否需要再增加一个额外的线程安全层？答案是 “视情况而定”。在某些情况下，通过多个线程安全类组合而成的类是线程安全的（如程序清单4-7 和程序清单4-9 所示），而在某些情况下，这仅仅是一个好的开端（如程序清单4-10 所示）。</p><p>在前面的 CountingFactorizer 类中，我们在一个无状态的类中增加了一个 AtomicLong 类型的域，并且得到的组合对象仍然是线程安全的。由于 CountingFactorizer 的状态就是 AtomicLong 的状态，而 AtomicLong 是线程安全的，因此 CountingFactorizer 不会对 counter 的状态施加额外的有效性约束，所以很容易知道 CountingFactorizer 是线程安全的。我们可以说 CountingFactorizer 将它的线程安全性委托给 AtomicLong 来保证：之所以 CountingFactorizer 是线程安全的，是因为 AtomicLong 是线程安全的。<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup></p><h3 id="_4-3-1-示例-基于委托的车辆追踪器" tabindex="-1"><a class="header-anchor" href="#_4-3-1-示例-基于委托的车辆追踪器" aria-hidden="true">#</a> 4.3.1 示例：基于委托的车辆追踪器</h3><p>下面将介绍一个更实际的委托示例，构造一个委托给线程安全类的车辆追踪器。我们将车辆的位置保存到一个 Map 对象中，因此首先要实现一个线程安全的 Map 类，ConcurrentHashMap。我们还可以用一个不可变的 Point 类来代替 MutablePoint 以保存位置，如程序清单4-6 所示。</p><p>程序清单4-6 在 DelegatingVehicleTracker 中使用的不可变 Point 类</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Immutable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 Point 类是不可变的，因而它是线程安全的。不可变的值可以被自由地共享与发布，因此在返回 location 时不需要复制。</p><p>在程序清单4-7 的 DelegatingVehicleTracker 中没有使用任何显式的同步，所有对状态的访问都由 ConcurrentHashMap 来管理，而且 Map 所有的键和值都是不可变的。</p><p>程序清单4-7 将线程安全委托给 ConcurrentHashMap</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelegatingVehicleTracker</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> locations<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> unmodifiableMap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DelegatingVehicleTracker</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> points<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        locations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">;</span>
        unmodifiableMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifableMap</span><span class="token punctuation">(</span>locations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> <span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unmodifiableMap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Point</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>locations<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;invalid vehicle name:&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用最初的 MutablePoint 类而不是 Point 类，就会破坏封装性，因为 getLocations 会发布一个指向可变状态的引用，而这个引用不是线程安全的。需要注意的是，我们稍微改变了车辆追踪器类的行为。在使用监视器模式的车辆追踪器中返回的是车辆位置的快照，而在使用委托的车辆追踪器中返回的是一个不可修改但却实时的车辆位置视图。这意味着，如果线程 A 调用 getLocations，而线程 B 在随后修改了某些点的位置，那么在返回给线程 A 的 Map 中将反映出这些变化。在前面提到过，这可能是一种优点（更新的数据），也可能是一种缺点（可能导致不一致的车辆位置视图），具体情况取决于你的需求。</p><p>如果需要一个不发生变化的车辆视图，那么 getLocations 可以返回对 locations 这个 Map 对象的一个浅拷贝（Shallow Copy）。由于 Map 的内容是不可变的，因此只需复制 Map 的结构，而不用复制它的内容，如程序清单4-8 所示（其中只返回一个 HashMap，因为 getLocations 并不能保证返回一个线程安全的 Map）。</p><p>程序清单4-8　返回 locations 的静态拷贝而非实时拷贝</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span> <span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Point</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>locations<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-2-独立的状态变量" tabindex="-1"><a class="header-anchor" href="#_4-3-2-独立的状态变量" aria-hidden="true">#</a> 4.3.2 独立的状态变量</h3><p>到目前为止，这些委托示例都仅仅委托给了单个线程安全的状态变量。我们还可以将线程安全性委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。</p><p>程序清单4-9 中的 VisualComponent 是一个图形组件，允许客户程序注册监控鼠标和键盘等事件的监听器。它为每种类型的事件都备有一个已注册监听器列表，因此当某个事件发生时，就会调用相应的监听器。然而，在鼠标事件监听器与键盘事件监听器之间不存在任何关联，二者是彼此独立的，因此 VisualComponent 可以将其线程安全性委托给这两个线程安全的监听器列表。</p><p>程序清单4-9 将线程安全性委托给多个状态变量</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VisualComponent</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">KeyListener</span><span class="token punctuation">&gt;</span></span> keyListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">KeyListener</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MouseListener</span><span class="token punctuation">&gt;</span></span> mouseListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MouseListener</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addKeyListener</span><span class="token punctuation">(</span><span class="token class-name">KeyListener</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        keyListeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addMouseListener</span><span class="token punctuation">(</span><span class="token class-name">MouseListener</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mouseListeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeKeyListener</span><span class="token punctuation">(</span><span class="token class-name">KeyListener</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        keyListeners<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMouseListener</span><span class="token punctuation">(</span><span class="token class-name">MouseListener</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mouseListeners<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>VisualComponent 使用 CopyOnWriteArrayList 来保存各个监听器列表。它是一个线程安全的链表，特别适用于管理监听器列表（参见 5.2.3 节）。每个链表都是线程安全的，此外，由于各个状态之间不存在耦合关系，因此 VisualComponent 可以将它的线程安全性委托给 mouseListeners 和 keyListeners 等对象。</p><h3 id="_4-3-3-当委托失效时" tabindex="-1"><a class="header-anchor" href="#_4-3-3-当委托失效时" aria-hidden="true">#</a> 4.3.3 当委托失效时</h3><p>大多数组合对象都不会像 VisualComponent 这样简单：在它们的状态变量之间存在着某些不变性条件。程序清单4-10 中的 NumberRange 使用了两个 AtomicInteger 来管理状态，并且含有一个约束条件，即第一个数值要小于或等于第二个数值。</p><p>程序清单4-10 NumberRange 类并不足以保护它的不变性条件（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NumberRange</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不变性条件: lower &lt;= upper</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> lower <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> upper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLower</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注意——不安全的 “先检查后执行”</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> upper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;can&#39;t set lower to&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;&gt; upper&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lower<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUpper</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注意——不安全的 “先检查后执行”</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;can&#39;t set upper to&quot;</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">&quot;&lt; lower&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        upper<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isInRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> upper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>NumberRange 不是线程安全的，没有维持对下界和上界进行约束的不变性条件。setLower 和 setUpper 等方法都尝试维持不变性条件，但却无法做到。setLower 和 setUpper 都是 “先检查后执行” 的操作，但它们没有使用足够的加锁机制来保证这些操作的原子性。假设取值范围为 (0, 10)，如果一个线程调用 setLower(5)，而另一个线程调用 setUpper(4)，那么在一些错误的执行时序中，这两个调用都将通过检查，并且都能设置成功。结果得到的取值范围就是 (5, 4)，那么这是一个无效的状态。因此，虽然 AtomicInteger 是线程安全的，但经过组合得到的类却不是。由于状态变量 lower 和 upper 不是彼此独立的，因此 NumberRange 不能将线程安全性委托给它的线程安全状态变量。</p><p>NumberRange 可以通过加锁机制来维护不变性条件以确保其线程安全性，例如使用一个锁来保护 lower 和 upper。此外，它还必须避免发布 lower 和 upper，从而防止客户代码破坏其不变性条件。</p><p>如果某个类含有复合操作，例如 NumberRange，那么仅靠委托并不足以实现线程安全性。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。</p><p>如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。</p><p>即使 NumberRange 的各个状态组成部分都是线程安全的，也不能确保 NumberRange 的线程安全性，这种问题非常类似于 3.1.4 节介绍的 volatile 变量规则：仅当一个变量参与到包含其他状态变量的不变性条件时，才可以声明为 volatile 类型。</p><h3 id="_4-3-4-发布底层的状态变量" tabindex="-1"><a class="header-anchor" href="#_4-3-4-发布底层的状态变量" aria-hidden="true">#</a> 4.3.4 发布底层的状态变量</h3><p>当把线程安全性委托给某个对象的底层状态变量时，在什么条件下才可以发布这些变量从而使其他类能修改它们？答案仍然取决于在类中对这些变量施加了哪些不变性条件。虽然 Counter 中的 value 域可以为任意整数值，但 Counter 施加的约束条件是只能取正整数，此外递增操作同样约束了下一个状态的有效取值范围。如果将 value 声明为一个公有域，那么客户代码可以将它修改为一个无效值，因此发布 value 会导致这个类出错。另一方面，如果某个变量表示的是当前温度或者最近登录用户的 ID，那么即使另一个类在某个时刻修改了这个值，也不会破坏任何不变性条件，因此发布这个变量也是可以接受的（这或许不是个好主意，因为发布可变的变量将对下一步的开发和派生子类带来限制，但不会破坏类的线程安全性）。</p><p>如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。</p><p>例如，发布 VisualComponent 中的 mouseListeners 或 keyListeners 等变量就是安全的。由于 VisualComponent 并没有在其监听器链表的合法状态上施加任何约束，因此这些域可以声明为公有域或者发布，而不会破坏线程安全性。</p><h3 id="_4-3-5-示例-发布状态的车辆追踪器" tabindex="-1"><a class="header-anchor" href="#_4-3-5-示例-发布状态的车辆追踪器" aria-hidden="true">#</a> 4.3.5 示例：发布状态的车辆追踪器</h3><p>我们来构造车辆追踪器的另一个版本，并在这个版本中发布底层的可变状态。我们需要修改接口以适应这种变化，即使用可变且线程安全的 Point 类。</p><p>程序清单4-11 中的 SafePoint 提供的 get 方法同时获得 x 和 y 的值，并将二者放在一个数组中返回<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>。如果为 x 和 y 分别提供 get 方法，那么在获得这两个不同坐标的操作之间，x 和 y 的值发生变化，从而导致调用者看到不一致的值：车辆从来没有到达过位置 (x, y)。通过使用 SafePoint，可以构造一个发布其底层可变状态的车辆追踪器，还能确保其线程安全性不被破坏，如程序清单4-12 中的 PublishingVehicleTracker 类所示。</p><p>程序清单4-11 线程安全且可变的 Point 类</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SafePoint</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">SafePoint</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">SafePoint</span><span class="token punctuation">(</span><span class="token class-name">SafePoint</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">SafePoint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序清单4-12 安全发布底层状态的车辆追踪器</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublishingVehicleTracker</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SafePoint</span><span class="token punctuation">&gt;</span></span> locations<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SafePoint</span><span class="token punctuation">&gt;</span></span> unmodifiableMap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PublishingVehicleTracker</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SafePoint</span><span class="token punctuation">&gt;</span></span> locations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>locations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SafePoint</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>locations<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>unmodifiableMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>locations<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">SafePoint</span><span class="token punctuation">&gt;</span></span> <span class="token function">getLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unmodifiableMap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">SafePoint</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>locations<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;invalid vehicle name:&quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        locations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PublishingVehicleTracker 将其线程安全性委托给底层的 ConcurrentHashMap，只是 Map 中的元素是线程安全的且可变的 Point，而并非不可变的。getLocation 方法返回底层 Map 对象的一个不可变副本。调用者不能增加或删除车辆，但却可以通过修改返回 Map 中的 SafePoint 值来改变车辆的位置。再次指出，Map 的这种 “实时” 特性究竟是带来好处还是坏处，仍然取决于实际的需求。PublishingVehicleTracker 是线程安全的，但如果它在车辆位置的有效值上施加了任何约束，那么就不再是线程安全的。如果需要对车辆位置的变化进行判断或者当位置变化时执行一些操作，那么 PublishingVehicleTracker 中采用的方法并不合适。</p><h2 id="_4-4-在现有的线程安全类中添加功能" tabindex="-1"><a class="header-anchor" href="#_4-4-在现有的线程安全类中添加功能" aria-hidden="true">#</a> 4.4 在现有的线程安全类中添加功能</h2><p>Java 类库包含许多有用的 “基础模块” 类。通常，我们应该优先选择重用这些现有的类而不是创建新的类：重用能降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。有时候，某个现有的线程安全类能支持我们需要的所有操作，但更多时候，现有的类只能支持大部分的操作，此时就需要在不破坏线程安全性的情况下添加一个新的操作。</p><p>例如，假设需要一个线程安全的链表，它需要提供一个原子的 “若没有则添加（Put-If-Absent）” 的操作。同步的 List 类已经实现了大部分的功能，我们可以根据它提供的 contains 方法和 add 方法来构造一个 “若没有则添加” 的操作。</p><p>“若没有则添加” 的概念很简单，在向容器中添加元素前，首先检查该元素是否已经存在，如果存在就不再添加。（回想 “先检查再执行” 的注意事项。）由于这个类必须是线程安全的，因此就隐含地增加了另一个需求，即 “若没有则添加” 这个操作必须是原子操作。这意味着，如果在链表中没有包含对象 X，那么在执行两次 “若没有则添加” X 后，在容器中只能包含一个 X 对象。然而，如果 “若没有则添加” 操作不是原子操作，那么在某些执行情况下，有两个线程都将看到 X 不在容器中，并且都执行了添加 X 的操作，从而使容器中包含两个相同的 X 对象。</p><p>要添加一个新的原子操作，最安全的方法是修改原始的类，但这通常无法做到，因为你可能无法访问或修改类的源代码。要想修改原始的类，就需要理解代码中的同步策略，这样增加的功能才能与原有的设计保持一致。如果直接将新方法添加到类中，那么意味着实现同步策略的所有代码仍然处于一个源代码文件中，从而更容易理解与维护。</p><p>另一种方法是扩展这个类，假定在设计这个类时考虑了可扩展性。程序清单4-13 中的 BetterVector 对 Vector 进行了扩展，并添加了一个新方法 putIfAbsent。扩展 Vector 很简单，但并非所有的类都像 Vector 那样将状态向子类公开，因此也就不适合采用这种方法。</p><p>程序清单4-13 扩展 Vector 并增加一个 “若没有则添加” 方法</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BetterVector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> absent <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>absent<span class="token punctuation">)</span> 
            <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> absent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“扩展” 方法比直接将代码添加到类中更加脆弱，因为现在的同步策略实现被分布到多个单独维护的源代码文件中。如果底层的类改变了同步策略并选择了不同的锁来保护它的状态变量，那么子类会被破坏，因为在同步策略改变后它无法再使用正确的锁来控制对基类状态的并发访问。（在 Vector 的规范中定义了它的同步策略，因此 BetterVector 不存在这个问题。）</p><h3 id="_4-4-1-客户端加锁机制" tabindex="-1"><a class="header-anchor" href="#_4-4-1-客户端加锁机制" aria-hidden="true">#</a> 4.4.1 客户端加锁机制</h3><p>对于由 Collections.synchronizedList 封装的 ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，因为客户代码并不知道在同步封装器工厂方法中返回的 List 对象的类型。第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个 “辅助类” 中。</p><p>程序清单4-14 实现了一个包含 “若没有则添加” 操作的辅助类，用于对线程安全的 List 执行操作，但其中的代码是错误的。</p><p>程序清单4-14 非线程安全的 “若没有则添加”（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@NotThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListHelper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//......</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> absent <span class="token operator">=</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>absent<span class="token punctuation">)</span> 
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> absent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么这种方式不能实现线程安全性？毕竟，putIfAbsent 已经声明为 synchronized 类型的变量，对不对？问题在于在错误的锁上进行了同步。无论 List 使用哪一个锁来保护它的状态，可以确定的是，这个锁并不是 ListHelper 上的锁。ListHelper 只是带来了同步的假象，尽管所有的链表操作都被声明为 synchronized，但却使用了不同的锁，这意味着 putIfAbsent 相对于 List 的其他操作来说并不是原子的，因此就无法确保当 putIfAbsent 执行时另一个线程不会修改链表。</p><p>要想使这个方法能正确执行，必须使 List 在实现客户端加锁或外部加锁时使用同一个锁。客户端加锁是指，对于使用某个对象 X 的客户端代码，使用 X 本身用于保护其状态的锁来保护这段客户代码。要使用客户端加锁，你必须知道对象 X 使用的是哪一个锁。</p><p>在 Vector 和同步封装器类的文档中指出，它们通过使用 Vector 或封装器容器的内置锁来支持客户端加锁。程序清单4-15 给出了在线程安全的 List 上执行 putIfAbsent 操作，其中使用了正确的客户端加锁。</p><p>程序清单4-15 通过客户端加锁来实现 “若没有则添加”</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListHelper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ......</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">boolean</span> absent <span class="token operator">=</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>absent<span class="token punctuation">)</span> 
                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> absent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过添加一个原子操作来扩展类是脆弱的，因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱，因为它将类 C 的加锁代码放到与 C 完全无关的其他类中。当在那些并不承诺遵循加锁策略的类上使用客户端加锁时，要特别小心。</p><p>客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起。正如扩展会破坏实现的封装性[EJ Item 14]，客户端加锁同样会破坏同步策略的封装性。</p><h3 id="_4-4-2-组合" tabindex="-1"><a class="header-anchor" href="#_4-4-2-组合" aria-hidden="true">#</a> 4.4.2 组合</h3><p>当为现有的类添加一个原子操作时，有一种更好的方法：组合（Composition）。程序清单4-16 中的 ImprovedList 通过将 List 对象的操作委托给底层的 List 实例来实现 List 的操作，同时还添加了一个原子的 putIfAbsent 方法。（与 Collections.synchronizedList 和其他容器封装器一样，ImprovedList 假设把某个链表对象传给构造函数以后，客户代码不会再直接使用这个对象，而只能通过 ImprovedList 来访问它。）</p><p>程序清单4-16 通过组合实现“若没有则添加”</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImprovedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ImprovedList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> contains <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>contains<span class="token punctuation">)</span> 
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">!</span>contains<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... 按照类似的方式委托 List 的其他方法</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ImprovedList 通过自身的内置锁增加了一层额外的加锁。它并不关心底层的 List 是否是线程安全的，即使 List 不是线程安全的或者修改了它的加锁实现，ImprovedList 也会提供一致的加锁机制来实现线程安全性。虽然额外的同步层可能导致轻微的性能损失<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>，但与模拟另一个对象的加锁策略相比，ImprovedList 更为健壮。事实上，我们使用了 Java 监视器模式来封装现有的 List，并且只要在类中拥有指向底层 List 的唯一外部引用，就能确保线程安全性。</p><h2 id="_4-5-将同步策略文档化" tabindex="-1"><a class="header-anchor" href="#_4-5-将同步策略文档化" aria-hidden="true">#</a> 4.5 将同步策略文档化</h2><p>在维护线程安全性时，文档是最强大的（同时也是最未被充分利用的）工具之一。用户可以通过查阅文档来判断某个类是否是线程安全的，而维护人员也可以通过查阅文档来理解其中的实现策略，避免在维护过程中破坏安全性。然而，通常人们从文档中获取的信息却是少之又少。</p><p>在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。</p><p>synchronized、volatile 或者任何一个线程安全类都对应于某种同步策略，用于在并发访问时确保数据的完整性。这种策略是程序设计的要素之一，因此应该将其文档化。当然，设计阶段是编写设计决策文档的最佳时间。这之后的几周或几个月后，一些设计细节会逐渐变得模糊，因此一定要在忘记之前将它们记录下来。</p><p>在设计同步策略时需要考虑多个方面，例如，将哪些变量声明为 volatile 类型，哪些变量用锁来保护，哪些锁保护哪些变量，哪些变量必须是不可变的或者被封闭在线程中的，哪些操作必须是原子操作等。其中某些方面是严格的实现细节，应该将它们文档化以便于日后的维护。还有一些方面会影响类中加锁行为的外在表现，也应该将其作为规范的一部分写入文档。</p><p>最起码，应该保证将类中的线程安全性文档化。它是否是线程安全的？在执行回调时是否持有一个锁？是否有某些特定的锁会影响其行为？不要让客户冒着风险去猜测。如果你不想支持客户端加锁也是可以的，但一定要明确地指出来。如果你希望客户代码能够在类中添加新的原子操作，如 4.4 节所示，那么就需要在文档中说明需要获得哪些锁才能实现安全的原子操作。如果使用锁来保护状态，那么也要将其写入文档以便日后维护，这很简单，只需使用标注 @GuardedBy 即可。如果要使用更复杂的方法来维护线程安全性，那么一定要将它们写入文档，因为维护者通常很难发现它们。</p><p>甚至在平台的类库中，线程安全性方面的文档也是很难令人满意。当你阅读某个类的 Javadoc 时，是否曾怀疑过它是否是线程安全的？<sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup>大多数类都没有给出任何提示。许多正式的 Java 技术规范，例如 Servlet 和 JDBC，也没有在它们的文档中给出线程安全性的保证和需求。</p><p>尽管我们不应该对规范之外的行为进行猜测，但有时候出于工作需要，将不得不面对各种糟糕的假设。我们是否应该因为某个对象看上去是线程安全的而就假设它是安全的？是否可以假设通过获取对象的锁来确保对象访问的线程安全性？（只有当我们能控制所有访问该对象的代码时，才能使用这种带风险的技术，否则，这只能带来线程安全性的假象。）无论做出哪种选择都难以令人满意。</p><p>更糟糕的是，我们的直觉通常是错误的：我们认为 “可能是线程安全“ 的类通常并不是线程安全的。例如，java.text.SimpleDateFormat 并不是线程安全的，但 JDK l.4 之前的 Javadoc 并没有提到这点。许多开发人员都对这个类不是线程安全的而感到惊讶。有多少程序已经错误地生成了这种非线程安全的对象，并在多线程中使用它？这些程序没有意识到这将在高负载的情况下导致错误的结果。</p><p>如果某个类没有明确地声明是线程安全的，那么就不要假设它是线程安全的，从而有效地避免类似于 SimpleDateFormat 的问题。而另一方面，如果不对容器提供对象（例如 HttpSession）的线程安全性做某种有问题的假设，也就不可能开发出一个基于 Servlet 的应用程序。不要使你的客户或同事也做这样的猜测。</p><p><strong>解释含糊的文档</strong></p><p>许多 Java 技术规范都没有（或者至少不愿意）说明接口的线程安全性，例如 ServletContext、HttpSession 或 DataSource<sup class="footnote-ref"><a href="#footnote9">[9]</a><a class="footnote-anchor" id="footnote-ref9"></a></sup>。这些接口是由容器或数据库供应商来实现的，而你通常无法通过查看其实现代码来了解细节功能。此外，你也不希望依赖于某个特定 JDBC 驱动的实现细节——你希望遵从标准，这样代码可以基于任何一个 JDBC 驱动工作。但在 JDBC 的规范中从未出现 “线程” 和 “并发” 这些术语，同样在 Servlet 规范中也很少提到。那么你该做些什么呢？</p><p>你只能去猜测。一个提高猜测准确性的方法是，从实现者（例如容器或数据库的供应商）的角度去解释规范，而不是从使用者的角度去解释。Servlet 通常是在容器管理的（Container-Managed）线程中调用的，因此可以安全地假设：如果有多个这种线程在运行，那么容器是知道这种情况的。Servlet 容器能生成一些为多个 Servlet 提供服务的对象，例如 HttpSession 或 ServletContext。因此，Servlet 容器应该预见到这些对象将被并发访问，因为它创建了多个线程，并且从这些线程中调用像 Servlet.service 这样的方法，而这个方法很可能会访问 ServletContext。</p><p>由于这些对象在单线程的上下文中很少是有用的，因此我们不得不假设它们已被实现为线程安全的，即使在规范中没有明确地说明。此外，如果它们需要客户端加锁，那么客户端代码应该在哪个锁上进行同步？在文档中没有说明这一点，而要猜测的话也不知从何猜起。在规范和正式手册中给出的如何访问 ServletContext 或 HttpSession 的示例中进一步强调了这种 “合理的假设”，并且没有使用任何客户端同步。</p><p>另一方面，通过把 setAttribute 放到 ServletContext 中或者将 HttpSession 的对象由 Web 应用程序拥有，而不是 Servlet 容器拥有。在 Serviet 规范中没有给出任何机制来协调对这些共享属性的并发访问。因此，由容器代替 Web 应用程序来保存这些属性应该是线程安全的，或者是不可变的。如果容器的工作只是代替 Web 应用程序来保存这些属性，那么当从 servlet 应用程序代码访问它们时，应该确保它们始终由同一个锁保护。但由于容器可能需要序列化 HttpSession 中的对象以实现复制或钝化等操作，并且容器不可能知道你的加锁协议，因此你要自己确保这些对象是线程安全的。</p><p>可以对 JDBC DataSource 接口做出类似的推断，该接口表示一个可重用的数据库连接池。DataSource 为应用程序提供服务，它在单线程应用程序中没有太大意义。我们很难想象不在多线程情况下使用 getConnection。并且，与 Servlet 一样，在使用 DataSource 的许多示例代码中，JDBC 规范并没有说明需要使用任何客户端加锁。因此，尽管 JDBC 规范没有说明 DataSource 是否是线程安全的，或者要求生产商提供线程安全的实现，但同样由于 “如果不这么做将是不可思议的”，所以我们只能假设 DataSource.getConnection 不需要额外的客户端加锁。</p><p>另一方面，在 DataSource 分配 JDBC Connection 对象上没有这样的争议，因为在它们返回连接池之前，不会有其他操作将它们共享。因此，如果某个获取 JDBC Connection 对象的操作跨越了多个线程，那么它必须通过同步来保护对 Connection 对象的访问。（大多数应用程序在实现使用 JDBC Connection 对象的操作时，通常都会把 Connection 对象封闭在某个特定的线程中。）</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>需要注意的是，虽然 HttpSession 对象在功能上类似于 Servlet 框架，但可能有着更严格的要求。由于 Servlet 容器可能需要访问 HttpSession 中的对象，以便在复制操作或者钝化操作（Passivation，指的是将状态保存到持久性存储）中对它们序列化，因此这些对象必须是线程安全的，因为容器可能与 Web Application 程序同时访问它们。（之所以说 “可能”，是因为在 Servlet 的规范中并没有明确定义复制与钝化等操作，这只是大多数 Servlet 容器的一个常见功能。） <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>虽然 Java 监视器模式来自于 Hoare 对监视器机制的研究工作（Hoare，1974），但这种模式与真正的监视器类之间存在一些重要的差异。进入和退出同步代码块的字节指令也称为 monitorenter 和 monitorexit，而 Java 的内置锁也称为监视器锁或监视器。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>注意，deepCopy 并不只是用 unmodifiableMap 来包装 Map 的，因为这只能防止容器对象被修改，而不能防止调用者修改保存在容器中的可变对象。基于同样的原因，如果只是通过拷贝构造函数来填充 deepCopy 中的 HashMap，那么同样是不正确的，因为这样做只复制了指向 Point 对象的引用，而不是 Point 对象本身。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>由于 deepCopy 是从一个 synchronized 方法中调用的，因此在执行时间较长的复制操作中，tracker 的内置锁将一直被占有，当有大量车辆需要追踪时，会严重降低用户界面的响应灵敏度。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>如果 count 不是 final 类型，那么要分析 CountingFactorizer 的线程安全性将变得更复杂。如果 CountingFactorizer 将 count 修改为指向另一个 AtomicLong 域的引用，那么必须确保 count 的更新操作对于所有访问 count 的线程都是可见的，并且还要确保在 count 的值上不存在竞态条件。这也是尽可能使用 final 类型域的另一个原因。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p>如果将拷贝构造函数实现为 this(p.x, p.y)，那么会产生竞态条件，而私有构造函数则可以避免这种竞态条件。这是私有构造函数捕获模式（Private Constructor Capture Idiom, Bloch and Gafter，2005）的一个实例。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li><li id="footnote7" class="footnote-item"><p>性能损失很小，因为在底层 List 上的同步不存在竞争，所以速度很快，请参见第 11 章。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p></li><li id="footnote8" class="footnote-item"><p>如果你从未考虑过这些问题，那么你确实比较乐观。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p></li><li id="footnote9" class="footnote-item"><p>令我们失望的是，在多次对规范的修订中一直都忽略了这些问题。 <a href="#footnote-ref9" class="footnote-backref">↩︎</a></p></li></ol></section></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Java并发编程实战/第4章对象的组合.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/28 下午9:05:06</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC3%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html" class="nav-link prev" aria-label="第 3 章 对象的共享"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 3 章 对象的共享</div></a><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC5%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97.html" class="nav-link next" aria-label="第 5 章 基础构建模块"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 5 章 基础构建模块<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
