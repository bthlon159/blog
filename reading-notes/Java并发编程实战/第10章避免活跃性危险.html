<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 10 章 避免活跃性危险"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-07-28T13:05:06.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-07-28T13:05:06.000Z"><title>第 10 章 避免活跃性危险 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link active" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java 并发编程实战</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E4%BB%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 简介"><!---->第 1 章 简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第一部分 基础知识</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 线程安全"><!---->第 2 章 线程安全<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC3%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 对象的共享"><!---->第 3 章 对象的共享<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 对象的组合"><!---->第 4 章 对象的组合<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC5%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 基础构建模块"><!---->第 5 章 基础构建模块<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 结构化并发应用程序</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC6%E7%AB%A0%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 任务执行"><!---->第 6 章 任务执行<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC7%E7%AB%A0%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 取消与关闭"><!---->第 7 章 取消与关闭<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC8%E7%AB%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 线程池的使用"><!---->第 8 章 线程池的使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC9%E7%AB%A0%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 图形用户界面应用程序"><!---->第 9 章 图形用户界面应用程序<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第三部分 活跃性、性能与测试</span><!----></p><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 10 章 避免活跃性危险"><!---->第 10 章 避免活跃性危险<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1 死锁"><!---->10.1 死锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-1-锁顺序死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1.1 锁顺序死锁"><!---->10.1.1 锁顺序死锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-2-动态的锁顺序死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1.2 动态的锁顺序死锁"><!---->10.1.2 动态的锁顺序死锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-3-在协作对象之间发生的死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1.3 在协作对象之间发生的死锁"><!---->10.1.3 在协作对象之间发生的死锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-4-开放调用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1.4 开放调用"><!---->10.1.4 开放调用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-5-资源死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.1.5 资源死锁"><!---->10.1.5 资源死锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-死锁的避免与诊断" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.2 死锁的避免与诊断"><!---->10.2 死锁的避免与诊断<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-1-支持定时的锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.2.1 支持定时的锁"><!---->10.2.1 支持定时的锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-2-通过线程转储信息来分析死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.2.2 通过线程转储信息来分析死锁"><!---->10.2.2 通过线程转储信息来分析死锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-其他活跃性危险" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.3 其他活跃性危险"><!---->10.3 其他活跃性危险<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-1-饥饿" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.3.1 饥饿"><!---->10.3.1 饥饿<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-2-糟糕的响应性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.3.2 糟糕的响应性"><!---->10.3.2 糟糕的响应性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-3-活锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10.3.3 活锁"><!---->10.3.3 活锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC11%E7%AB%A0%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 性能与可伸缩性"><!---->第 11 章 性能与可伸缩性<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC12%E7%AB%A0%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%8B%E8%AF%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 并发程序的测试"><!---->第 12 章 并发程序的测试<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 高级主题</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC13%E7%AB%A0%E6%98%BE%E5%BC%8F%E9%94%81.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 显式锁"><!---->第 13 章 显式锁<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC14%E7%AB%A0%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 14 章 构建自定义的同步工具"><!---->第 14 章 构建自定义的同步工具<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC15%E7%AB%A0%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 15 章 原子变量与非阻塞同步机制"><!---->第 15 章 原子变量与非阻塞同步机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC16%E7%AB%A0Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 16 章 Java 内存模型简介"><!---->第 16 章 Java 内存模型简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 10 章 避免活跃性危险</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月1日</span><meta property="datePublished" content="2022-07-01T01:25:00.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 30 分钟</span><meta property="timeRequired" content="PT30M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年7月1日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 9146 字</span><meta property="wordCount" content="9146"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-死锁" class="router-link-active router-link-exact-active toc-link level2">10.1 死锁</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-1-锁顺序死锁" class="router-link-active router-link-exact-active toc-link level3">10.1.1 锁顺序死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-2-动态的锁顺序死锁" class="router-link-active router-link-exact-active toc-link level3">10.1.2 动态的锁顺序死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-3-在协作对象之间发生的死锁" class="router-link-active router-link-exact-active toc-link level3">10.1.3 在协作对象之间发生的死锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-4-开放调用" class="router-link-active router-link-exact-active toc-link level3">10.1.4 开放调用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-1-5-资源死锁" class="router-link-active router-link-exact-active toc-link level3">10.1.5 资源死锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-死锁的避免与诊断" class="router-link-active router-link-exact-active toc-link level2">10.2 死锁的避免与诊断</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-1-支持定时的锁" class="router-link-active router-link-exact-active toc-link level3">10.2.1 支持定时的锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-2-2-通过线程转储信息来分析死锁" class="router-link-active router-link-exact-active toc-link level3">10.2.2 通过线程转储信息来分析死锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-其他活跃性危险" class="router-link-active router-link-exact-active toc-link level2">10.3 其他活跃性危险</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-1-饥饿" class="router-link-active router-link-exact-active toc-link level3">10.3.1 饥饿</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-2-糟糕的响应性" class="router-link-active router-link-exact-active toc-link level3">10.3.2 糟糕的响应性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC10%E7%AB%A0%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9.html#_10-3-3-活锁" class="router-link-active router-link-exact-active toc-link level3">10.3.3 活锁</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-10-章-避免活跃性危险" tabindex="-1"><a class="header-anchor" href="#第-10-章-避免活跃性危险" aria-hidden="true">#</a> 第 10 章 避免活跃性危险</h1><p>在安全性与活跃性之间通常存在着某种制衡。我们使用加锁机制来确保线程安全，但如果过度地使用加锁，则可能导致锁顺序死锁（Lock-Ordering Deadlock）。同样，我们使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能会导致资源死锁（Resource Deadlock）。Java 应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁出现的条件。本章将介绍一些导致活跃性故障的原因，以及如何避免它们。</p><h2 id="_10-1-死锁" tabindex="-1"><a class="header-anchor" href="#_10-1-死锁" aria-hidden="true">#</a> 10.1 死锁</h2><p>经典的 “哲学家进餐” 问题很好地描述了死锁状况。5 个哲学家去吃中餐，坐在一张圆桌旁。他们有 5 根筷子（而不是 5 双），并且每两个人中间放一根筷子。哲学家们时而思考，时而进餐。每个人都需要一双筷子才能吃到东西，并在吃完后将筷子放回原处继续思考。有些筷子管理算法能够使每个人都能相对及时地吃到东西（例如一个饥饿的哲学家会尝试获得两根邻近的筷子，但如果其中一根正在被另一个哲学家使用，那么他将放弃已经得到的那根筷子，并等待几分钟之后再次尝试），但有些算法却可能导致一些或者所有哲学家都 “饿死”（每个人都立即抓住自己左边的筷子，然后等待自己右边的筷子空出来，但同时又不放下已经拿到的筷子）。后一种情况将产生死锁：每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源。</p><p>当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞。在线程 A 持有锁 L 并想获得锁 M 的同时，线程 B 持有锁 M 并尝试获得锁 L，那么这两个线程将永远地等待下去。这种情况就是最简单的死锁形式（或者称为 “抱死[Deadly Embrace]”），其中多个线程由于存在环路的锁依赖关系而永远地等待下去。（把每个线程假想为有向图中的一个节点，图中每条边表示的关系是：“线程 A 等待线程 B 所占有的资源”。如果在图中形成了一条环路，那么就存在一个死锁。）</p><p>在数据库系统的设计中考虑了监测死锁以及从死锁中恢复。在执行一个事务（Transaction）时可能需要获取多个锁，并一直持有这些锁直到事务提交。因此在两个事务之间很可能发生死锁，但事实上这种情况并不多见。如果没有外部干涉，那么这些事务将永远等待下去（在某个事务中持有的锁可能在其他事务中也需要）。但数据库服务器不会让这种情况发生。当它检测到一组事务发生了死锁时（通过在表示等待关系的有向图中搜索循环），将选择一个牺牲者并放弃这个事务。作为牺牲者的事务会释放它所持有的资源，从而使其他事务继续进行。应用程序可以重新执行被强行中止的事务，而这个事务现在可以成功完成，因为所有跟它竞争资源的事务都已经完成了。</p><p>JVM 在解决死锁问题方面并没有数据库服务那样强大。当一组 Java 线程发生死锁时，“游戏” 将到此结束——这些线程永远不能再使用了。根据线程完成工作的不同，可能造成应用程序完全停止，或者某个特定的子系统停止，或者是性能降低。恢复应用程序的唯一方式就是中止并重启它，并希望不要再发生同样的事情。</p><p>与许多其他的并发危险一样，死锁造成的影响很少会立即显现出来。如果一个类可能发生死锁，那么并不意味着每次都会发生死锁，而只是表示有可能。当死锁出现时，往往是在最糟糕的时候——在高负载情况下。</p><h3 id="_10-1-1-锁顺序死锁" tabindex="-1"><a class="header-anchor" href="#_10-1-1-锁顺序死锁" aria-hidden="true">#</a> 10.1.1 锁顺序死锁</h3><p>程序清单10-1 中的 LeftRightDeadlock 存在死锁风险。leftRight 和 rightLeft 这两个方法分别获得 left 锁和 right 锁。如果一个线程调用了 leftRight，而另一个线程调用了 rightLeft，并且这两个线程的操作是交错执行，如图10-1 所示，那么它们会发生死锁。</p><img src="/assets/图10-1.103491a7.jpeg" alt="图10-1" style="zoom:50%;"><p>图10-1 LeftRightDeadlock 中的不当执行时机</p><p>在 LeftRightDeadlock 中发生死锁的原因是：两个线程试图以不同的顺序来获得相同的锁。如果按照相同的顺序来请求锁，那么就不会出现循环的加锁依赖性，因此也就不会产生死锁。如果每个需要锁 L 和锁 M 的线程都以相同的顺序来获取 L 和 M，那么就不会发生死锁了。</p><p>如果所有线程以固定的顺序来获得锁，那么在程序中就不会出现锁顺序死锁问题。</p><p>要想验证锁顺序的一致性，需要对程序中的加锁行为进行全局分析。如果只是单独地分析每条获取多个锁的代码路径，那是不够的：leftRight 和 rightLeft 都采用了 “合理的” 方式来获得锁，它们只是不能相互兼容。当需要加锁时，它们需要知道彼此正在执行什么操作。</p><p>程序清单10-1 简单的锁顺序死锁（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注意：容易发生死锁！</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeftRightDeadlock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">leftRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rightLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_10-1-2-动态的锁顺序死锁" tabindex="-1"><a class="header-anchor" href="#_10-1-2-动态的锁顺序死锁" aria-hidden="true">#</a> 10.1.2 动态的锁顺序死锁</h3><p>有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。考虑程序清单10-2 中看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个 Account 对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，例如 “账户的余额不能为负数”。</p><p>程序清单10-2 动态的锁顺序死锁（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注意：容易发生死锁！</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transferMoney</span><span class="token punctuation">(</span><span class="token class-name">Account</span> fromAccount<span class="token punctuation">,</span> <span class="token class-name">Account</span> toAccount<span class="token punctuation">,</span> <span class="token class-name">DollarAmount</span> amount<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InsufficientFundsException</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>fromAccount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>toAccount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fromAccount<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientFundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                fromAccount<span class="token punctuation">.</span><span class="token function">debit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                toAccount<span class="token punctuation">.</span><span class="token function">credit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 transferMoney 中如何发生死锁？所有的线程似乎都是按照相同的顺序来获得锁，但事实上锁的顺序取决于传递给 transferMoney 的参数顺序，而这些参数顺序又取决于外部输入。如果两个线程同时调用 transferMoney，其中一个线程从 X 向 Y 转账，另一个线程从 Y 向 X 转账，那么就会发生死锁：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">A</span><span class="token operator">:</span> <span class="token function">transferMoney</span><span class="token punctuation">(</span>myAccount<span class="token punctuation">,</span> yourAccount<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">B</span><span class="token operator">:</span> <span class="token function">transferMoney</span><span class="token punctuation">(</span>yourAccount<span class="token punctuation">,</span> myAccount<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果执行时序不当，那么 A 可能获得 myAccount 的锁并等待 yourAccount 的锁，然而 B 此时持有 yourAccount 的锁，并正在等待 myAccount 的锁。</p><p>这种死锁可以采用程序清单10-1 中的方法来检查——查看是否存在嵌套的锁获取操作。由于我们无法控制参数的顺序，因此要解决这个问题，必须定义锁的顺序，并在整个应用程序中都按照这个顺序来获取锁。</p><p>在制定锁的顺序时，可以使用 System.identityHashCode 方法，该方法将返回由 Object.hashCode 返回的值。程序清单10-3 给出了另一个版本的 transferMoney，在该版本中使用了 System.identityHashCode 来定义锁的顺序。虽然增加了一些新的代码，但却消除了发生死锁的可能性。</p><p>程序清单10-3 通过锁顺序来避免死锁</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> tieLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transferMoney</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Account</span> fromAcct<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Account</span> toAcct<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">DollarAmount</span> amount<span class="token punctuation">)</span> 
        <span class="token keyword">throws</span> <span class="token class-name">InsufficientFundsException</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Helper</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InsufficientFundsException</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fromAcct<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InsufficientFundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                fromAcct<span class="token punctuation">.</span><span class="token function">debit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                toAcct<span class="token punctuation">.</span><span class="token function">credit</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> fromHash <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">identityHashCode</span><span class="token punctuation">(</span>fromAcct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> toHash <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">identityHashCode</span><span class="token punctuation">(</span>toAcct<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fromHash <span class="token operator">&lt;</span> toHash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>fromAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>toAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fromHash <span class="token operator">&gt;</span> toHash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>toAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>fromAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>tieLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>fromAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>toAcct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在极少数情况下，两个对象可能拥有相同的散列值，此时必须通过某种任意的方法来决定锁的顺序，而这可能又会重新引入死锁。为了避免这种情况，可以使用 “加时赛（Tie-Breaking）” 锁。在获得两个 Account 锁之前，首先获得这个 “加时赛” 锁，从而保证每次只有一个线程以未知的顺序获得这两个锁，从而消除了死锁发生的可能性（只要一致地使用这种机制）。如果经常会出现散列冲突的情况，那么这种技术可能会成为并发性的一个瓶颈（这类似于在整个程序中只有一个锁的情况），但由于 System.identityHashCode 中出现散列冲突的频率非常低，因此这项技术以最小的代价，换来了最大的安全性。</p><p>如果在 Account 中包含一个唯一的、不可变的，并且具备可比性的键值，例如账号，那么要制定锁的顺序就更加容易了：通过键值对对象进行排序，因而不需要使用 “加时赛” 锁。</p><p>你或许认为我有些夸大了死锁的风险，因为锁被持有的时间通常很短暂，然而在真实系统中，死锁往往都是很严重的问题。作为商业产品的应用程序每天可能要执行数十亿次获取锁-释放锁的操作。只要在这数十亿次操作中有一次发生了错误，就可能导致程序发生死锁，并且即使应用程序通过了压力测试也不可能找出所有潜在的死锁<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。在程序清单l0-4<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>中的 DemonstrateDeadlock 在大多数系统下都会很快发生死锁。</p><p>程序清单10-4 在典型条件下会发生死锁的循环</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemonstrateDeadlock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM_THREADS <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM_ACCOUNTS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM_ITERATIONS <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Random</span> rnd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Account</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">[</span>NUM_ACCOUNTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> accounts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
            accounts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">TransferThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_ITERATIONS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">int</span> fromAcct <span class="token operator">=</span> rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>NUM_ACCOUNTS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> toAcct <span class="token operator">=</span> rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>NUM_ACCOUNTS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">DollarAmount</span> amount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DollarAmount</span><span class="token punctuation">(</span>rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">transferMoney</span><span class="token punctuation">(</span>accounts<span class="token punctuation">[</span>fromAcct<span class="token punctuation">]</span><span class="token punctuation">,</span> accounts<span class="token punctuation">[</span>toAcct<span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
            <span class="token keyword">new</span> <span class="token class-name">TransferThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_10-1-3-在协作对象之间发生的死锁" tabindex="-1"><a class="header-anchor" href="#_10-1-3-在协作对象之间发生的死锁" aria-hidden="true">#</a> 10.1.3 在协作对象之间发生的死锁</h3><p>某些获取多个锁的操作并不像在 LeftRightDeadlock 或 transferMoney 中那么明显，这两个锁并不一定必须在同一个方法中被获取。考虑程序清单10-5 中两个相互协作的类，在出租车调度系统中可能会用到它们。Taxi 代表一个出租车对象，包含位置和目的地两个属性，Dispatcher 代表一个出租车车队。</p><p>程序清单10-5 在相互协作对象之间的锁顺序死锁（不要这么做）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注意：容易发生死锁！</span>
<span class="token keyword">class</span> <span class="token class-name">Taxi</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Point</span> location<span class="token punctuation">,</span> destination<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Dispatcher</span> dispatcher<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Taxi</span><span class="token punctuation">(</span><span class="token class-name">Dispatcher</span> dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>dispatcher <span class="token operator">=</span> dispatcher<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Point</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> location<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token class-name">Point</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>location <span class="token operator">=</span> location<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span class="token punctuation">)</span> 
            dispatcher<span class="token punctuation">.</span><span class="token function">notifyAvailable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dispatcher</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span> taxis<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span> availableTaxis<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Dispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        taxis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        availableTaxis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">notifyAvailable</span><span class="token punctuation">(</span><span class="token class-name">Taxi</span> taxi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        availableTaxis<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>taxi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Image</span> <span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Image</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Taxi</span> t <span class="token operator">:</span> taxis<span class="token punctuation">)</span> 
            image<span class="token punctuation">.</span><span class="token function">drawMarker</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> image<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尽管没有任何方法会显式地获取两个锁，但 setLocation 和 getImage 等方法的调用者都会获得两个锁。如果一个线程在收到 GPS 接收器的更新事件时调用 setLocation，那么它将首先更新出租车的位置，然后判断它是否到达了目的地。如果已经到达，它会通知 Dispatcher：它需要一个新的目的地。因为 setLocation 和 notifyAvailable 都是同步方法，因此调用 setLocation 的线程将首先获取 Taxi 的锁，然后获取 Dispatcher 的锁。同样，调用 getImage 的线程将首先获取 Dispatcher 锁，然后再获取每一个 Taxi 的锁（每次获取一个）。这与 LeftRightDeadlock 中的情况相同，两个线程按照不同的顺序来获取两个锁，因此就可能产生死锁。</p><p>在 LeftRightDeadlock 或 transferMoney 中，要查找死锁是比较简单的，只需要找出那些需要获取两个锁的方法。然而要在 Taxi 和 Dispatcher 中查找死锁则比较困难：如果在持有锁的情况下调用某个外部方法，那么就需要警惕死锁。</p><p>如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能会获取其他锁（这可能会产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</p><h3 id="_10-1-4-开放调用" tabindex="-1"><a class="header-anchor" href="#_10-1-4-开放调用" aria-hidden="true">#</a> 10.1.4 开放调用</h3><p>当然，Taxi 和 Dispatcher 并不知道它们将要陷入死锁，况且它们本来就不应该知道。方法调用相当于一种抽象屏障，因而你无须了解在被调用方法中所执行的操作。但也正是由于不知道在被调用方法中执行的操作，因此在持有锁的时候对调用某个外部方法将难以进行分析，从而可能出现死锁。</p><p>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用（Open Call）[CPJ 2.4.1.3]。依赖于开放调用的类通常能表现出更好的行为，并且与那些在调用方法时需要持有锁的类相比，也更易于编写。这种通过开放调用来避免死锁的方法，类似于采用封装机制来提供线程安全的方法：虽然在没有封装的情况下也能确保构建线程安全的程序，但对一个使用了封装的程序进行线程安全分析，要比分析没有使用封装的程序容易得多。同理，分析一个完全依赖于开放调用的程序的活跃性，要比分析那些不依赖开放调用的程序的活跃性简单。通过尽可能地使用开放调用，将更易于找出那些需要获取多个锁的代码路径，因此也就更容易确保采用一致的顺序来获得锁。<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup></p><p>可以很容易地将程序清单10-5 中的 Taxi 和 Dispatcher 修改为使用开放调用，从而消除发生死锁的风险。这需要使同步代码块仅被用于保护那些涉及共享状态的操作，如程序清单10-6 所示。通常，如果只是为了语法紧凑或简单性（而不是因为整个方法必须通过一个锁来保护）而使用同步方法（而不是同步代码块），那么就会导致程序清单10-5 中的问题。（此外，收缩同步代码块的保护范围还可以提高可伸缩性，在 11.4.1 节中给出了如何确定同步代码块大小的方法。）</p><p>程序清单10-6 通过公开调用来避免在相互协作的对象之间产生死锁</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">class</span> <span class="token class-name">Taxi</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Point</span> location<span class="token punctuation">,</span> destination<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Dispatcher</span> dispatcher<span class="token punctuation">;</span>
    <span class="token comment">// ......</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Point</span> <span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> location<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocation</span><span class="token punctuation">(</span><span class="token class-name">Point</span> location<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> reachedDestination<span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>location <span class="token operator">=</span> location<span class="token punctuation">;</span>
            reachedDestination <span class="token operator">=</span> location<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>reachedDestination<span class="token punctuation">)</span>
            dispatcher<span class="token punctuation">.</span><span class="token function">notifyAvailable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">class</span> <span class="token class-name">Dispatcher</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span> taxis<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span> availableTaxis<span class="token punctuation">;</span>
    <span class="token comment">// ......</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">notifyAvailable</span><span class="token punctuation">(</span><span class="token class-name">Taxi</span> taxi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        availableTaxis<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>taxi<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">getImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span> copy<span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Taxi</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>taxis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Image</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Taxi</span> t <span class="token operator">:</span> copy<span class="token punctuation">)</span> 
            image<span class="token punctuation">.</span><span class="token function">drawMarker</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> image<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在程序中应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更易于对依赖于开放调用的程序进行死锁分析。</p><p>有时候，在重新编写同步代码块以使用开放调用时会产生意想不到的结果，因为这会使得某个原子操作变为非原子操作。在许多情况下，使某个操作失去原子性是可以接受的。例如，对于两个操作：更新出租车位置以及通知调度程序这辆出租车已准备好出发去一个新的目的地，这两个操作并不需要实现为一个原子操作。在其他情况中，虽然去掉原子性可能会出现一些值得注意的结果，但这种语义变化仍然是可以接受的。在容易产生死锁的版本中，getImage 会生成某个时刻下的整个车队位置的完整快照，而在重新改写的版本中，getImage 将获得每辆出租车不同时刻的位置。</p><p>然而，在某些情况下，丢失原子性会引发错误，此时需要通过另一种技术来实现原子性。例如，在构造一个并发对象时，使得每次只有单个线程执行使用了开放调用的代码路径。例如，在关闭某个服务时，你可能希望所有正在运行的操作执行完成以后，再释放这些服务占用的资源。如果在等待操作完成的同时持有该服务的锁，那么将很容易导致死锁，但如果在服务关闭之前就释放服务的锁，则可能导致其他线程开始新的操作。这个问题的解决方法是，在将服务的状态更新为 “关闭” 之前一直持有锁，这样其他想要开始新操作的线程，包括想关闭该服务的其他线程，会发现服务已经不可用，因此也就不会试图开始新的操作。然后，你可以等待关闭操作结束，并且知道当开放调用完成后，只有执行关闭操作的线程才能访问服务的状态。因此，这项技术依赖于构造一些协议（而不是通过加锁）来防止其他线程进入代码的临界区。</p><h3 id="_10-1-5-资源死锁" tabindex="-1"><a class="header-anchor" href="#_10-1-5-资源死锁" aria-hidden="true">#</a> 10.1.5 资源死锁</h3><p>正如当多个线程相互持有彼此正在等待的锁而又不释放自己已持有的锁时会发生死锁，当它们在相同的资源集合上等待时，也会发生死锁。</p><p>假设有两个资源池，例如两个不同数据库的连接池。资源池通常采用信号量来实现（请参见 5.5.3 节）当资源池为空时的阻塞行为。如果一个任务需要连接两个数据库，并且在请求这两个资源时不会始终遵循相同的顺序，那么线程 A 可能持有与数据库 D1 的连接，并等待与数据库 D2 的连接，而线程 B 则持有与 D2 的连接并等待与 D1 的连接。（资源池越大，出现这种情况的可能性就越小。如果每个资源池都有 N 个连接，那么在发生死锁时不仅需要 N 个循环等待的线程，而且还需要大量不恰当的执行时序。）</p><p>另一种基于资源的死锁形式就是线程饥饿死锁（Thread-Starvation Deadlock）。8.1.1 节给出了这种危害的一个示例：一个任务提交另一个任务，并等待被提交任务在单线程的 Executor 中执行完成。这种情况下，第一个任务将永远等待下去，并使得另一个任务以及在这个 Executor 中执行的所有其他任务都停止执行。如果某些任务需要等待其他任务的结果，那么这些任务往往是产生线程饥饿死锁的主要来源，有界线程池 / 资源池与相互依赖的任务不能一起使用。</p><h2 id="_10-2-死锁的避免与诊断" tabindex="-1"><a class="header-anchor" href="#_10-2-死锁的避免与诊断" aria-hidden="true">#</a> 10.2 死锁的避免与诊断</h2><p>如果一个程序每次至多只能获得一个锁，那么就不会产生锁顺序死锁。当然，这种情况通常并不现实，但如果能够避免这种情况，那么就能省去很多工作。如果必须获取多个锁，那么在设计时必须考虑锁的顺序：尽量减少潜在的加锁交互数量，将获取锁时需要遵循的协议写入正式文档并始终遵循这些协议。</p><p>在使用细粒度锁的程序中，可以通过使用一种两阶段策略（Two-Part Strategy）来检查代码中的死锁：首先，找出在什么地方将获取多个锁（使这个集合尽量小），然后对所有这些实例进行全局分析，从而确保它们在整个程序中获取锁的顺序都保持一致。尽可能地使用开放调用，这能极大地简化分析过程。如果所有的调用都是开放调用，那么要发现获取多个锁的实例是非常简单的，可以通过代码审查，或者借助自动化的源代码分析工具。</p><h3 id="_10-2-1-支持定时的锁" tabindex="-1"><a class="header-anchor" href="#_10-2-1-支持定时的锁" aria-hidden="true">#</a> 10.2.1 支持定时的锁</h3><p>还有一项技术可以检测死锁和从死锁中恢复过来，即显式使用 Lock 类中的定时 tryLock 功能（参见第 13 章）来代替内置锁机制。当使用内置锁时，只要没有获得锁，就会永远等待下去，而显式锁则可以指定一个超时时限（Timeout），在等待超过该时间后 tryLock 会返回一个失败信息。如果超时时限比获取锁的时间要长很多，那么就可以在发生某个意外情况后重新获得控制权。（在程序清单13-3 中给出了 transferMoney 的另一种实现，其中使用了一种轮询的 tryLock 消除了死锁发生的可能性。）</p><p>当定时锁失败时，你并不需要知道失败的原因。或许是因为发生了死锁，或许某个线程在持有锁时错误地进入了无限循环，还可能是某个操作的执行时间远远超过了你的预期。然而，至少你能记录所发生的失败，以及关于这次操作的其他有用信息，并通过一种更平缓的方式来重新启动计算，而不是关闭整个进程。</p><p>即使在整个系统中没有始终使用定时锁，使用定时锁来获取多个锁也能有效地应对死锁问题。如果在获取锁时超时，那么可以释放这个锁，然后后退并在一段时间后再次尝试，从而消除了死锁发生的条件，使程序恢复过来。（这项技术只有在同时获取两个锁时才有效，如果在嵌套的方法调用中请求多个锁，那么即使你知道已经持有了外层的锁，也无法释放它。）</p><h3 id="_10-2-2-通过线程转储信息来分析死锁" tabindex="-1"><a class="header-anchor" href="#_10-2-2-通过线程转储信息来分析死锁" aria-hidden="true">#</a> 10.2.2 通过线程转储信息来分析死锁</h3><p>虽然防止死锁的主要责任在于你自己，但 JVM 仍然通过线程转储（Thread Dump）来帮助识别死锁的发生。线程转储包括各个运行中的线程的栈追踪信息，这类似于发生异常时的栈追踪信息。线程转储还包含加锁信息，例如每个线程持有了哪些锁，在哪些栈帧中获得这些锁，以及被阻塞的线程正在等待获取哪一个锁。<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>在生成线程转储之前，JVM 将在等待关系图中通过搜索循环来找出死锁。如果发现了一个死锁，则获取相应的死锁信息，例如在死锁中涉及哪些锁和线程，以及这个锁的获取操作位于程序的哪些位置</p><p>要在 UNIX 平台上触发线程转储操作，可以通过向 JVM 的进程发送 SIGQUIT 信号（kill-3），或者在 UNIX 平台中按下 Ctrl-\键，在 Windows 平台中按下 Ctrl-Break 键。在许多 IDE（集成开发环境）中都可以请求线程转储。</p><p>如果使用显式的 Lock 类而不是内部锁，那么 Java 5.0 并不支持与 Lock 相关的转储信息，在线程转储中不会出现显式的 Lock。虽然 Java 6 中包含对显式 Lock 的线程转储和死锁检测等的支持，但在这些锁上获得的信息比在内置锁上获得的信息精确度低。内置锁与获得它们所在的线程栈帧是相关联的，而显式的 Lock 只与获得它的线程相关联。</p><p>程序清单10-7 给出了一个 J2EE 应用程序中获取的部分线程转储信息。在导致死锁的故障中包括 3 个组件：一个 J2EE 应用程序，一个 J2EE 容器，以及一个 JDBC 驱动程序，分别由不同的生产商提供。这 3 个组件都是商业产品，并经过了大量的测试，但每一个组件中都存在一个错误，并且这个错误只有当它们进行交互时才会显现出来，并导致服务器出现一个严重的故障。</p><p>程序清单10-7 在发生死锁后的部分线程转储信息</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Found</span> one <span class="token class-name">Java</span><span class="token operator">-</span>level deadlock<span class="token operator">:</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token string">&quot;ApplicationServerThread&quot;</span><span class="token operator">:</span>
waiting <span class="token keyword">to</span> <span class="token namespace">lock</span> monitor <span class="token function">0x080f0cdc</span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBConnection</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
which is held by<span class="token string">&quot;ApplicationServerThread&quot;</span>
<span class="token string">&quot;ApplicationServerThread&quot;</span><span class="token operator">:</span>
waiting <span class="token keyword">to</span> <span class="token namespace">lock</span> monitor <span class="token function">0x080f0ed4</span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBCallableStatement</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
which is held by<span class="token string">&quot;ApplicationServerThread&quot;</span>
<span class="token class-name">Java</span> stack information <span class="token keyword">for</span> the threads listed above<span class="token operator">:</span>
<span class="token string">&quot;ApplicationServerThread&quot;</span><span class="token operator">:</span>
at <span class="token class-name">MumbleDBConnection</span><span class="token punctuation">.</span>remove_statement
<span class="token operator">-</span>waiting <span class="token keyword">to</span> <span class="token namespace">lock</span><span class="token generics"><span class="token punctuation">&lt;</span>0x650f7f30<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBConnection</span><span class="token punctuation">)</span>
at <span class="token class-name">MumbleDBStatement</span><span class="token punctuation">.</span>close
<span class="token operator">-</span>locked<span class="token generics"><span class="token punctuation">&lt;</span>0x6024ffb0<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBCallableStatement</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">&quot;ApplicationServerThread&quot;</span><span class="token operator">:</span>
at <span class="token class-name">MumbleDBCallableStatement</span><span class="token punctuation">.</span>sendBatch
<span class="token operator">-</span>waiting <span class="token keyword">to</span> <span class="token namespace">lock</span><span class="token generics"><span class="token punctuation">&lt;</span>0x6024ffb0<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBCallableStatement</span><span class="token punctuation">)</span>
at <span class="token class-name">MumbleDBConnection</span><span class="token punctuation">.</span>commit<span class="token operator">-</span>locked<span class="token generics"><span class="token punctuation">&lt;</span>0x650f7f30<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a <span class="token class-name">MumbleDBConnection</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只给出了与查找死锁相关的部分线程转储信息。当诊断死锁时，JVM 可以帮我们做许多工作——哪些锁导致了这个问题，涉及哪些线程，它们持有哪些其他的锁，以及是否间接地给其他线程带来了不利影响。其中一个线程持有 MumbleDBConnection 上的锁，并等待获得 MumbleDBCallableStatement 上的锁，而另一个线程则持有 MumbleDBCallableStatement 上的锁，并等待 MumbleDBConnection 上的锁。</p><p>在这里使用的 JDBC 驱动程序中明显存在一个锁顺序问题：不同的调用链通过 JDBC 驱动程序以不同的顺序获取多个锁。如果不是由于另一个错误，这个问题永远不会显现出来：多个线程试图同时使用同一个 JDBC 连接。这并不是应用程序的设计初衷——开发人员惊讶地发现同一个 Connection 被两个线程并发使用。在 JDBC 规范中并没有要求 Connection 必须是线程安全的，以及 Connection 通常被封闭在单个线程中使用，而在这里就采用了这种假设。这个生产商试图提供一个线程安全的 JDBC 驱动，因此在驱动程序代码内部对多个 JDBC 对象施加了同步机制。然而，生产商却没有考虑锁的顺序，因而驱动程序很容易发生死锁，而正是由于这个存在死锁风险的驱动程序与错误共享 Connection 的应用程序发生了交互，才使得这个问题暴露出来。因为单个错误并不会产生死锁，只有这两个错误同时发生时才会产生，即使它们分别进行了大量测试。</p><h2 id="_10-3-其他活跃性危险" tabindex="-1"><a class="header-anchor" href="#_10-3-其他活跃性危险" aria-hidden="true">#</a> 10.3 其他活跃性危险</h2><p>尽管死锁是最常见的活跃性危险，但在并发程序中还存在一些其他的活跃性危险，包括：饥饿、丢失信号和活锁等。（“丢失信号” 这种活跃性危险将在 14.2.3 节中介绍。）</p><h3 id="_10-3-1-饥饿" tabindex="-1"><a class="header-anchor" href="#_10-3-1-饥饿" aria-hidden="true">#</a> 10.3.1 饥饿</h3><p>当线程由于无法访问它所需要的资源而不能继续执行时，就发生了 “饥饿（Starvation）”。引发饥饿的最常见资源就是 CPU 时钟周期。如果在 Java 应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构（例如无限循环，或者无限制地等待某个资源），那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。在 Thread API 中定义的线程优先级只是作为线程调度的参考。</p><p>在 Thread API 中定义了 10 个优先级，JVM 根据需要将它们映射到操作系统的调度优先级。这种映射是与特定平台相关的，因此在某个操作系统中两个不同的 Java 优先级可能被映射到同一个优先级，而在另一个操作系统中则可能被映射到另一个不同的优先级。在某些操作系统中，如果优先级的数量少于 10 个，那么有多个 Java 优先级会被映射到同一个优先级。</p><p>操作系统的线程调度器会尽力提供公平的、活跃性良好的调度，甚至超出 Java 语言规范的需求范围。在大多数 Java 应用程序中，所有线程都具有相同的优先级 Thread.NORM_PRIORITY。线程优先级并不是一种直观的机制，而通过修改线程优先级所带来的效果通常也不明显。当提高某个线程的优先级时，可能不会起到任何作用，或者也可能使得某个线程的调度优先级高于其他线程，从而导致饥饿。</p><p>通常，我们尽量不要改变线程的优先级。只要改变了线程的优先级，程序的行为就将与平台相关，并且会导致发生饥饿问题的风险。你经常能发现某个程序会在一些奇怪的地方调用 Thread.sleep 或 Thread.yield，这是因为该程序试图克服优先级调整问题或响应性问题，并试图让低优先级的线程执行更多的时间。<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup></p><p>要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线程优先级。</p><h3 id="_10-3-2-糟糕的响应性" tabindex="-1"><a class="header-anchor" href="#_10-3-2-糟糕的响应性" aria-hidden="true">#</a> 10.3.2 糟糕的响应性</h3><p>除饥饿以外的另一个问题是糟糕的响应性，如果在 GUI 应用程序中使用了后台线程，那么这种问题是很常见的。在第 9 章中开发了一个框架，并把运行时间较长的任务放到后台线程中运行，从而不会使用户界面失去响应。但 CPU 密集型的后台任务仍然可能对响应性造成影响，因为它们会与事件线程共同竞争 CPU 的时钟周期。在这种情况下就可以发挥线程优先级的作用，此时计算密集型的后台任务将对响应性造成影响。如果由其他线程完成的工作都是后台任务，那么应该降低它们的优先级，从而提高前台程序的响应性。不良的锁管理也可能导致糟糕的响应性。如果某个线程长时间占有一个锁（或许正在对一个大容器进行迭代，并且对每个元素进行计算密集的处理），而其他想要访问这个容器的线程就必须等待很长时间。</p><h3 id="_10-3-3-活锁" tabindex="-1"><a class="header-anchor" href="#_10-3-3-活锁" aria-hidden="true">#</a> 10.3.3 活锁</h3><p>活锁（Livelock）是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。（有时候也被称为毒药消息，Poison Message。）虽然处理消息的线程并没有阻塞，但也无法继续执行下去。这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误地将不可修复的错误作为可修复的错误。</p><p>当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。这就像两个过于礼貌的人在半路上面对面地相遇：他们彼此都让出对方的路，然而又在另一条路上相遇了。因此他们就这样反复地避让下去。</p><p>要解决这种活锁问题，需要在重试机制中引入随机性。例如，在网络上，如果两台机器尝试使用相同的载波来发送数据包，那么这些数据包就会发生冲突。这两台机器都检查到了冲突，并都在稍后再次重发。如果二者都选择了在 1 秒钟后重试，那么它们又会发生冲突，并且不断地冲突下去，因而即使有大量闲置的带宽，也无法使数据包发送出去。为了避免这种情况发生，需要让它们分别等待一段随机的时间。（以太协议定义了在重复发生冲突时采用指数方式回退机制，从而降低在多台存在冲突的机器之间发生拥塞和反复失败的风险。）在并发应用程序中，通过等待随机长度的时间和回退可以有效地避免活锁的发生。</p><p><strong>小结</strong></p><p>活跃性故障是一个非常严重的问题，因为当出现活跃性故障时，除了中止应用程序之外没有其他任何机制可以帮助从这种故障时恢复过来。最常见的活跃性故障就是锁顺序死锁。在设计时应该避免产生锁顺序死锁：确保线程在获取多个锁时采用一致的顺序。最好的解决方法是在程序中始终使用开放调用。这将大大减少需要同时持有多个锁的地方，也更容易发现这些地方。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>具有讽刺意味的是，之所以短时间地持有锁，是为了降低锁的竞争程度，但却增加了在测试中找出潜在死锁风险的难度。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>为了简便，在 DemonstrateDeadlock 没有考虑账户余额为负数的问题。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>这些对开放调用以及锁顺序的依赖，反映了在构造同步对象（而不是对已构造好的对象进行同步）过程中存在的复杂性。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>即使没有死锁，这些信息对于调试来说也是有用的。通过定期触发线程转储，可以观察程序的加锁行为。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>Thread.yield（以及 Thread.sleep(O)）的语义都是未定义的[JLS 17.9]。JVM 既可以将它们实现为空操作，也可以将它们视为线程调度的参考。尤其是，在 UNIX 系统中并不要求它们拥有 sleep(O) 的语义——将当前线程放在与该优先级对应的运行队列末尾，并将执行权交给拥有相同优先级的其他线程，尽管有些 JVM 是按照这种方式来实现 yield 方法的。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li></ol></section></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Java并发编程实战/第10章避免活跃性危险.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/28 下午9:05:06</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%AC%AC11%E7%AB%A0%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7.html" class="nav-link next" aria-label="第 11 章 性能与可伸缩性"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 11 章 性能与可伸缩性<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
