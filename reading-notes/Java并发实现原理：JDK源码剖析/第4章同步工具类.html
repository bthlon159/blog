<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 4 章 同步工具类"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 4 章 同步工具类 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link active" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC1%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 多线程基础"><!---->第 1 章 多线程基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC2%E7%AB%A0Atomic%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 Atomic 类"><!---->第 2 章 Atomic 类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC3%E7%AB%A0Lock%E4%B8%8ECondition.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 Lock 与 Condition"><!---->第 3 章 Lock 与 Condition<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 4 章 同步工具类"><!---->第 4 章 同步工具类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-1-semaphore" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.1 Semaphore"><!---->4.1 Semaphore<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-countdownlatch" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2 CountDownLatch"><!---->4.2 CountDownLatch<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-1-countdownlatch-使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.1 CountDownLatch 使用场景"><!---->4.2.1 CountDownLatch 使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-2-await-实现分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.2 await() 实现分析"><!---->4.2.2 await() 实现分析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-3-countdown-实现分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.2.3 countDown() 实现分析"><!---->4.2.3 countDown() 实现分析<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-cyclicbarrier" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3 CyclicBarrier"><!---->4.3 CyclicBarrier<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-1-cyclicbarrier-使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.1 CyclicBarrier 使用场景"><!---->4.3.1 CyclicBarrier 使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-2-cyclicbarrier-实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.3.2 CyclicBarrier 实现原理"><!---->4.3.2 CyclicBarrier 实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-exchanger" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4 Exchanger"><!---->4.4 Exchanger<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-1-exchanger-使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4.1 Exchanger 使用场景"><!---->4.4.1 Exchanger 使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-2-exchanger-实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4.2 Exchanger 实现原理"><!---->4.4.2 Exchanger 实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-3-exchange-v-x-实现分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.4.3 exchange(V x) 实现分析"><!---->4.4.3 exchange(V x) 实现分析<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-phaser" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5 Phaser"><!---->4.5 Phaser<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-1-用-phaser-替代-cyclicbarrier-和-countdownlatch" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch"><!---->4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-2-phaser-新特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.2 Phaser 新特性"><!---->4.5.2 Phaser 新特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-3-state-变量解析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.3 state 变量解析"><!---->4.5.3 state 变量解析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-4-阻塞与唤醒-treiber-stack" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.4 阻塞与唤醒（Treiber Stack）"><!---->4.5.4 阻塞与唤醒（Treiber Stack）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-5-arrive-函数分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.5 arrive() 函数分析"><!---->4.5.5 arrive() 函数分析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-6-awaitadvance-函数分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.5.6 awaitAdvance() 函数分析"><!---->4.5.6 awaitAdvance() 函数分析<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC5%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 并发容器"><!---->第 5 章 并发容器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC6%E7%AB%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EFuture.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 线程池与 Future"><!---->第 6 章 线程池与 Future<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC7%E7%AB%A0ForkJoinPool.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 ForkJoinPool"><!---->第 7 章 ForkJoinPool<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC8%E7%AB%A0CompletableFuture.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 CompletableFuture"><!---->第 8 章 CompletableFuture<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 4 章 同步工具类</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月16日</span><meta property="datePublished" content="2022-07-16T09:38:20.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 22 分钟</span><meta property="timeRequired" content="PT22M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年7月16日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 6458 字</span><meta property="wordCount" content="6458"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-1-semaphore" class="router-link-active router-link-exact-active toc-link level2">4.1 Semaphore</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-countdownlatch" class="router-link-active router-link-exact-active toc-link level2">4.2 CountDownLatch</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-1-countdownlatch-使用场景" class="router-link-active router-link-exact-active toc-link level3">4.2.1 CountDownLatch 使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-2-await-实现分析" class="router-link-active router-link-exact-active toc-link level3">4.2.2 await() 实现分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-2-3-countdown-实现分析" class="router-link-active router-link-exact-active toc-link level3">4.2.3 countDown() 实现分析</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-cyclicbarrier" class="router-link-active router-link-exact-active toc-link level2">4.3 CyclicBarrier</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-1-cyclicbarrier-使用场景" class="router-link-active router-link-exact-active toc-link level3">4.3.1 CyclicBarrier 使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-3-2-cyclicbarrier-实现原理" class="router-link-active router-link-exact-active toc-link level3">4.3.2 CyclicBarrier 实现原理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-exchanger" class="router-link-active router-link-exact-active toc-link level2">4.4 Exchanger</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-1-exchanger-使用场景" class="router-link-active router-link-exact-active toc-link level3">4.4.1 Exchanger 使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-2-exchanger-实现原理" class="router-link-active router-link-exact-active toc-link level3">4.4.2 Exchanger 实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-4-3-exchange-v-x-实现分析" class="router-link-active router-link-exact-active toc-link level3">4.4.3 exchange(V x) 实现分析</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-phaser" class="router-link-active router-link-exact-active toc-link level2">4.5 Phaser</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-1-用-phaser-替代-cyclicbarrier-和-countdownlatch" class="router-link-active router-link-exact-active toc-link level3">4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-2-phaser-新特性" class="router-link-active router-link-exact-active toc-link level3">4.5.2 Phaser 新特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-3-state-变量解析" class="router-link-active router-link-exact-active toc-link level3">4.5.3 state 变量解析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-4-阻塞与唤醒-treiber-stack" class="router-link-active router-link-exact-active toc-link level3">4.5.4 阻塞与唤醒（Treiber Stack）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-5-arrive-函数分析" class="router-link-active router-link-exact-active toc-link level3">4.5.5 arrive() 函数分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC4%E7%AB%A0%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB.html#_4-5-6-awaitadvance-函数分析" class="router-link-active router-link-exact-active toc-link level3">4.5.6 awaitAdvance() 函数分析</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-4-章-同步工具类" tabindex="-1"><a class="header-anchor" href="#第-4-章-同步工具类" aria-hidden="true">#</a> 第 4 章 同步工具类</h1><p>除了锁与 Condition，Concurrent 包还提供了一系列同步工具类。这些同步工具类的原理，有些也是基于 AQS 的，有些则需要特殊的实现机制，这一章将对所有同步工具类的实现原理进行剖析。</p><h2 id="_4-1-semaphore" tabindex="-1"><a class="header-anchor" href="#_4-1-semaphore" aria-hidden="true">#</a> 4.1 Semaphore</h2><p>Semaphore 也就是信号量，提供了资源数量的并发访问控制，其使用代码很简单，如下所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 初始有 10 个共享资源。第 2 个参数是公平或非公平选项</span>
<span class="token class-name">Semaphore</span> available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 每次获取一个，如果获取不到，则线程就阻塞</span>
available<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 用完释放</span>
available<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如图4-1 所示，假设有 n 个线程来获取 Semaphore 里面的资源（n &gt; 10），n 个线程中只有 10 个线程能获取到，其他线程都会阻塞。直到有线程释放了资源，其他线程才能获取到。</p><img src="/assets/图4-1.9de1ad69.jpeg" alt="图4-1" style="zoom:50%;"><p>图4-1 多个线程访问 Semaphore 示意图</p><p>当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。正因为如此，Semaphone 的实现原理和锁十分类似，是基于 AQS，有公平和非公平之分。Semaphore 相关类的继承体系如图4-2 所示。</p><img src="/assets/图4-2.7955079a.jpeg" alt="图4-2" style="zoom:50%;"><p>图4-2 Semaphore 相关类的继承体系</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 Semaphore 和锁的实现原理基本相同，上面的代码不再展开解释。资源总数即 state 的初始值，在 acquire 里对 state 变量进行 CAS 减操作，减到 0 之后，线程阻塞；在 release 里对 state 变量进行 CAS 加操作。</p><h2 id="_4-2-countdownlatch" tabindex="-1"><a class="header-anchor" href="#_4-2-countdownlatch" aria-hidden="true">#</a> 4.2 CountDownLatch</h2><h3 id="_4-2-1-countdownlatch-使用场景" tabindex="-1"><a class="header-anchor" href="#_4-2-1-countdownlatch-使用场景" aria-hidden="true">#</a> 4.2.1 CountDownLatch 使用场景</h3><p>考虑一个场景：一个主线程要等待 10 个 Worker 线程工作完毕才退出，就能使用 CountDownLatch 来实现。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 初始为 10</span>
<span class="token class-name">CountDownLatch</span> doneSingal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 主线程调用该方法，阻塞在这</span>
doneSingal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 10 个 Worker 线程，每个线程工作完毕之后，调用 1 次 countDown()，</span>
<span class="token comment">// 计数器减 1。当减到 0 之后，主线程就会被唤醒。</span>
doneSingal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图4-3 所示为 CountDownLatch 相关类的继承层次，CountDownLatch 原理和 Semaphore 原理类似，同样是基于 AQS，不过没有公平和非公平之分。</p><img src="/assets/图4-3.421d1082.jpeg" alt="图4-3" style="zoom:50%;"><p>图4-3 CountDownLatch 相关类的继承层次</p><h3 id="_4-2-2-await-实现分析" tabindex="-1"><a class="header-anchor" href="#_4-2-2-await-实现分析" aria-hidden="true">#</a> 4.2.2 await() 实现分析</h3><p>如下所示，await() 调用的是 AQS 的模板方法，这个方法在前面已经介绍过。CountDownLatch.Sync 重新实现了 tryAccuqireShared 方法。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// AQS 模板方法</span>
    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 被 CountDownLatch.Sync 重新实现</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 tryAcquireShared(..) 方法的实现来看，只要 state != 0，调用 await() 方法的线程便会被放入 AQS 的阻塞队列，进入阻塞状态。</p><h3 id="_4-2-3-countdown-实现分析" tabindex="-1"><a class="header-anchor" href="#_4-2-3-countdown-实现分析" aria-hidden="true">#</a> 4.2.3 countDown() 实现分析</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// AQS 模块方法</span>
    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 被 CountDownLatch.Sync 重新实现</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>countDown() 调用的 AQS 的模板方法 releaseShared()，里面的 tryReleaseShared(..) 被 CountDownLatch.Sync 重新实现。从上面的代码可以看出，只有 state == 0，tryReleaseShared(..) 才会返回 true，然后执行 doReleaseShared(..)，一次性唤醒队列中所有阻塞的线程。</p><p>最后做一下小结：因为是基于 AQS 阻塞队列来实现的，所以可以让多个线程都阻塞在 state == 0 条件上，通过 countDown() 一直累减 state，减到 0 后一次性唤醒所有线程。如图4-4 所示，假设初始总数为 M，N 个线程 await()，M 个线程 countDown()，减到 0 之后，N 个线程被唤醒。</p><img src="/assets/图4-4.60e53e7a.jpeg" alt="图4-4" style="zoom:50%;"><p>图4-4 多个线程阻塞在await() 示意图</p><h2 id="_4-3-cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#_4-3-cyclicbarrier" aria-hidden="true">#</a> 4.3 CyclicBarrier</h2><h3 id="_4-3-1-cyclicbarrier-使用场景" tabindex="-1"><a class="header-anchor" href="#_4-3-1-cyclicbarrier-使用场景" aria-hidden="true">#</a> 4.3.1 CyclicBarrier 使用场景</h3><p>CyclicBarrier 使用代码也很简单，如下所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">CyclicBarrier</span> cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>考虑这样一个场景：10 个工程师一起来公司应聘，招聘方式分为笔试和面试。首先，要等人到齐后，开始笔试；笔试结束之后，再一起参加面试。把 10 个人看作 10 个线程，10 个线程之间的同步过程如图4-5 所示。</p><img src="/assets/图4-5.a8cb7911.jpeg" alt="图4-5" style="zoom:50%;"><p>图4-5 10 个线程之间的同步过程</p><p>在整个过程中，有 2 个同步点：第 1 个同步点，要等所有应聘者都到达公司，再一起开始笔试；第 2 个同步点，要等所有应聘者都结束笔试，之后一起进入面试环节。具体到每个线程的 run() 方法中，就是下面的伪代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 阶段 1</span>
    <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">&quot;我已到公司&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第 1 个同步点</span>
    cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 阶段 2</span>
    笔试<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第 2 个同步点</span>
    cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 阶段 3</span>
    面试<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-2-cyclicbarrier-实现原理" tabindex="-1"><a class="header-anchor" href="#_4-3-2-cyclicbarrier-实现原理" aria-hidden="true">#</a> 4.3.2 CyclicBarrier 实现原理</h3><p>CyclicBarrier 基于 ReentrantLock + Condition 实现。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrier</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 用于线程之间互相唤醒</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> trip <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 总线程数</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> parties<span class="token punctuation">;</span>
    <span class="token comment">// 在讲 await 实现的时候，再详细介绍 count 和 generation</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Generation</span> generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面详细介绍 CyclicBarrier 的实现原理。先从构造函数说起，可以看到，不仅可以传入参与方的总数量，还可以传入一个回调函数。当所有的线程被唤醒时，barrierAction 被执行。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> barrierAction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parties <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barrierCommand <span class="token operator">=</span> barrierAction<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来看一下 await() 函数的实现过程。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> toe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>toe<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dowait</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Generation</span> g <span class="token operator">=</span> generation<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 响应中断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 唤醒所有阻塞的线程</span>
            <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 每个线程调用 1 次 await()，count--</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>
        <span class="token comment">// 当 count 减到 0 的时候，此线程唤醒其他所有线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">final</span> <span class="token class-name">Runnable</span> command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>
                <span class="token comment">// 一起唤醒之后，还可以执行一个回调</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token comment">// 唤醒其他所有线程，同时把 count 值复原，用于下一次的 CyclicBarrier（因为可以重复使用）</span>
                <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>
                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 当 count &gt; 0 时，说明人没到期，阻塞自己</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
                    <span class="token comment">// 关键点：await 在阻塞自己的同时，会把锁释放掉，这样别的线程就会拿到锁，执行上面的 index = count--</span>
                    trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span>
                    nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">==</span> generation <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">throw</span> ie<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token punctuation">.</span>broken<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BrokenBarrierException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 从阻塞中唤醒，返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>g <span class="token operator">!=</span> generation<span class="token punctuation">)</span>
                <span class="token keyword">return</span> index<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面的函数，有几点说明：</p><ol><li><p>CyclicBarrier 是可以被重用的。以上一节的应聘场景为例，来了 10 个线程，这 10 个线程互相等待，到齐后一起被唤醒，各自执行接下来的逻辑；然后，这 10 个线程继续互相等待，到齐后再一起被唤醒。每一轮被称为一个 Generation，就是一次同步点。</p></li><li><p>CyclicBarrier 会响应中断。10 个线程没有到齐，如果有线程收到了中断信号，所有阻塞的线程也会被唤醒，就是上面的 breakBarrier() 函数。然后 count 被重置为初始值（parties），重新开始。</p></li><li><p>上面的回调函数，barrierAction 只会被第 10 个线程执行 1 次（在唤醒其他 9 个线程之前），而不是 10 个线程每个都执行 1 次。</p></li></ol><h2 id="_4-4-exchanger" tabindex="-1"><a class="header-anchor" href="#_4-4-exchanger" aria-hidden="true">#</a> 4.4 Exchanger</h2><h3 id="_4-4-1-exchanger-使用场景" tabindex="-1"><a class="header-anchor" href="#_4-4-1-exchanger-使用场景" aria-hidden="true">#</a> 4.4.1 Exchanger 使用场景</h3><p>Exchanger 用于线程之间交换数据，其使用代码很简单，是一个 exchange(..) 函数，使用示例如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> exchange <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 建 1 个多线程共用的 exchange 对象，把 exchage 对象传给 4 个线程对象。</span>
<span class="token comment">// 每个线程在自己的 run 函数里面，调用 exchange，把自己的数据当参数传进去，</span>
<span class="token comment">// 返回值是另外一个线程调用 exchange 传进去的参数</span>
<span class="token class-name">ThreadA</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span>exchage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有其他线程调用 exchange，自己会阻塞在这。直到有别的线程调用 exchange</span>
    <span class="token class-name">String</span> other <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ThreadB</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span>exchage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> other <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ThreadC</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadC</span><span class="token punctuation">(</span>exchage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> other <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ThreadD</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadD</span><span class="token punctuation">(</span>exchage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> other <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，4 个线程并发地调用 exchange(..)，会两两交互数据，如 A / B、C / D、A / C、B / D、A / D 或 B / C。</p><h3 id="_4-4-2-exchanger-实现原理" tabindex="-1"><a class="header-anchor" href="#_4-4-2-exchanger-实现原理" aria-hidden="true">#</a> 4.4.2 Exchanger 实现原理</h3><p>Exchanger 的核心机制和 Lock 一样，也是 CAS + park / unpark。在实现上面，JDK 7 和 JDK 8 有一定差异，这里以 JDK 7 的实现为例进行分析。</p><p>首先，在 Exchanger 内部，有两个内部类：Slot 和 Node，代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token keyword">extends</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token comment">// 自己要拿去交互的数据</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> item<span class="token punctuation">;</span>
        <span class="token comment">// 自己</span>
        <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> var1<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Slot</span> <span class="token keyword">extends</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token comment">// 缓存行填充</span>
        <span class="token keyword">long</span> q0<span class="token punctuation">,</span> q1<span class="token punctuation">,</span> q2<span class="token punctuation">,</span> q3<span class="token punctuation">,</span> q4<span class="token punctuation">,</span> q5<span class="token punctuation">,</span> q6<span class="token punctuation">,</span> q7<span class="token punctuation">,</span> q8<span class="token punctuation">,</span> q9<span class="token punctuation">,</span> qa<span class="token punctuation">,</span> qb<span class="token punctuation">,</span> qc<span class="token punctuation">,</span> qd<span class="token punctuation">,</span> qe<span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个线程在调用 exchange(..) 函数交换数据的时候，会先创建一个 Node 对象，这个 Node 对象就是对该线程的包装，里面包含了 2 个字段：1 个是该线程要交互的数据，另 1 个是该线程自身。这里有个关键点：Node 本身是继承自 AtomicReference 的，所以除了这 2 个字段，Node 还有第 3 个字段，记录的是对方所要交换的数据，初始为 NULL。</p><p>Slot 其实是一个 AtomicReference，里面的 q0，q1，…，qd 变量都是多余的。为什么要添加这些多余的变量呢？是为了优化性能而做的缓存行填充。</p><p>Slot 的 AtomicReference 就是指向的一个 Node，通过 Slot 和 Node 相结合，实现了 2 个线程之间的数据交换，如图4-6 所示。线程 1 持有数据 item1，线程 2 持有数据 item2，各自调用 exchange(..)，会各自生成一个 Node。而 Slot 只会指向 2 个 Node 中的 1 个：如果是线程 1 先调用的 exchange(..)，那么 Slot 就指向 Node1，线程 1 阻塞，等待线程 2 来交换；反之，如果是线程 2 先调用的 exchange(..)，那么 Slot 就指向 Node2，线程 2 阻塞，等待线程 1 来交换数据。</p><img src="/assets/图4-6.46f7d033.jpeg" alt="图4-6" style="zoom:50%;"><p>图4-6 Slot 与 Node 相结合实现 2 个线程交换数据</p><p>一个 Slot 只能支持 2 个线程之间交换数据，要实现多个线程并行地交换数据，需要多个 Slot，因此在 Exchanger 里面定义了 Slot 数组：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Slot</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arena <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Slot</span><span class="token punctuation">[</span>CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_4-4-3-exchange-v-x-实现分析" tabindex="-1"><a class="header-anchor" href="#_4-4-3-exchange-v-x-实现分析" aria-hidden="true">#</a> 4.4.3 exchange(V x) 实现分析</h3><p>明白了大致思路，下面来看 exchange(V x) 函数的详细实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">V</span> x<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> v <span class="token operator">=</span> <span class="token function">doExchange</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> NULL_ITEM <span class="token operator">:</span> x<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> NULL_ITEM<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> CANCEL<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span>v<span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>exchange(..) 函数，参数是自己要交互的数据 item，返回的是从对方线程得到的 item。内部调用的是下面的 doExchange(..) 函数：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">doExchange</span><span class="token punctuation">(</span><span class="token class-name">Object</span> item<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 为该线程新建一个 Node</span>
    <span class="token class-name">Node</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                 
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">hashIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  
    <span class="token keyword">int</span> fails <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                            

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Object</span> y<span class="token punctuation">;</span>                             
        <span class="token class-name">Slot</span> slot <span class="token operator">=</span> arena<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>slot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      
            <span class="token comment">// slot == null，创建一个 slot，然后回到 for 循环，再次开始</span>
            <span class="token function">createSlot</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                
        <span class="token comment">// 如果 slot 里面有线程等待（有 Node），则尝试与其交换</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">=</span> slot<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> slot<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> you <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">)</span> y<span class="token punctuation">;</span>               
            <span class="token comment">// 把 Node 的 AtomiReference 指向自己的 item，也就是把自己的 item 给对方</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>you<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 唤醒对方</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>you<span class="token punctuation">.</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 取回对方的 itme，返回</span>
                <span class="token keyword">return</span> you<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>                                
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果 Slot 里面为空（没有 Node），则尝试把自己的 Node 放进去</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> slot<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> me<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果位置是 0，自己阻塞，等待其他线程来交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                   
                <span class="token keyword">return</span> timed <span class="token operator">?</span>  <span class="token function">awaitNanos</span><span class="token punctuation">(</span>me<span class="token punctuation">,</span> slot<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">await</span><span class="token punctuation">(</span>me<span class="token punctuation">,</span> slot<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 不是位置 0，则自旋等待</span>
            <span class="token class-name">Object</span> v <span class="token operator">=</span> <span class="token function">spinWait</span><span class="token punctuation">(</span>me<span class="token punctuation">,</span> slot<span class="token punctuation">)</span><span class="token punctuation">;</span>    
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> CANCEL<span class="token punctuation">)</span>
                <span class="token keyword">return</span> v<span class="token punctuation">;</span>
            me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>              
            <span class="token keyword">int</span> m <span class="token operator">=</span> max<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 自旋的时候，没有线程来交换。执行下面的，index 减半，挪个位置，重新开始 for 循环 </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&gt;</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          
                max<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
        <span class="token comment">// 失败 case1：solt 有线程，要交互，但被其他线程抢了；</span>
        <span class="token comment">// case2：slot 没有线程，自己准备占位置，又被其他线程抢了</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>fails <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               
            <span class="token keyword">int</span> m <span class="token operator">=</span> max<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fails <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> m <span class="token operator">&lt;</span> FULL <span class="token operator">&amp;&amp;</span> max<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 3 次匹配失败，扩大 index，再次开始 for 循环</span>
                index <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                index <span class="token operator">=</span> m<span class="token punctuation">;</span>                    
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面的代码，有几个点要说明：</p><ol><li><p>当一个线程调用 exchange 准备和其他线程交换数据的时候，无外乎两种情况。一种是没有其他线程要交换数据，自己只能自旋或者阻塞，等待；另一种是恰好有其他线程在 Slot 里面等着，那么和对方交换。</p></li><li><p>由于 Slot 不止 1 个，而是多个。如果运气好，根据自己的 thread id 找到对应的 Slot，里面恰好有别的线程在等待，就和对方交换。交换办法是：取出 Slot 指向的 Node，也就是对方的 Node，然后把这个 Node（本身也是一个 AtomicReference）指向自己的 item，唤醒对方，同时返回对方的 item。（再次强调一次：1 个 Node 实际上有 2 个 item 字段，1 个记录的是自己的 item，1 个记录的是对方的 item，因此实现 2 个线程的数据交换）。</p></li><li><p>如果运气不好，Slot 是空的，如何处理呢？当前 Slot 为空，不代表其他 Slot 没有线程在等待。因此，如果当前 Slot 的 index = 0，自己就阻塞在那；如果 index != 0，则需要遍历所有的 Slot，看其他的 Slot 里面是否有线程在等待。最好是遍历一圈发现没有其他线程，自己再在 index = 0 的位置等待。</p></li></ol><h2 id="_4-5-phaser" tabindex="-1"><a class="header-anchor" href="#_4-5-phaser" aria-hidden="true">#</a> 4.5 Phaser</h2><h3 id="_4-5-1-用-phaser-替代-cyclicbarrier-和-countdownlatch" tabindex="-1"><a class="header-anchor" href="#_4-5-1-用-phaser-替代-cyclicbarrier-和-countdownlatch" aria-hidden="true">#</a> 4.5.1 用 Phaser 替代 CyclicBarrier 和 CountDownLatch</h3><p>从 JDK 7 开始，新增了一个同步工具类 Phaser，其功能比 CyclicBarrier 和 CountDownLatch 更加强大。</p><ol><li><p>用 Phaser 替代 CountDownLatch</p><p>考虑讲 CountDownLatch 时的例子，1 个主线程要等 10 个 worker 线程完成之后，才能做接下来的事情，也可以用 Phaser 来实现此功能。在 CountDownLatch 中，主要是 2 个函数：await() 和 countDown()，在 Phaser 中，与之相对应的函数是 awaitAdance(int n) 和 arrive()。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 初始为 10</span>
<span class="token class-name">Phaser</span> ph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 主线程调用该方法，阻塞在这。awaitAdance(int phase)，表示等待当前 phase（当前同步点）完成</span>
ph<span class="token punctuation">.</span><span class="token function">awaitAdance</span><span class="token punctuation">(</span>ph<span class="token punctuation">.</span><span class="token function">getPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 10 个 worker 线程，每个线程工作完成之后，调用 1 次 arrive()。顾名思义，“我到达了这个同步点”</span>
ph<span class="token punctuation">.</span><span class="token function">arrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>用 Phaser 替代 CyclicBarrier</p><p>考虑前面讲 CyclicBarrier 时，10 个工程师去公司应聘的例子，也可以用 Phaser 实现，代码基本类似。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Phaser</span> ph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 阶段 1</span>
    <span class="token function">report</span><span class="token punctuation">(</span><span class="token string">&quot;我已到公司&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第 1 个同步点（代替 CyclicBarrier 的 await）</span>
    ph<span class="token punctuation">.</span><span class="token function">arriveAndAwaitAdvance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 阶段 2</span>
    笔试<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第 2 个同步点（代替 CyclicBarrier 的 await）</span>
    ph<span class="token punctuation">.</span><span class="token function">arriveAndAwaitAdvance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 阶段 3</span>
    面试<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arriveAndAwaitAdance() 就是 arrive() 与 awaitAdvance(int) 的组合，表示 “我自己已到达这个同步点，同时要等待所有人都到达这个同步点，然后再一起前行”。</p></li></ol><h3 id="_4-5-2-phaser-新特性" tabindex="-1"><a class="header-anchor" href="#_4-5-2-phaser-新特性" aria-hidden="true">#</a> 4.5.2 Phaser 新特性</h3><p>特性 1：动态调整线程个数</p><p>CyclicBarrier 所要同步的线程个数是在构造函数中指定的，之后不能更改，而 Phaser 可以在运行期间动态地调整要同步的线程个数。Phaser 提供了下面这些函数来增加、减少所要同步的线程个数。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注册 1 个</span>
<span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 注册多个</span>
<span class="token function">bulkRegister</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span>
<span class="token comment">// 解注册</span>
<span class="token function">arriveAndDeregister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特性 2：层次 Phaser</p><p>多个 Phaser 可以组成如图4-7 所示的树状结构，可以通过在构造函数中传入父 Phaser 来实现。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span><span class="token class-name">Phaser</span> parent<span class="token punctuation">,</span> <span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="/assets/图4-7.c975ce11.jpeg" alt="图4-7" style="zoom:50%;"><p>图4-7 树状的 Phaser</p><p>先简单看一下 Phaser 内部关于树状结构的存储，如下面代码所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phaser</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Phaser</span> parent<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，在 Phaser 的内部结构中，每个 Phaser 记录了自己的父节点，但并没有记录自己的子节点列表。所以，每个 Phaser 知道自己的父节点是谁，但父节点并不知道自己有多少个子节点，对父节点的操作，是通过子节点来实现的。</p><p>树状的 Phaser 怎么使用呢？考虑如下代码，会组成如图4-8 所示的树状 Phaser。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Phaser</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Phaser</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Phaser</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Phaser</span> c3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="/assets/图4-8.6a40dd19.jpeg" alt="图4-8" style="zoom:50%;"><p>图4-8 代码组成的树状 Phaser</p><p>本来 root 有两个参与者，然后为其加入了两个子 Phaser(c1, c2)，每个子 Phaser 会算作 1 个参与者，root 的参与者就变成 2 + 2 = 4 个。c1 本来有 3 个参与者，为其加入了一个子 Phaser c3，参与者数量变成 3 + 1 = 4 个。c3 的参与者初始为 0，后续可以通过调用 register() 函数加入。</p><p>对于树状 Phaser 上的每个节点来说，可以当作一个独立的 Phaser 来看待，其运作机制和一个单独的 Phaser 是一样的。具体来讲：父 Phaser 并不用感知子 Phaser 的存在，当子 Phaser 中注册的参与者数量大于 0 时，会把自己向父节点注册；当子 Phaser 中注册的参与者数量等于 0 时，会自动向父节点解注册。父 Phaser 把子 Phaser 当作一个正常参与的线程就可以了。</p><h3 id="_4-5-3-state-变量解析" tabindex="-1"><a class="header-anchor" href="#_4-5-3-state-变量解析" aria-hidden="true">#</a> 4.5.3 state 变量解析</h3><p>大致了解了 Phaser 的用法和新特性之后，下面仔细剖析其实现原理。Phaser 没有基于 AQS 来实现，但具备 AQS 的核心特性：state 变量、CAS 操作、阻塞队列。先从 state 变量说起。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phaser</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 64 位的 state 变量被拆成 4 部分，如图4-9 所示为 state 变量各部分表示的意思。</p><img src="/assets/图4-9.d0000462.jpeg" alt="图4-9" style="zoom:50%;"><p>图4-9 state 变量各部分表示的意思</p><p>最高位 0 表示未同步完成，1 表示同步完成，初始最高位为 0。</p><p>Phaser 提供了一系列的成员函数来从 state 中获取图4-9 中的几个数字，如下所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 获取当前的轮数。当前轮数已经同步完成，返回值是一个负数（最高位为 1）</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前 phase 已完成，返回值是一个负数（最高位为 1）</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>state <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PHASE_SHIFT <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>

<span class="token comment">// 当前轮数同步完成，最高位为 1</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> root<span class="token punctuation">.</span>state <span class="token operator">&lt;</span> <span class="token number">0L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取总线程注册数</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRegisteredParties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">partiesOf</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partiesOf</span><span class="token punctuation">(</span><span class="token keyword">long</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先把 state 强制转成 32 位 int，再右移 16 位</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s <span class="token operator">&gt;&gt;&gt;</span> PARTIES_SHIFT<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PARTIES_SHIFT <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token comment">// 获取未到达的线程数</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUnarrivedParties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">unarrivedOf</span><span class="token punctuation">(</span><span class="token function">reconcileState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">unarrivedOf</span><span class="token punctuation">(</span><span class="token keyword">long</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> counts <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 截取低 16 位</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>counts <span class="token operator">==</span> EMPTY<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> counts <span class="token operator">&amp;</span> UNARRIVED_MASK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNARRIVED_MASK <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面再看一下 state 变量在构造函数中是如何被赋值的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Phaser</span><span class="token punctuation">(</span><span class="token class-name">Phaser</span> parent<span class="token punctuation">,</span> <span class="token keyword">int</span> parties<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// parties 超出了最大个数（2 的 16 次方），直接抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parties <span class="token operator">&gt;&gt;&gt;</span> PARTIES_SHIFT <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal number of parties&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始轮数为 0</span>
    <span class="token keyword">int</span> phase <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">(</span>parties <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>EMPTY <span class="token operator">:</span>
    <span class="token comment">// 或操作，赋给 state。最高位为 0，表示未完成同步</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> phase <span class="token operator">&lt;&lt;</span> PHASE_SHIFT<span class="token punctuation">)</span> <span class="token operator">|</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> parties <span class="token operator">&lt;&lt;</span> PARTIES_SHIFT<span class="token punctuation">)</span> <span class="token operator">|</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> parties<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EMPTY <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PARTIES_SHIFT <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PHASE_SHIFT <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 parties = 0 时，state 被赋予一个 EMPTY 常量，常量为 1；</p><p>当 parties != 0 时，把 phase 值左移 32 位；把 parties 左移 16 位；然后 parties 也作为最低的 16 位，3 个值做或操作，赋值给 state。这个赋值操作也反映了图4-9 的意思。</p><h3 id="_4-5-4-阻塞与唤醒-treiber-stack" tabindex="-1"><a class="header-anchor" href="#_4-5-4-阻塞与唤醒-treiber-stack" aria-hidden="true">#</a> 4.5.4 阻塞与唤醒（Treiber Stack）</h3><p>基于上述的 state 变量，对其执行 CAS 操作，并进行相应的阻塞与唤醒。如图4-10 所示，右边的主线程会调用 awaitAdvance() 进行阻塞；左边的 arrive() 会对 state 进行 CAS 的累减操作，当未到达的线程数减到 0 时，唤醒右边阻塞的主线程。</p><img src="/assets/图4-10.24a99506.jpeg" alt="图4-10" style="zoom:50%;"><p>图4-10 基于 state 的 CAS 的阻塞与唤醒示意图</p><p>在这里，阻塞使用的是一个称为 Treiber Stack 的数据结构，而不是 AQS 的双向链表。Treiber Stack 是一个无锁的栈，由 R.Kent Treiber 在其于 1986 年发表的论文 Systems Programming: Coping with Para llelism 中首次提出。它是一个单向链表，出栈、入栈都在链表头部，所以只需要一个 head 指针，而不需要 tail 指针。实现代码如下所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phaser</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">QNode</span> <span class="token keyword">implements</span> <span class="token class-name">ForkJoinPool<span class="token punctuation">.</span>ManagedBlocker</span> <span class="token punctuation">{</span>
        <span class="token comment">// 单向链表</span>
        <span class="token class-name">QNode</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 和 AQS 一样，每个 Node 对应一个 Thread 对象</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 链表的头指针</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">&gt;</span></span> evenQ<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">&gt;</span></span> oddQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了减少并发冲突，这里定义了 2 个链表，也就是 2 个 Treiber Stack。当 phase 为奇数轮的时候，阻塞线程放在 oddQ 里面；当 phase 为偶数轮的时候，阻塞线程放在 evenQ 里面。代码如下所示。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">&gt;</span></span> <span class="token function">queueFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>phase <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> evenQ <span class="token operator">:</span> oddQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-5-arrive-函数分析" tabindex="-1"><a class="header-anchor" href="#_4-5-5-arrive-函数分析" aria-hidden="true">#</a> 4.5.5 arrive() 函数分析</h3><p>下面看 arrive() 函数是如何对 state 变量进行操作，又是如何唤醒线程的。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">arrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doArrive</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">arriveAndDeregister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doArrive</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arrive() 和 arriveAndDeregister() 内部调用的都是 doArrive(boolean) 函数。区别在于前者只是把 “未达到线程数” 减 1；后者则把 “未到达线程数” 和 “下一轮的总线程数” 都减 1。下面看一下 doArrive(boolean) 函数的实现。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">doArrive</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> deregister<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 最低 16 位减 1 或者低 32 位中的 2 个 16 位都减 1</span>
    <span class="token keyword">int</span> adj <span class="token operator">=</span> deregister <span class="token operator">?</span> ONE_ARRIVAL <span class="token operator">|</span> ONE_PARTY <span class="token operator">:</span> ONE_ARRIVAL<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Phaser</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">?</span> state <span class="token operator">:</span> <span class="token function">reconcileState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> phase <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> counts <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> s<span class="token punctuation">;</span>
        <span class="token keyword">int</span> unarrived <span class="token operator">=</span> <span class="token punctuation">(</span>counts <span class="token operator">&amp;</span> UNARRIVED_MASK<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>phase <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> phase<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>counts <span class="token operator">==</span> EMPTY <span class="token operator">||</span> unarrived <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">this</span> <span class="token operator">||</span> <span class="token function">reconcileState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token function">badArrive</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// CAS 减 1</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s <span class="token operator">-=</span> adj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 所有线程到达</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>unarrived <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> n <span class="token operator">=</span> s <span class="token operator">&amp;</span> PARTIES_MASK<span class="token punctuation">;</span>  
                <span class="token keyword">int</span> nextUnarrived <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>n <span class="token operator">&gt;&gt;&gt;</span> PARTIES_SHIFT<span class="token punctuation">;</span>
                <span class="token comment">// 如果父 Phaser 不为空</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
                    <span class="token comment">// 先调用 parent 的 doArrive</span>
                    <span class="token keyword">return</span> parent<span class="token punctuation">.</span><span class="token function">doArrive</span><span class="token punctuation">(</span>nextUnarrived <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">onAdvance</span><span class="token punctuation">(</span>phase<span class="token punctuation">,</span> nextUnarrived<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment">// 最高位置为 1</span>
                    n <span class="token operator">|=</span> TERMINATION_BIT<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nextUnarrived <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    n <span class="token operator">|=</span> EMPTY<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    <span class="token comment">// 下一轮的未到达数等于总的线程个数</span>
                    n <span class="token operator">|=</span> nextUnarrived<span class="token punctuation">;</span>
                <span class="token comment">// phase 加 1</span>
                n <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>phase <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> MAX_PHASE<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PHASE_SHIFT<span class="token punctuation">;</span>
                <span class="token comment">// 重置 state</span>
                UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> s<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 唤醒队列中等待的线程</span>
                <span class="token function">releaseWaiters</span><span class="token punctuation">(</span>phase<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果所有线程没有到达，只是把未到达线程数减 1，什么都不做，该函数返回</span>
            <span class="token keyword">return</span> phase<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于上面的函数，有以下几点说明：</p><ol><li><p>定义了 2 个常量如下。当 deregister = false 时，只最低的 16 位需要减 1，adj = ONE_ARRIVAL；当 deregister = true 时，低 32 位中的 2 个 16 位都需要减 1，adj = ONE_ARRIVAL | ONE_PARTY。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span>  ONE_ARRIVAL <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span>  ONE_PARTY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PARTIES_SHIFT<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>把未到达线程数减 1。减了之后，如果还未到 0，什么都不做，直接返回。如果到 0，会做 2 件事情：第 1，重置 state，把 state 的未到达线程个数重置到总的注册的线程数中，同时 phase 加 1；第 2，唤醒队列中的线程。</p><p>下面看一下唤醒函数：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">releaseWaiters</span><span class="token punctuation">(</span><span class="token keyword">int</span> phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">QNode</span> q<span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>
    <span class="token comment">// 根据 phase 是奇数还是偶数，决定用 evenQ 还是 oddQ。</span>
    <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">&gt;</span></span> head <span class="token operator">=</span> <span class="token punctuation">(</span>phase <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> evenQ <span class="token operator">:</span> oddQ<span class="token punctuation">;</span>
    <span class="token comment">// 遍历栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>phase <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>state <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> q<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历整个栈，只要栈当中节点的 phase 不等于当前 Phaser 的 phase，说明该节点不是当前轮的，而是前一轮的，应该被释放并唤醒。接下来看一下线程是如何被阻塞的。</p></li></ol><h3 id="_4-5-6-awaitadvance-函数分析" tabindex="-1"><a class="header-anchor" href="#_4-5-6-awaitadvance-函数分析" aria-hidden="true">#</a> 4.5.6 awaitAdvance() 函数分析</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">awaitAdvance</span><span class="token punctuation">(</span><span class="token keyword">int</span> phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Phaser</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
    <span class="token comment">// 当只有一个 Phaser，没有树状结构时，root = this</span>
    <span class="token keyword">long</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">?</span> state <span class="token operator">:</span> <span class="token function">reconcileState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// phase 已经结束，不再阻塞了，直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>phase <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> phase<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> phase<span class="token punctuation">)</span>
        <span class="token comment">// 阻塞在 phase 这一轮上面</span>
        <span class="token keyword">return</span> root<span class="token punctuation">.</span><span class="token function">internalAwaitAdvance</span><span class="token punctuation">(</span>phase<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面的 while 循环中有 4 个分支：初始的时候，node == null，进入第 1 个分支进行自旋，自旋次数满足之后，会新建一个 QNode 节点；之后执行第 3、第 4 个分支，分别把该节点入栈并阻塞。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">internalAwaitAdvance</span><span class="token punctuation">(</span><span class="token keyword">int</span> phase<span class="token punctuation">,</span> <span class="token class-name">QNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">releaseWaiters</span><span class="token punctuation">(</span>phase <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          
    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>           
    <span class="token keyword">int</span> lastUnarrived <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            
    <span class="token keyword">int</span> spins <span class="token operator">=</span> SPINS_PER_ARRIVAL<span class="token punctuation">;</span>
    <span class="token keyword">long</span> s<span class="token punctuation">;</span>
    <span class="token keyword">int</span> p<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> state<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 自旋</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           
            <span class="token keyword">int</span> unarrived <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> s <span class="token operator">&amp;</span> UNARRIVED_MASK<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>unarrived <span class="token operator">!=</span> lastUnarrived <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>lastUnarrived <span class="token operator">=</span> unarrived<span class="token punctuation">)</span> <span class="token operator">&lt;</span> NCPU<span class="token punctuation">)</span>
                spins <span class="token operator">+=</span> SPINS_PER_ARRIVAL<span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 由自旋结束，建一个节点，接下来进入阻塞</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted <span class="token operator">||</span> <span class="token operator">--</span>spins <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> phase<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                node<span class="token punctuation">.</span>wasInterrupted <span class="token operator">=</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 由阻塞中唤醒，退出 while 循环</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span> <span class="token punctuation">{</span>           
            <span class="token class-name">AtomicReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QNode</span><span class="token punctuation">&gt;</span></span> head <span class="token operator">=</span> <span class="token punctuation">(</span>phase <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> evenQ <span class="token operator">:</span> oddQ<span class="token punctuation">;</span>
            <span class="token class-name">QNode</span> q <span class="token operator">=</span> node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> q<span class="token punctuation">.</span>phase <span class="token operator">==</span> phase<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>state <span class="token operator">&gt;&gt;&gt;</span> PHASE_SHIFT<span class="token punctuation">)</span> <span class="token operator">==</span> phase<span class="token punctuation">)</span> 
                <span class="token comment">// 节点入栈</span>
                queued <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 调用 node.block() 阻塞</span>
                <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">managedBlock</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                node<span class="token punctuation">.</span>wasInterrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里调用了 ForkJoinPool.managedBlock(ManagedBlocker blocker) 函数，目的是把 node 对应的线程阻塞。ManagerdBlocker 是 ForkJoinPool 里面的一个接口，定义如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">interface</span> <span class="token class-name">ManagedBlocker</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>QNode 实现了该接口，实现原理还是 park()，如下所示。之所以没有直接使用 park() / unpark() 来实现阻塞、唤醒，而是封装了 ManagedBlocker 这一层，主要是出于使用上的方便考虑。一方面是 park() 可能被中断唤醒，另一方面是带超时时间的 park()，把这二者都封装在一起。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">QNode</span> <span class="token keyword">implements</span> <span class="token class-name">ForkJoinPool<span class="token punctuation">.</span>ManagedBlocker</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>phaser<span class="token punctuation">.</span><span class="token function">getPhase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> phase<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            wasInterrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wasInterrupted <span class="token operator">&amp;&amp;</span> interruptible<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                nanos <span class="token operator">-=</span> now <span class="token operator">-</span> lastTime<span class="token punctuation">;</span>
                lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// block 函数封装了 park() 和 parkNanos(xx)，使用起来更方便</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>理解了 arrive() 和 awaitAdvance()，arriveAndAwaitAdvance() 就是二者的一个组合版本，此处不再展开分析。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Java并发实现原理：JDK源码剖析/第4章同步工具类.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC3%E7%AB%A0Lock%E4%B8%8ECondition.html" class="nav-link prev" aria-label="第 3 章 Lock 与 Condition"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 3 章 Lock 与 Condition</div></a><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC5%E7%AB%A0%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html" class="nav-link next" aria-label="第 5 章 并发容器"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 5 章 并发容器<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
