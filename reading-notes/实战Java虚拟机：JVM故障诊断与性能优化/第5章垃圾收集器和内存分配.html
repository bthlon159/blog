<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 5 章 垃圾收集器和内存分配"><meta property="og:type" content="article"><meta property="og:image" content="https://www.cxlsn.cn/"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="第 5 章 垃圾收集器和内存分配"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 5 章 垃圾收集器和内存分配 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link active" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC1%E7%AB%A0%E5%88%9D%E6%8E%A2Java%E8%99%9A%E6%8B%9F%E6%9C%BA.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 初探 Java 虚拟机"><!---->第 1 章 初探 Java 虚拟机<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC2%E7%AB%A0%E8%AE%A4%E8%AF%86Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 认识 Java 虚拟机的基本结构"><!---->第 2 章 认识 Java 虚拟机的基本结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC3%E7%AB%A0%E5%B8%B8%E7%94%A8Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 常用 Java 虚拟机参数"><!---->第 3 章 常用 Java 虚拟机参数<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC4%E7%AB%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 垃圾回收的概念与算法"><!---->第 4 章 垃圾回收的概念与算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 5 章 垃圾收集器和内存分配"><!---->第 5 章 垃圾收集器和内存分配<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-一心一意一件事-串行回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1 一心一意一件事：串行回收器"><!---->5.1 一心一意一件事：串行回收器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-1-新生代串行回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1.1 新生代串行回收器"><!---->5.1.1 新生代串行回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-2-老年代串行回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.1.2 老年代串行回收器"><!---->5.1.2 老年代串行回收器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-人多力量大-并行回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2 人多力量大：并行回收器"><!---->5.2 人多力量大：并行回收器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-1-新生代-parnew-回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2.1 新生代 ParNew 回收器"><!---->5.2.1 新生代 ParNew 回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-2-新生代-parallelgc-回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2.2 新生代 ParallelGC 回收器"><!---->5.2.2 新生代 ParallelGC 回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-3-老年代-paralleloldgc-回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.2.3 老年代 ParallelOldGC 回收器"><!---->5.2.3 老年代 ParallelOldGC 回收器<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-一心多用都不落下-cms-回收器-jdk-8-及之前的版本" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3 一心多用都不落下：CMS 回收器（JDK 8 及之前的版本）"><!---->5.3 一心多用都不落下：CMS 回收器（JDK 8 及之前的版本）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-1-cms-主要工作步骤" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3.1 CMS 主要工作步骤"><!---->5.3.1 CMS 主要工作步骤<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-2-cms-主要的参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3.2 CMS 主要的参数"><!---->5.3.2 CMS 主要的参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-3-cms-的日志分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3.3 CMS 的日志分析"><!---->5.3.3 CMS 的日志分析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-4-有关-class-的回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.3.4 有关 Class 的回收"><!---->5.3.4 有关 Class 的回收<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-未来我做主-g1-回收器-jdk-9-及之后版本的默认回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4 未来我做主：G1 回收器（JDK 9 及之后版本的默认回收器）"><!---->5.4 未来我做主：G1 回收器（JDK 9 及之后版本的默认回收器）<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-1-g1-的内存划分和主要收集过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.1 G1 的内存划分和主要收集过程"><!---->5.4.1 G1 的内存划分和主要收集过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-2-g1-的新生代-gc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.2 G1 的新生代 GC"><!---->5.4.2 G1 的新生代 GC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-3-g1-的并发标记周期" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.3 G1 的并发标记周期"><!---->5.4.3 G1 的并发标记周期<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-4-混合回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.4 混合回收"><!---->5.4.4 混合回收<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-5-必要时的-full-gc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.5 必要时的 Full GC"><!---->5.4.5 必要时的 Full GC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-6-g1-的日志" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.6 G1 的日志"><!---->5.4.6 G1 的日志<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-7-g1-相关的参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.4.7 G1 相关的参数"><!---->5.4.7 G1 相关的参数<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-回眸-有关对象内存分配和回收的一些细节问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5 回眸：有关对象内存分配和回收的一些细节问题"><!---->5.5 回眸：有关对象内存分配和回收的一些细节问题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-1-禁用-system-gc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.1 禁用 System.gc()"><!---->5.5.1 禁用 System.gc()<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-2-system-gc-使用并发回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.2 System.gc() 使用并发回收"><!---->5.5.2 System.gc() 使用并发回收<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-3-并行-gc-前额外触发的新生代-gc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.3 并行 GC 前额外触发的新生代 GC"><!---->5.5.3 并行 GC 前额外触发的新生代 GC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-4-对象何时进入老年代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.4 对象何时进入老年代"><!---->5.5.4 对象何时进入老年代<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-5-在-tlab-上分配对象" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.5 在 TLAB 上分配对象"><!---->5.5.5 在 TLAB 上分配对象<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-6-finalize-函数对垃圾回收的影响" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.5.6 finalize() 函数对垃圾回收的影响"><!---->5.5.6 finalize() 函数对垃圾回收的影响<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-6-温故又知新-常用的-gc-参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.6 温故又知新：常用的 GC 参数"><!---->5.6 温故又知新：常用的 GC 参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-动手才是真英雄-垃圾回收器对-tomcat-性能影响的实验" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7 动手才是真英雄：垃圾回收器对 Tomcat 性能影响的实验"><!---->5.7 动手才是真英雄：垃圾回收器对 Tomcat 性能影响的实验<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-1-配置实验环境" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.1 配置实验环境"><!---->5.7.1 配置实验环境<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-2-配置性能测试工具-jmeter" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.2 配置性能测试工具 JMeter"><!---->5.7.2 配置性能测试工具 JMeter<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-3-配置-web-应用服务器-tomcat" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.3 配置 Web 应用服务器 Tomcat"><!---->5.7.3 配置 Web 应用服务器 Tomcat<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-4-实战案例-1——初试串行回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.4 实战案例 1——初试串行回收器"><!---->5.7.4 实战案例 1——初试串行回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-5-实战案例-2——扩大堆以提升系统性能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.5 实战案例 2——扩大堆以提升系统性能"><!---->5.7.5 实战案例 2——扩大堆以提升系统性能<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-6-实战案例-3——调整初始堆大小" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.6 实战案例 3——调整初始堆大小"><!---->5.7.6 实战案例 3——调整初始堆大小<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-7-实战案例-4——使用-parrelloldgc-回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.7 实战案例 4——使用 ParrellOldGC 回收器"><!---->5.7.7 实战案例 4——使用 ParrellOldGC 回收器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-8-实战案例-5——使用较小堆提高-gc-压力" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.8 实战案例 5——使用较小堆提高 GC 压力"><!---->5.7.8 实战案例 5——使用较小堆提高 GC 压力<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-9-实战案例-6——测试-paralleloldgc-的表现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.9 实战案例 6——测试 ParallelOldGC 的表现"><!---->5.7.9 实战案例 6——测试 ParallelOldGC 的表现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-10-实战案例-7——测试-parnew-回收器的表现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.10 实战案例 7——测试 ParNew 回收器的表现"><!---->5.7.10 实战案例 7——测试 ParNew 回收器的表现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-11-实战案例-8——测试-jdk-1-8-的表现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.11 实战案例 8——测试 JDK 1.8 的表现"><!---->5.7.11 实战案例 8——测试 JDK 1.8 的表现<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-12-实战案例-9——使用高版本虚拟机提升性能" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.7.12 实战案例 9——使用高版本虚拟机提升性能"><!---->5.7.12 实战案例 9——使用高版本虚拟机提升性能<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-8-小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.8 小结"><!---->5.8 小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC6%E7%AB%A0%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 性能监控工具"><!---->第 6 章 性能监控工具<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC7%E7%AB%A0%E5%88%86%E6%9E%90Java%E5%A0%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 分析 Java 堆"><!---->第 7 章 分析 Java 堆<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC8%E7%AB%A0%E9%94%81%E4%B8%8E%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 锁与并发"><!---->第 8 章 锁与并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC9%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 Class 文件结构"><!---->第 9 章 Class 文件结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC10%E7%AB%A0Class%E8%A3%85%E8%BD%BD%E7%B3%BB%E7%BB%9F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 Class 装载系统"><!---->第 10 章 Class 装载系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC11%E7%AB%A0%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 字节码执行"><!---->第 11 章 字节码执行<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 5 章 垃圾收集器和内存分配</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月30日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月30日</span><meta property="datePublished" content="2022-07-30T08:51:46.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月30日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 74 分钟</span><meta property="timeRequired" content="PT74M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年7月30日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 22153 字</span><meta property="wordCount" content="22153"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-一心一意一件事-串行回收器" class="router-link-active router-link-exact-active toc-link level2">5.1 一心一意一件事：串行回收器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-1-新生代串行回收器" class="router-link-active router-link-exact-active toc-link level3">5.1.1 新生代串行回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-1-2-老年代串行回收器" class="router-link-active router-link-exact-active toc-link level3">5.1.2 老年代串行回收器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-人多力量大-并行回收器" class="router-link-active router-link-exact-active toc-link level2">5.2 人多力量大：并行回收器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-1-新生代-parnew-回收器" class="router-link-active router-link-exact-active toc-link level3">5.2.1 新生代 ParNew 回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-2-新生代-parallelgc-回收器" class="router-link-active router-link-exact-active toc-link level3">5.2.2 新生代 ParallelGC 回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-2-3-老年代-paralleloldgc-回收器" class="router-link-active router-link-exact-active toc-link level3">5.2.3 老年代 ParallelOldGC 回收器</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-一心多用都不落下-cms-回收器-jdk-8-及之前的版本" class="router-link-active router-link-exact-active toc-link level2">5.3 一心多用都不落下：CMS 回收器（JDK 8 及之前的版本）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-1-cms-主要工作步骤" class="router-link-active router-link-exact-active toc-link level3">5.3.1 CMS 主要工作步骤</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-2-cms-主要的参数" class="router-link-active router-link-exact-active toc-link level3">5.3.2 CMS 主要的参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-3-cms-的日志分析" class="router-link-active router-link-exact-active toc-link level3">5.3.3 CMS 的日志分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-3-4-有关-class-的回收" class="router-link-active router-link-exact-active toc-link level3">5.3.4 有关 Class 的回收</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-未来我做主-g1-回收器-jdk-9-及之后版本的默认回收器" class="router-link-active router-link-exact-active toc-link level2">5.4 未来我做主：G1 回收器（JDK 9 及之后版本的默认回收器）</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-1-g1-的内存划分和主要收集过程" class="router-link-active router-link-exact-active toc-link level3">5.4.1 G1 的内存划分和主要收集过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-2-g1-的新生代-gc" class="router-link-active router-link-exact-active toc-link level3">5.4.2 G1 的新生代 GC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-3-g1-的并发标记周期" class="router-link-active router-link-exact-active toc-link level3">5.4.3 G1 的并发标记周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-4-混合回收" class="router-link-active router-link-exact-active toc-link level3">5.4.4 混合回收</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-5-必要时的-full-gc" class="router-link-active router-link-exact-active toc-link level3">5.4.5 必要时的 Full GC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-6-g1-的日志" class="router-link-active router-link-exact-active toc-link level3">5.4.6 G1 的日志</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-4-7-g1-相关的参数" class="router-link-active router-link-exact-active toc-link level3">5.4.7 G1 相关的参数</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-回眸-有关对象内存分配和回收的一些细节问题" class="router-link-active router-link-exact-active toc-link level2">5.5 回眸：有关对象内存分配和回收的一些细节问题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-1-禁用-system-gc" class="router-link-active router-link-exact-active toc-link level3">5.5.1 禁用 System.gc()</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-2-system-gc-使用并发回收" class="router-link-active router-link-exact-active toc-link level3">5.5.2 System.gc() 使用并发回收</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-3-并行-gc-前额外触发的新生代-gc" class="router-link-active router-link-exact-active toc-link level3">5.5.3 并行 GC 前额外触发的新生代 GC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-4-对象何时进入老年代" class="router-link-active router-link-exact-active toc-link level3">5.5.4 对象何时进入老年代</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-5-在-tlab-上分配对象" class="router-link-active router-link-exact-active toc-link level3">5.5.5 在 TLAB 上分配对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-5-6-finalize-函数对垃圾回收的影响" class="router-link-active router-link-exact-active toc-link level3">5.5.6 finalize() 函数对垃圾回收的影响</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-6-温故又知新-常用的-gc-参数" class="router-link-active router-link-exact-active toc-link level2">5.6 温故又知新：常用的 GC 参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-动手才是真英雄-垃圾回收器对-tomcat-性能影响的实验" class="router-link-active router-link-exact-active toc-link level2">5.7 动手才是真英雄：垃圾回收器对 Tomcat 性能影响的实验</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-1-配置实验环境" class="router-link-active router-link-exact-active toc-link level3">5.7.1 配置实验环境</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-2-配置性能测试工具-jmeter" class="router-link-active router-link-exact-active toc-link level3">5.7.2 配置性能测试工具 JMeter</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-3-配置-web-应用服务器-tomcat" class="router-link-active router-link-exact-active toc-link level3">5.7.3 配置 Web 应用服务器 Tomcat</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-4-实战案例-1——初试串行回收器" class="router-link-active router-link-exact-active toc-link level3">5.7.4 实战案例 1——初试串行回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-5-实战案例-2——扩大堆以提升系统性能" class="router-link-active router-link-exact-active toc-link level3">5.7.5 实战案例 2——扩大堆以提升系统性能</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-6-实战案例-3——调整初始堆大小" class="router-link-active router-link-exact-active toc-link level3">5.7.6 实战案例 3——调整初始堆大小</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-7-实战案例-4——使用-parrelloldgc-回收器" class="router-link-active router-link-exact-active toc-link level3">5.7.7 实战案例 4——使用 ParrellOldGC 回收器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-8-实战案例-5——使用较小堆提高-gc-压力" class="router-link-active router-link-exact-active toc-link level3">5.7.8 实战案例 5——使用较小堆提高 GC 压力</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-9-实战案例-6——测试-paralleloldgc-的表现" class="router-link-active router-link-exact-active toc-link level3">5.7.9 实战案例 6——测试 ParallelOldGC 的表现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-10-实战案例-7——测试-parnew-回收器的表现" class="router-link-active router-link-exact-active toc-link level3">5.7.10 实战案例 7——测试 ParNew 回收器的表现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-11-实战案例-8——测试-jdk-1-8-的表现" class="router-link-active router-link-exact-active toc-link level3">5.7.11 实战案例 8——测试 JDK 1.8 的表现</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-7-12-实战案例-9——使用高版本虚拟机提升性能" class="router-link-active router-link-exact-active toc-link level3">5.7.12 实战案例 9——使用高版本虚拟机提升性能</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC5%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html#_5-8-小结" class="router-link-active router-link-exact-active toc-link level2">5.8 小结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-5-章-垃圾收集器和内存分配" tabindex="-1"><a class="header-anchor" href="#第-5-章-垃圾收集器和内存分配" aria-hidden="true">#</a> 第 5 章 垃圾收集器和内存分配</h1><p>在 Java 虚拟机中，垃圾回收器可不只有一种，什么情况下要使用哪一种，对性能又有什么样的影响，这都是我们必须要了解的。本章将具体介绍虚拟机中的垃圾回收器类型，以及它们的特点和使用方法，并进一步探讨对象在内存中的分配和回收的问题。</p><p>本章涉及的主要知识点有：</p><ul><li>Java 虚拟机支持的垃圾回收器种类。</li><li>串行垃圾回收器。</li><li>并行垃圾回收器。</li><li>CMS 回收器。</li><li>G1 回收器。</li><li>有关对象分配的一些细节问题。</li></ul><h2 id="_5-1-一心一意一件事-串行回收器" tabindex="-1"><a class="header-anchor" href="#_5-1-一心一意一件事-串行回收器" aria-hidden="true">#</a> 5.1 一心一意一件事：串行回收器</h2><p>串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往能让其有更好的性能表现。串行回收器可以在新生代和老年代使用，根据不同的堆空间分为新生代串行回收器和老年代串行回收器。</p><h3 id="_5-1-1-新生代串行回收器" tabindex="-1"><a class="header-anchor" href="#_5-1-1-新生代串行回收器" aria-hidden="true">#</a> 5.1.1 新生代串行回收器</h3><p>串行回收器是所有垃圾回收器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。串行回收器主要有两个特点：</p><p>第一，它仅仅使用单线程进行垃圾回收。</p><p>第二，它是独占式的垃圾回收方式。</p><p>在串行回收器进行垃圾回收时，Java 应用程序中的线程都需要暂停工作，等待垃圾回收完成。如图5.1 所示，在串行回收器运行时，应用程序中的所有线程都停止工作，进行等待，这种现象称为 &quot;Stop-The-World”。它将造成非常糟糕的用户体验，在实时性要求较高的应用场景中，这往往是不能被接受的。</p><p><img src="/assets/图5-1.f5cd69d4.png" alt="图5-1" loading="lazy"></p><p>图5.1 串行回收示意图</p><p>虽然如此，串行回收器却是一种成熟且经过长时间生产环境考验的极为高效的收集器。新生代串行回收器使用复制算法，实现相对简单、逻辑处理特别高效且没有线程切换的开销。在诸如单 CPU 处理器等硬件平台不是特别优越的情况下，它的性能表现可以超过并行回收器和并发回收器。</p><p>使用 -XX:+UseSerialGC 参数可以指定使用新生代串行回收器或老年代串行回收器。当虚拟机在 Client 模式下运行时，它是默认的垃圾回收器。</p><p>新生代串行回收器的输出日志如下（使用 -XX:+PrintGCDetails 开关）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	0.844: [GC 0.844: [DefNew: 17472K-&gt;2176K(19648K), 0.0188339 secs] 17472K-&gt; 2375K(63360K), 0.0189186 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它显示了一次垃圾回收前的新生代内存占用量和垃圾回收后的新生代内存占用量，以及垃圾回收所消耗的时间。</p><p><strong>注意</strong>：串行垃圾回收器虽然古老，但是久经考验，在大多数情况下，其性能表现是相当不错的。</p><h3 id="_5-1-2-老年代串行回收器" tabindex="-1"><a class="header-anchor" href="#_5-1-2-老年代串行回收器" aria-hidden="true">#</a> 5.1.2 老年代串行回收器</h3><p>老年代串行回收器使用的是标记压缩法。和新生代串行回收器一样，它也是一个串行的、独占式的垃圾回收器。由于老年代垃圾回收通常会需要比新生代垃圾回收更长的时间，在堆空间较大的应用程序中，一旦老年代串行回收器启动，应用程序很可能会因此停顿较长的时间。</p><p>虽然如此，作为老牌的垃圾回收器，老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。</p><p>若要启用老年代串行回收器，可以尝试使用以下参数。</p><ul><li><p>-XX:+UseSerialGC：新生代、老年代都使用串行回收器。</p></li><li><p>-XX:+UseParNewGC（JDK 9、JDK 10 已经删除，因为 ParNew 需要和 CMS 搭配工作，而 CMS 己经被 G1 替代，不再支持此参数）：新生代使用 ParNew 回收器，老年代使用串行回收器。</p></li><li><p>-XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。</p></li></ul><p>老年代串行回收器的输出日志类如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	8.259: [Full GC 8.259: [Tenured: 43711K-&gt;40302K(43712K), 0.2960477 secs] 63350K-&gt;40302K(63360K), [Perm: 17836K-&gt;17836K(32768K)], 0.2961554 secs] [Times: user=0.28 sys=0.02, real=0.30 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它显示了垃圾回收前老年代和永久区的内存占用量，以及垃圾回收后老年代和永久区的内存占用量。</p><h2 id="_5-2-人多力量大-并行回收器" tabindex="-1"><a class="header-anchor" href="#_5-2-人多力量大-并行回收器" aria-hidden="true">#</a> 5.2 人多力量大：并行回收器</h2><p>并行回收器在串行回收器的基础上做了改进，它使用多个线程同时进行垃圾回收。对于并行能力强的计算机，可以有效减少垃圾回收所需的实际时间。</p><h3 id="_5-2-1-新生代-parnew-回收器" tabindex="-1"><a class="header-anchor" href="#_5-2-1-新生代-parnew-回收器" aria-hidden="true">#</a> 5.2.1 新生代 ParNew 回收器</h3><p>ParNew 回收器是一个工作在新生代的垃圾回收器。它只是简单地将串行回收器多线程化，它的回收策略、算法及参数和新生代串行回收器一样。ParNew 回收器的工作示意图如图5.2 所示。ParNew 回收器也是独占式的回收器，在回收过程中应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。</p><p><img src="/assets/图5-2.6fb266fa.png" alt="图5-2" loading="lazy"></p><p>图5.2 ParNew 回收器的工作示意图</p><p>开启 ParNew 回收器可以使用以下参数。</p><ul><li><p>-XX:+UseParNewGC（JDK 9、JDK 10 已经删除，因为 ParNew 需要和 CMS 搭配工作，而 CMS 已经被 G1 替代，不再支持此参数）：新生代使用 ParNew 回收器，老年代使用串行回收器。</p></li><li><p>-XX:+UseConcMarkSweepGC（JDK 9、JDK 10 不建议使用，建议使用默认的 G1 垃圾回收器）：新生代使用 ParNew 回收器，老年代使用 CMS。</p></li></ul><p>ParNew 回收器工作时的线程数量可以使用 -XX:ParallelGCThreads 参数指定。一般，最好与 CPU 数量相当，避免过多的线程数影响垃圾回收性能。在默认情况下，当 CPU 数量小于 8 时，ParallelGCThreads 的值等于 CPU 数量，当 CPU 数量大于 8 时，ParallelGCThreads 的值等于 3 + ((5 * CPU_Count) / 8)。</p><p>ParNew 回收器的输出日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    0.834 : [GC 0.834: [ParNew: 13184K-&gt;1600K(14784K), 0.0092203 secs] 13184K-&gt; 1921K(63936K), 0.0093401 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，这个输出和新生代串行回收器的输出几乎是一样的，只有回收器标识符不同。</p><h3 id="_5-2-2-新生代-parallelgc-回收器" tabindex="-1"><a class="header-anchor" href="#_5-2-2-新生代-parallelgc-回收器" aria-hidden="true">#</a> 5.2.2 新生代 ParallelGC 回收器</h3><p>新生代 ParallelGC 回收器也是使用复制算法的回收器。从表面上看，它和 ParNew 回收器一样，都是多线程、独占式的回收器。但是，ParallelGC 回收器有一个重要的特点：它非常关注系统的吞吐量。</p><p>新生代 ParallelGC 回收器可以使用以下参数启用。</p><ul><li><p>-XX:+UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。</p></li><li><p>-XX:+UseParallelOldGC：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。</p></li></ul><p>ParallelGC 回收器提供了两个重要的参数用于控制系统的吞吐量。</p><ul><li><p>-XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。它的值是一个大于 0 的整数。ParallelGC 在工作时，会调整 Java 堆大小或者其他参数，尽可能地把停顿时间控制在 MaxGCPauseMillis 以内。如果读者希望减少停顿时间而把这个值设得很小，为了达到预期的停顿时间，虚拟机可能会使用一个较小的堆（一个小堆比一个大堆回收快），而这将导致垃圾回收变得很频繁，从而增加垃圾回收总时间，降低吞吐量。</p></li><li><p>-XX:GCTimeRatio：设置吞吐量大小。它的值是一个 0 到 100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1 / (1 + n) 的时间进行垃圾回收。比如 GCTimeRatio 等于 19（默认值），则系统用于垃圾回收的时间不超过 1 / (1 + 19) = 5%。默认情况下，它的取值是 99，即有不超过1 / (1 + 99) = 1% 的时间用于垃圾回收。</p></li></ul><p>除此之外，ParallelGC 回收器与 ParNew 回收器另一个不同之处在于，它还支持一种自适应的 GC 调节策略。使用 -XX:+UseAdaptiveSizePolicy 可以打开自适应 GC 策略。在这种模式下，新生代的大小、eden 区和 survivor 区的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。在手工调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p><p>ParallelGC 回收器的输出日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	0.880: [GC [PSYoungGen: 16448K-&gt;2439K(19136K)] 16448K-&gt;2439K(62848K), 0.0064912 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它显示了 ParallelGC 回收器的工作成果，也就是回收前的内存大小和回收后的内存大小，以及花费的时间。</p><p><strong>注意</strong>：ParallelGC 回收器关注系统吞吐量。可以通过 -XX:MaxGCPauseMillis 和 -XX:GCTimeRatio 设置期望的停顿时间和吞吐量。但是鱼和熊掌不可兼得，这两个参数是相互矛盾的，通常如果减少一次收集的最大停顿时间，就会同时减小系统吞吐量，增加系统吞吐量又可能会同时增加一次垃圾回收的最大停顿时间。</p><h3 id="_5-2-3-老年代-paralleloldgc-回收器" tabindex="-1"><a class="header-anchor" href="#_5-2-3-老年代-paralleloldgc-回收器" aria-hidden="true">#</a> 5.2.3 老年代 ParallelOldGC 回收器</h3><p>老年代 ParallelOldGC 回收器也是一种多线程并发的回收器。和新生代 ParallelGC 回收器一样，它也是一种关注吞吐量的回收器。从名字上看，它在 ParallelGC 中间插入了 Old，表示这是一个应用于老年代的回收器，并且和 ParallelGC 新生代回收器搭配使用。</p><p>ParallelOldGC 回收器使用标记压缩法，它在 JDK 1.6 中才可以使用。图5.3 为老年代 ParallelOldGC 回收器工作示意图。</p><p><img src="/assets/图5-3.2fabb51a.png" alt="图5-3" loading="lazy"></p><p>图5.3 老年代 ParallelOldGC 回收器工作示意图</p><p>使用 -XX:+UseParallelOldGC 可以在新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。这是一对非常关注吞吐量的垃圾回收器。在对吞吐量敏感的系统中，可以考虑使用。参数 -XX:ParallelGCThreads 也可以用于设置垃圾回收时的线程数量。</p><p>ParallelOldGC 回收器的输出日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	1.500: [Full GC [PSYoungGen: 2682K-&gt;0K(19136K)] [ParOldGen: 28035K-&gt;30437K (43712K)] 30717K-&gt;30437K(62848K) [PSPermGen: 10943K-&gt;10928K(32768K)], 0.2902791 secs] [Times: user=l.44 sys=0.03, real=0.30 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它显示了新生代、老年代及永久区在回收前、后的情况，以及 Full GC 所消耗的时间。</p><h2 id="_5-3-一心多用都不落下-cms-回收器-jdk-8-及之前的版本" tabindex="-1"><a class="header-anchor" href="#_5-3-一心多用都不落下-cms-回收器-jdk-8-及之前的版本" aria-hidden="true">#</a> 5.3 一心多用都不落下：CMS 回收器（JDK 8 及之前的版本）</h2><p>与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上就可以得知，它使用的是标记清除法，同时它又是一个使用多线程并行回收的垃圾回收器。</p><h3 id="_5-3-1-cms-主要工作步骤" tabindex="-1"><a class="header-anchor" href="#_5-3-1-cms-主要工作步骤" aria-hidden="true">#</a> 5.3.1 CMS 主要工作步骤</h3><p>CMS 回收器的工作过程与其他垃圾回收器相比，略显复杂。CMS 工作时的主要步骤有：初始标记、并发标记、预清理、重新标记、并发清除和并发重置。其中初始标记和重新标记是独占系统资源的，而预清理、并发标记、并发清除和并发重置是可以和用户线程一起执行的。从整体上说，CSM 不是独占式的，它可以在应用程序运行过程中进行垃圾回收。CMS 的工作流程如图5.4 所示。</p><p><img src="/assets/图5-4.24f68f69.png" alt="图5-4" loading="lazy"></p><p>图5.4 CMS 的工作流程</p><p>根据标记清除法，初始标记、并发标记和重新标记都是为了标记出需要回收的对象。并发清理则是在标记完成后，正式回收垃圾对象。并发重置是指在垃圾回收完成后，重新初始化 CMS 数据结构和数据，为下一次垃圾回收做好准备。并发标记、并发清理和并发重置都是可以和应用程序线程一起执行的。</p><p>在整个 CMS 的回收过程中，默认情况下，在并发标记之后，会有一个预清理的操作（也可以关闭开关 -XX:-CMSPrecleaningEnabled，不进行预清理）。预清理是并发的，除了为正式清理做准备和检查，还会尝试控制一次停顿的时间。由于重新标记是独占 CPU 的，如果新生代 GC 发生后，立即触发一次重新标记，那么一次停顿的时间可能很长。为了避免这种情况，预处理时会刻意等待一次新生代 GC 的发生，然后根据历史性能数据预测下一次新生代 GC 可能发生的时间，在当前时间和预测时间的中间时刻进行重新标记。这样可尽量避免新生代 GC 和重新标记重合，尽可能减少一次停顿的时间。</p><h3 id="_5-3-2-cms-主要的参数" tabindex="-1"><a class="header-anchor" href="#_5-3-2-cms-主要的参数" aria-hidden="true">#</a> 5.3.2 CMS 主要的参数</h3><p>启用 CMS 回收器的参数是 -XX:+UseConcMarkSweepGC。CMS 是多线程回收器，设置合理的工作线程数量对系统性能有重要的影响。</p><p>CMS 默认启动的并发线程数是 (ParallelGCThreads + 3) / 4。ParallelGCThreads 表示 GC 并行时使用的线程数量，如果新生代使用 ParNew，那么 ParallelGCThreads 也就是新生代 GC 的线程数量。这意味着有 4 个 ParallelGCThreads 时，只有 1 个并发线程，而有两个并发线程时，有 5 ~ 8 个 ParallelGCThreads 线程。</p><p>并发线程数量也可以通过 -XX:ConcGCThreads 或者 -XX:ParallelCMSThreads 参数手工设定。当 CPU 资源比较紧张时，受到 CMS 回收器线程的影响，应用系统的性能在垃圾回收阶段可能会非常糟糕。</p><p><strong>注意</strong>：并发是指收集器和应用线程交替执行，并行是指应用程序停止，同时由多个线程一起执行 GC。因此并行回收器不是并发的，因为并行回收器执行时，应用程序完全挂起，不存在交替执行。</p><p>由于 CMS 回收器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，CMS 回收器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率达到某一阈值时便开始进行回收，以确保应用程序在 CMS 工作过程中，依然有足够的空间支持应用程序运行。</p><p>这个回收阈值可以使用参数 -XX:CMSInitiatingOccupancyFraction 来指定，默认是 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。如果应用程序的内存使用率增长很快，在 CMS 的执行过程中，己经出现了内存不足的情况，CMS 回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收。此时，应用程序将完全中断，直到垃圾回收完成，这时，应用程序的停顿时间可能会较长。</p><p><strong>注意</strong>：通过 -XX:CMSInitiatingOccupancyFraction 可以指定当老年代空间使用率达到多少时进行一次 CMS 垃圾回收。</p><p>根据应用程序的特点，可以对参数 -XX:CMSInitiatingOccupancyFraction 进行调优。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数，可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行回收器。</p><p>CMS 是一个基于标记清除法的回收器。在本章之前的篇幅中已经提到，标记清除法将会产生大量内存碎片，离散的可用空间无法分配给较大的对象。图5.5 显示了 CMS 回收前、后老年代的情况。</p><p><img src="/assets/图5-5.24221a93.png" alt="图5-5" loading="lazy"></p><p>图5.5 CMS 回收前、后老年代对比示意图</p><p>在这种情况下，即使堆内存仍然有较大的剩余空间，也可能会被迫进行一次垃圾回收，以换取一块可用的连续内存。这种现象对系统性能是相当不利的，为了解决这个问题，CMS 回收器还提供了几个用于内存压缩整理的参数。</p><ul><li><p>-XX:+UseCMSCompactAtFullCollection 参数可以使 CMS 在垃圾收集完成后，进行一次内存碎片整理，内存碎片的整理不是并发进行的。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction 参数可以用于设定进行多少次 CMS 回收后，进行一次内存压缩。</p></li></ul><h3 id="_5-3-3-cms-的日志分析" tabindex="-1"><a class="header-anchor" href="#_5-3-3-cms-的日志分析" aria-hidden="true">#</a> 5.3.3 CMS 的日志分析</h3><p>CMS 回收器工作时的日志输出如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	1.313: [GC [1 CMS-initial-mark: 69112K(136576K)] 77037K(198016K), 0.0120453 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
	1.325: [CMS-concurrent-mark-start]
	1.342: [GC1.342: [ParNew: 61440K-&gt;4557K(61440K), 0.0025283 secs] 130552K-&gt;74933K(198016K), 0.0026144 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	1.365: [GC1.365: [ParNew: 59213K-&gt;5972K(61440K), 0.0036258 secs] 129589K-&gt;77612K(198016K), 0.0037053 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	1.388: [GC1.388: [ParNew: 60628K-&gt;6468K(61440K), 0.0025254 secs] 132268K-&gt;79371K(198016K), 0.0026154 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	1.406: [CMS-concurrent-mark: 0.072/0.082 secs] [Times: user=0.17 sys=0.00, secs]
	1.406: [CMS-concurrent-preclean-start]
	1.409: [CMS-concurrent-preclean: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, secs]
	1.406: [CMS-concurrent-abortable-preclean-start]
	1.411: [GC1.411: [ParNew: 61124K-&gt;4691K(61440K), 0.0025330 secs] 134027K-&gt;78858K(198016K), 0.0026144 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	1.422: [CMS-concurrent-abortable-preclean: 0.011/0.014 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]
	1.423: [GC[YG occupancy: 35483K (61440K)] 1.423: [Rescan (parallel), 0.0102064 secs]1.433 : [weak refs processing, 0.0000142 secs] 1.433: [scrub string table,0.0000298 secs] [1 CMS-remark: 74166K (136576K) ] 109650K (198016K) , 0.0103386 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
	1.433: [CMS-concurrent-sweep-start]
	1.445: [GC1.445: [ParNew: 59347K-&gt;6001K(61440K), 0.0037510 secs] 132617K-&gt;80535K(198016K), 0.0038390 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	1.450: [CMS-concurrent-sweep: 0.013/0.017 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]
	1.450: [CMS-concurrent-reset-start]
	1.451: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.02 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上信息是一次 CMS 回收的输出。可以看到，在 CMS 回收器工作过程中，包括初始化标记、并发标记、预清理、重新标记、并发清理和重发重置等几个重要阶段。在日志中，还可以看到 CMS 的耗时及堆内存信息。</p><p>在 1.409 秒发生 abortable-preclean，表示 CMS 开始等待一次新生代 GC。在 1.411 秒 ParNew 回收器开始工作，在 1.422 秒 abortable-preclean 终止。之后，CMS 根据之前新生代 GC 的情况，将重新标记的时间放在一个最不可能和下一次新生代 GC 重叠的时刻，即两次新生代 GC 的中间点，这里为 1.423 秒处。</p><p>除此之外，CMS 回收器在运行时还可能输出如下日志：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	33.348: [Full GC 33.348: [CMS33.357: [CMS-concurrent-sweep: 0.035/0.036 secs] [Times: user=0.11 sys=0.03, real=0.03 secs]
	(concurrent mode failure): 47066K-&gt;39901K(49152K), 0.3896802 secs] 60771K-&gt; 39901K(63936K), [CMS Perm : 22529K-&gt;22529K(32768K)], 0.3897989 secs] [Times: user=0.39 sys=0.00, real=0.39 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这说明 CMS 回收器并发回收失败。这很可能是应用程序在运行过程中老年代空间不够导致的。如果在 CMS 工作过程中，出现非常频繁的并发模式失败，就应该考虑进行调整，尽可能预留一个较大的老年代空间。或者可以设置一个较小的 -XX:CMSInitiatingOccupancyFraction 参数，降低 CMS 触发的阈值，使 CMS 在执行过程中仍然有较大的老年代空闲空间供应用程序使用。</p><p><strong>注意</strong>：CMS 回收器是一个关注停顿的垃圾回收器。同时 CMS 回收器在部分工作流程中，可以与用户程序同时运行，从而减少应用程序的停顿时间。</p><h3 id="_5-3-4-有关-class-的回收" tabindex="-1"><a class="header-anchor" href="#_5-3-4-有关-class-的回收" aria-hidden="true">#</a> 5.3.4 有关 Class 的回收</h3><p>在使用 CMS 回收器时，如果需要回收 Perm 区，那么默认情况下，还需要触发一次 Full GC，如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	[Full GC[CMS: 4624K-&gt;2047K(10944K), 0.0156648 secs] 7191K-&gt;2047K(15936K), [CMS Perm : 4096K-&gt;2145K(4096K)], 0.0157072 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果希望使用 CMS 回收器回收 Perm 区，则必须打开 -XX:+CMSClassUnloadingEnabled 开关。使用 -XX:+CMSClassUnloadingEnabled 后，如果条件允许，系统会使用 CMS 的机制回收 Perm 区的 Class 数据，日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	[GC [1 CMS-initial-mark: 6035K(10944K)] 6640K(15936K), 0.0007878 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
	[CMS-concurrent-mark: 0.008/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
	[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00r real=0.00 secs]
	[GC[YG occupancy: 1070 K (4992 K)][Rescan (parallel) , 0.0008064 secs][weak refs processing, 0.0001239 secs][class unloading, 0.0016846 secs][scrub symbol table, 0.0004835 secs][scrub string table, 0.0000285 secs][1 CMS-remark: 6035K(10944K)] 7105K(15936K), 0.0033860 secs] [Times: user=0.00 sys=0.00r real=0.00 secs]
	[CMS-concurrent-sweep: 0.009/0.009 secs] [Times: user=0.00 sys=0.00r real=0.01 secs]
	[CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00r real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-4-未来我做主-g1-回收器-jdk-9-及之后版本的默认回收器" tabindex="-1"><a class="header-anchor" href="#_5-4-未来我做主-g1-回收器-jdk-9-及之后版本的默认回收器" aria-hidden="true">#</a> 5.4 未来我做主：G1 回收器（JDK 9 及之后版本的默认回收器）</h2><p>G1 回收器（Garbage-First）是在 JDK 1.7 中正式使用的全新的垃圾回收器，从长期目标来看，它是为了取代 CMS 回收器。G1 回收器拥有独特的垃圾回收策略，和之前提到的回收器截然不同。从分代上看，G1 依然属于分代垃圾回收器，它会区分年轻代和老年代，依然有 eden 区和 survivor 区，但从堆的结构上看，它并不要求整个 eden 区、年轻代或者老年代都连续。它使用了分区算法。作为 CMS 的长期替代方案，G1 使用了全新的分区算法，其特点如下。</p><ul><li><p>并行性：G1 在回收期间，可以由多个 GC 线程同时工作，有效利用多核计算能力。</p></li><li><p>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，一般来说，不会在整个回收期间完全阻塞应用程序。</p></li><li><p>分代 GC：G1 依然是一个分代回收器，但是和之前的回收器不同，它同时兼顾年轻代和老年代，其他回收器或者工作在年轻代，或者工作在老年代。</p></li><li><p>空间整理：G1 在回收过程中，会进行适当的对象移动，不像 CMS，只是简单地标记清理对象，在若干次 GC 后，CMS 必须进行一次碎片整理。而 G1 不同，它每次回收都会有效地复制对象，减少碎片空间。</p></li><li><p>可预见性：由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，全局停顿也能得到较好的控制。</p></li></ul><h3 id="_5-4-1-g1-的内存划分和主要收集过程" tabindex="-1"><a class="header-anchor" href="#_5-4-1-g1-的内存划分和主要收集过程" aria-hidden="true">#</a> 5.4.1 G1 的内存划分和主要收集过程</h3><p>G1 将堆进行分区，划分为一个个的区域，每次回收的时候，只回收其中几个区域，以此来控制垃圾回收产生的一次停顿的时间。</p><p>G1 的回收过程可能有 4 个阶段：</p><ul><li><p>新生代 GC。</p></li><li><p>并发标记周期。</p></li><li><p>混合回收。</p></li><li><p>如果需要，可能会进行 Full GC。</p></li></ul><h3 id="_5-4-2-g1-的新生代-gc" tabindex="-1"><a class="header-anchor" href="#_5-4-2-g1-的新生代-gc" aria-hidden="true">#</a> 5.4.2 G1 的新生代 GC</h3><p>新生代 GC 的主要工作是回收 eden 区和 survivor 区。一旦 eden 区被占满，新生代 GC 就会启动。新生代 GC 前、后的堆数据示例如图5.6 所示，其中 E 表示 eden 区，S 表示 survivor 区，O 表示老年代。可以看到，新生代 GC 只处理 eden 区和 survivor 区，回收后所有的 eden 区都应该被清空，而 survivor 区会被回收一部分数据，但是应该至少仍然存在一个 survivor 区，类比其他的新生代回收器，这一点似乎并没有太大变化。另一个重要的变化是，老年代的区域增多，因为部分 survivor 区或者 eden 区的对象可能会晋升到老年代。</p><p><img src="/assets/图5-6.5adbfb71.png" alt="图5-6" loading="lazy"></p><p>图5.6 新生代 GC 前、后的堆数据示例</p><p>新生代 GC 发生后，如果打开了 PrintGCDetails 选项，就可以得到类似如下的 GC 日志（这里只给出了部分日志，完全的日志及其分析请看 5.4.6 节)：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>0.336: [GC pause (young), 0.0063051 secs]
...
[Eden: 235.0M(235.0M)-&gt;0.0B(229.0M) Survivors: 5120.0K-&gt;11.0M Heap: 239.2M(400.0M)-&gt;10.5M(400.0M)] 
[Times: user=0.06 sys=0.00, real=0.01 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和其他回收器的日志相比，G1 的日志内容非常丰富。当然我们最关心的依然是 GC 的停顿时间及回收情况。从日志中可以看到，edcn 区原本占用 235MB 空间，回收后被清空，survivor 区从 5MB 增长到了 11MB，这是因为部分对象被从 eden 区复制到 survivor 区，整个堆合计为 400MB，堆内存从回收前的 239MB 下降到 10.5MB。</p><h3 id="_5-4-3-g1-的并发标记周期" tabindex="-1"><a class="header-anchor" href="#_5-4-3-g1-的并发标记周期" aria-hidden="true">#</a> 5.4.3 G1 的并发标记周期</h3><p>G1 的并发阶段和 CMS 有点类似，它们都是为了降低一次停顿时间，而将可以和应用程序并发的部分单独提取出来执行。</p><p>并发标记周期可以分为以下几步。</p><ul><li><p>初始标记：标记从根节点直接可达的对象。这个阶段会伴随一次新生代 GC，它是会产生全局停顿的，应用程序线程在这个阶段必须停止执行。</p></li><li><p>根区域扫描：由于初始标记必然会伴随一次新生代 GC，所以在初始化标记后，eden 区被清空，并且存活对象被移入 survivor 区。在这个阶段，将扫描由 survivor 区直接可达的老年代区域，并标记这些直接可达的对象。这个过程是可以和应用程序并发执行的。但是根区域扫描不能和新生代 GC 同时执行（因为根区域扫描依赖 survivor 区的对象，而新生代 GC 会修改这个区域），因此如果恰巧在此时需要进行新生代 GC，就需要等待根区域扫描结束后才能进行。如果发生这种情况，这次新生代 GC 的时间就会延长。</p></li><li><p>并发标记：和 CMS 类似，并发标记将会扫描并查找整个堆的存活对象，并做好标记。这是一个并发的过程，并且这个过程可以被一次新生代 GC 打断。</p></li><li><p>重新标记：和 CMS 一样，重新标记也是会产生应用程序停顿的。由于在并发标记过程中，应用程序依然在运行，因此标记结果可能需要进行修正，所以在此对上一次的标记结果进行补充。在 G1 中，这个过程使用 SATB（Snapshot-At-The-Beginning）算法完成，即 G1 会在标记之初为存活对象创建一个快照，这个快照有助于加速重新标记的速度。</p></li><li><p>独占清理：这个阶段是会引起停顿的。它将计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可供混合回收的区域。在这个阶段，还会更新记忆集（Remebered Set）。该阶段给出了需要被混合回收的区域并进行了标记，在混合回收阶段需要这些信息。</p></li><li><p>并发清理：这里会识别并清理完全空闲的区域。它是并发的清理，不会引起停顿。</p></li></ul><p>图5.7 显示了并发标记周期前后堆的可能情况。由于并发标记周期包含一次新生代 GC，故新生会被整理，但由于并发标记周期执行时，应用程序依然在运行，所以并发标记周期结束后，又会有新的 eden 区的空间被使用。并发标记周期执行前后最大的不同是在该阶段后，系统增加了一些标记为 G 的区域。这些区域被标记，是因为它们内部的垃圾比例较高，希望在后续的混合 GC 中进行收集（注意在并发标记周期中并未正式收集这些区域）。这些将要被回收的区域会被 G1 记录在一个称为 Collection Sets（回收集）的集合中。</p><p><img src="/assets/图5-7.77e40e2c.png" alt="图5-7" loading="lazy"></p><p>图5.7 并发标记周期前、后堆的可能情况</p><p>并发回收阶段的整体工作流程如图5.8 所示，可以看到除了初始标记、重新标记和独占清理，其他几个阶段都可以和应用程序并发执行。</p><p><img src="/assets/图5-8.8935d385.png" alt="图5-8" loading="lazy"></p><p>图5.8 并发回收阶段的整体工作流程</p><p>在并发标记周期中，G1 会产生如下日志。</p><ol><li><p>初始标记，它伴随一次新生代 GC。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.765: [GC pause (young) (initial-mark), 0.0052941 secs]
...
[Eden: 61.0M(61.0M)-&gt;0.0B(57.0M) Survivors: 3072.0K-&gt;5120.OK Heap: 174.8M (200.0M)-&gt;116.3M(200.0M)]
[Times: user=0.00 sys=0.00, real=0.01 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，初始化标记时，eden 区被清空，并部分复制到 survivor 区。</p></li><li><p>一次并发的根区域扫描，并发扫描过程不能被新生代 GC 中断。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.771: [GC concurrent-root-region-scan-start]
1.772: [GC concurrent-root-region-scan-end, 0.0011676 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>根区域扫描不会产生停顿。</p></li><li><p>并发标记，并发标记可以被新生代 GC 打断，下面的日志显示了一次并发标记被 3 次新生代 GC 打断。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.772: [GC concurrent-mark-start]
1.793: [GC pause (young), 0.0057816 secs]
...
[Eden: 57.0M(57.0M)-&gt;0.0B(55.0M) Survivors: 5120.0K-&gt;6144.0K Heap: 173.3M(200.0M)-&gt;117.5M(200.0M)]
[Times: user=O.00 sys=0.00, real=0.01 secs]
1.818 : [GC pause (young), 0.0062386 secs]
...
[Eden: 55.0M(55.0M)-&gt;0.0B(55.0M) Survivors: 6144.0K-&gt;5120.0K Heap: 172.5M(200.0M)-&gt;118.2M(200.0M)]
[Times: user=0.00 sys=0.00, real=0.01 secs]
1.842: [GC pause (young), 0.0068966 secs]
...
[Eden: 55.0M(55.0M)-&gt;0.0B(53.0M) Survivors: 5120.0K-&gt;6144.0K Heap: 173.2M(200.0M)-&gt;119.2M(200.0M)]
[Times: user=0.00 sys=0.00, real=0.01 secs]
1.867: [GC pause (young), 0.0067426 secs]
...
[Eden: 53.0M(53.0M)-&gt;0.0B(52.0M) Survivors: 6144.0K-&gt;6144.0K Heap: 172.2M(200.0M)-&gt;120.7M(200.0M)]
[Times: user=0.06 sys=0.00, real=0.01 secs]
1.878: [GC concurrent-mark-end, 0.1055874 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重新标记，是会引起全局停顿的，它的日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.878: [GC remark 1.878: [GC ref-proc, 0.0000447 secs], 0.0015223 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>重新标记后会进行独占清理，独占清理会重新计算各个区域的存活对象，并以此可以得到每个区域进行 GC 的效果（即回收比）。它的日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.879: [GC cleanup 127M-&gt;127M(200M), 0.0009723 secs]
[Times: user=0.00 sys=0.00r real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>并发清理，是并发执行的，它会根据独占清理阶段计算得出的每个区域的存活对象数量，直接回收已经不包含存活对象的区域。它的日志如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.498: [GC concurrent-cleanup-start]
1.498: [GC concurrent-cleanup-end, 0.0000073 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="_5-4-4-混合回收" tabindex="-1"><a class="header-anchor" href="#_5-4-4-混合回收" aria-hidden="true">#</a> 5.4.4 混合回收</h3><p>在并发标记周期中，虽然有部分对象被回收，但是总体上说，回收的比例是相当低的。但是在并发标记周期后，G1 已经明确知道哪些区域含有比较多的垃圾对象，在混合回收阶段就可以专门针对这些区域进行回收。当然，G1 会优先回收垃圾比例较高的区域，因为回收这些区域的性价比也比较高。这也正是 G1 名字的由来。G1 垃圾回收器的全称为 Garbage First Garbage Collector，直译为垃圾优先的垃圾回收器，这里的垃圾优先（Garbage First）指的就是回收时优先选取垃圾比例最高的区域。</p><p>这个阶段叫作混合回收，是因为在这个阶段既会执行正常的年轻代 GC，又会选取一些被标记的老年代区域进行回收，它同时处理了新生代和老年代，如图5.9 所示，因为新生代 GC 的原因，eden 区必然被清空，此外，有两块被标记为 G 的垃圾比例最高的区域被清理。被清理区域中的存活对象会被移到其他区域，这样做的好处是可以减少空间碎片。</p><p><img src="/assets/图5-9.abae0951.png" alt="图5-9" loading="lazy"></p><p>图5.9 G1 的混合回收</p><p>混合 GC 会产生如下日志：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.904: [GC pause (mixed), 0.0073135 secs]
...
[Eden: 4096.0K(4096.0K)-&gt;0.0B(53.0M) Survivors: 6144.0K-&gt;2048.0K Heap: 127.3M(200.0M)-&gt;123.6M(200.0M)]
[Times: user=0.00 sys=0.00, real=0.01 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>混合 GC 会执行多次，直到回收了足够多的内存空间，然后它会触发一次新生代 GC。新生代 GC 后，又可能会发生一次并发标记周期的处理，最后又会引起混合 GC 的执行。整个过程可能如图5.10 所示。</p><p><img src="/assets/图5-10.789634ce.png" alt="图5-10" loading="lazy"></p><p>图5.10 混合 GC 及 G1 整体示意图</p><h3 id="_5-4-5-必要时的-full-gc" tabindex="-1"><a class="header-anchor" href="#_5-4-5-必要时的-full-gc" aria-hidden="true">#</a> 5.4.5 必要时的 Full GC</h3><p>和 CMS 类似，并发回收由于让应用程序和 GC 线程交替工作，总是不能完全避免在特别繁忙的场合出现在回收过程中内存不充足的情况。当遇到这种情况时，G1 也会转入一个 Full GC。</p><p>【示例 5-1】当 G1 在并发标记时，由于老年代被快速填充，G1 会终止并发标记而转入一个 Full GC。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>24.909: [GC concurrent-mark-start]
24.909: [Full GC 898M-&gt;896M(900M), 0.7505595 secs]
[Eden: 0.0B(45.0M)-&gt;0.0B(45.0M) Survivors: 0.0B-&gt;0.0B Heap: 898.7M(900.0M)-&gt; 896.2M(900.0M)]
[Times: user=1.05 sys=0.00, real=0.75 secs] 
25.660: [GC concurrent-mark-abort]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，如果在混合 GC 时空间不足，或者在新生代 GC 时 survivor 区和老年代无法容纳幸存对象，都会导致一次 Full GC。</p><h3 id="_5-4-6-g1-的日志" tabindex="-1"><a class="header-anchor" href="#_5-4-6-g1-的日志" aria-hidden="true">#</a> 5.4.6 G1 的日志</h3><p>G1 的日志与先前的回收器相比已经丰富了很多。在本书前文中尚未给出完整的 G1 日志，本节将给出一个较为完整的日志，并做出解释。</p><p>【示例 5-2】以下是一个完整的 G1 新生代日志。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.619: [GC pause (young) (initial-mark), 0.03848843 secs]
	[Parallel Time: 38.0 ms]
	 [GC Worker Start (ms): 1619.3 1619.3 1619.3 1619.3 Avg: 1619.3, Min: 1619.3, Max: 1619.3, Diff: 0.0]   
     [Ext Root Scanning (ms): 0.3 0.3 0.2 0.2 Avg: 0.3, Min: 0.2, Max: 0.3, Diff: 0.1]  
     [Update RS (ms): 5.7 5.4 28.0 5.3 Avg: 11.1, Min: 5.3, Max: 28.0, Diff: 22.8] 
     [Processed Buffers: 5 4 1 4, Sum: 14, Avg: 3, Min: 1, Max: 5, Diff: 4]    
     [Scan RS (ms): 4.6 5.0 0.0 5.2 Avg: 3.7, Min: 0.0, Max: 5.2, Diff: 5.2]  
     [Object Copy (ms): 27.4 27.3 9.6 27.2 Avg: 22.9, Min: 9.6, Max: 27.4, Diff: 17.7] 
     [Termination (ms): 0.1 0.0 0.0 0.1 Avg:	0.0, Min: 0.0, Max: 0.1, Diff: 0.1]  
     [Termination Attempts: 3 1 10 5 Sum: 19, Avg: 4, Min: 1, Max: 10, Diff: 9]   
     [GC Worker End (ms): 1657.3 1657.2 1657.2 1657.2 Avg: 1657.2, Min :1657.2, Max: 1657.3, Diff: 0.0]                       
     [GC Worker (ms): 38.0 38.0 38.0 38.0 Avg: 38.0, Min: 38.0, Max: 38.0, Diff: 0.1]  
     [GC Worker Other (ms): 0.0 0.1 0.1 0.1 Avg: 0.1, Min: 0.0, Max: 0.1, Diff: 0.1]  
	[Clear CT: 0.0 ms]                                                                                                      
	[Other: 0.4 ms]                                                                                                      
     [Choose CSet: 0.0 ms]                                                    
     [Ref Proc:	0.1 ms]                                                       
     [Ref Enq: 0.0 ms]                                                                                                       
     [Free CSet: 0.1 ms]                                                       
	[Eden: 32M(35M)-&gt;0B(35M) Survivors: 5120K-&gt;5120K Heap: 147M(200M)-&gt;147M(200M)]      
	[Times: user=0.16 sys=0.00, real=0.04 secs]    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>日志第一行：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1.619: [GC pause (young) (initial-mark), 0.03848843 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示在应用程序开启 1.619 秒时发生了一次新生代 GC，这是在初始标记时发生的，耗时 0.038 秒，意味着应用程序至少暂停了 0.038 秒。</p></li><li><p>后续并行时间：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Parallel Time: 38.0 ms]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示所有 GC 线程总的花费时间，这里为 38 毫秒。</p></li><li><p>给出每一个 GC 线程的执行情况：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC Worker Start (ms): 1619.3 1619.3 1619.3 1619.3 Avg: 1619.3, Min: 1619.3, Max: 1619.3, Diff:	0.0]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里表示一共 4 个 GC 线程（因为第一行有 4 个数据），它们都在 1619.3 秒时启动。同时，还给出了这几个启动数据的统计值，如平均（Avg）、最小（Min）、最大（Max）和差值（Diff）。Diff 表示最大值和最小值的差。</p></li><li><p>给出了根扫描的耗时：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Ext Root Scanning (ms): 0.3 0.3 0.2 0.2 Avg: 0.3, Min: 0.2, Max: 0.3, Diff: 0.1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在根扫描时，每一个 GC 线程的耗时，这里分别消耗了 0.3、0.3、0.2、0.2 秒，后一行给出了这些耗时的统计数据。</p></li><li><p>给出了更新记忆集（Remembered Set）的耗时：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Update RS (ms): 5.7 5.4 28.0 5.3 Avg: 11.1, Min: 5.3, Max: 28.0, Diff: 22.8]
[Processed Buffers: 5 4 1 4 Sum: 14, Avg: 3, Min: 1, Max: 5, Diff: 4]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>记忆集是 G1 中维护的一个数据结构，简称 RS。每一个 G1 区域都有一个 RS 与之关联。由于 G1 回收时是按照区域回收的，比如在回收区域 A 的对象时，很可能并不回收区域 B 的对象，为了回收区域 A 的对象，要扫描区域 B 甚至整个堆来判定区域 A 中哪些对象不可达，这样做的代价显然很大。因此，G1 在区域 A 的 RS 中，记录了在区域 A 中被其他区域引用的对象，这样在回收区域 A 时，只要将 RS 视为区域 A 根集的一部分即可，从而避免做整个堆的扫描。由于系统在运行过程中，对象之间的引用关系是可能时刻变化的，为了更高效地跟踪这些引用关系，会将这些变化记录在 Update Buffers 中。这里的 Processed Buffers 指的就是处理这个 Update Buffers 数据。这里给出的 4 个时间也是 4 个 GC 线程的耗时，以及它们的统计数据。从这个日志中可以看到，更新 RS 时分别耗时 5.7、5.4、28、5.3 毫秒，平均耗时 11.1 毫秒。</p></li><li><p>扫描 RS 的时间：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Scan RS (ms): 4.6 5.0 0.0 5.2 Avg: 3.7, Min: 0.0, Max: 5.2, Diff: 5.2]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>在正式回收时，G1 会对被回收区域的对象进行疏散，即将存活对象放置在其他区域中，因此需要进行对象的复制。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Object Copy (ms): 27.4 27.3 9.6 27.2 Avg: 22.9, Min: 9.6, Max: 27.4, Diff: 17.7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里给出的 Object Copy 就是进行对象赋值的耗时。</p></li><li><p>给出 GC 工作线程的终止信息：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Termination (ms): 0.1 0.0 0.0 0.1 Avg: 0.0, Min: 0.0, Max: 0.1, Diff: 0.1]
[Termination Attempts: 3 1 10 5 Sum: 19, Avg: 4, Min: 1, Max: 10, Diff: 9]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的终止时间是线程花在终止阶段的耗时。在 GC 线程终止前，它们会检查其他 GC 线程的工作队列，查看是否仍然还有对象引用没有处理完，如果其他线程仍然有没有处理完的数据，请求终止的 GC 线程就会帮助它尽快完成，随后再尝试终止。其中 Termination Attempts 展示了每一个工作线程尝试终止的次数。</p></li><li><p>显示 GC 工作线程的完成时间：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC Worker End (ms): 1657.3 1657.2 1657.2 1657.2 Avg: 1657.2, Min: 1657.2, Max: 1657.3, Diff: 0.0]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里显示了在系统运行后 1657 毫秒，这几个线程都终止了。</p></li><li><p>显示几个 GC 工作线程的存活时间，单位是毫秒：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC Worker (ms) : 38.0 38.0 38.0 38.0 Avg: 38.0, Min: 38.0, Max: 38.0, Diff: 0.1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>显示 GC 线程花费在其他任务中的耗时，单位是毫秒，可以看到这部分时间非常少：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC Worker Other (ms) : 0.0 0.1 0.1 0.1 Avg: 0.1, Min: 0.0, Max: 0.1, Diff:	0.1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>显示清空 CardTable 的时间，RS 就是依靠 CardTable 来记录哪些是存活对象的：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Clear CT:	0.0 ms]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>显示其他几个任务的耗时：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Other:	0.4 ms]
[Choose CSet: 0.0 ms]
[Ref Proc: 0.1 ms]
[Ref Enq: 0.0 ms]
[Free CSet:	0.1 ms]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如选择 CSet（Collection Sets）的时间、Ref Proc（处理弱引用、软引用的时间）、Ref Enq（弱引用、软引用入队时间）和 Free CSet（释放被回收的 CSet 中区域的时间，包括它们的 RS）。</p><p><strong>注意</strong>：Collection Sets 表示被选取的、将要被回收的区域的集合。</p></li><li><p>显示比较熟悉的 GC 回收的整体情况：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Eden: 32M(35M)-&gt;0B(35M) Survivors: 5120K-&gt;5120K Heap: 147M(200M)-&gt;147M(200M)] 
[Times: user=0.16 sys=0.00, real=0.04 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里显示了 eden 区一共 32MB 被清空，survivor 区没有释放对象，整个堆空间没有释放空间。用户 CPU 耗时 0.16 秒，实际耗时 0.04 秒。</p></li></ol><h3 id="_5-4-7-g1-相关的参数" tabindex="-1"><a class="header-anchor" href="#_5-4-7-g1-相关的参数" aria-hidden="true">#</a> 5.4.7 G1 相关的参数</h3><p>对于 G1，可以使用 -XX:+UseG1GC 标记打开 G1 的开关，对 G1 进行设置时，最重要的一个参数就是 -XX:MaxGCPauseMillis，它用于指定目标最大停顿时间。如果任何一次停顿超过这个设置值，G1 就会尝试调整新生代和老年代的比例、调整堆大小、调整晋升年龄等，试图达到预设目标。对于性能调优来说，有时候总是鱼和熊掌不可兼得，如果停顿时间缩短，对于新生代来说，这意味着很可能要增加新生代 GC 的次数。对于老年代来说，为了获得更短的停顿时间，在混合 GC 时，一次收集的区域数量也会变少，这样无疑增加了进行 Full GC 的可能性。</p><p>另外一个重要的参数是 -XX:ParallelGCThreads，它用于设置并行回收时 GC 的工作线程数量。</p><p>此外，-XX:InitiatingHeapOccupancyPercent 参数可以指定当整个堆使用率达到多少时，触发并发标记周期的执行。默认值是 45，即当整个堆的占用率达到 45% 时，执行并发标记周期。InitiatingHeapOccupancyPercent 一旦设置，始终都不会被 G1 修改，这意味着 G1 不会试图改变这个值来满足 MaxGCPauseMillis 的目标。如果 InitiatingHeapOccupancyPercent 值设置得偏大，会导致并发周期迟迟得不到启动，那么引起 Full GC 的可能性也大大增加，反之，一个过小的 InitiatingHeapOccupancyPercent 值会使得并发标记周期执行非常频繁，大量 GC 线程抢占 CPU，导致应用程序的性能有所下降。</p><h2 id="_5-5-回眸-有关对象内存分配和回收的一些细节问题" tabindex="-1"><a class="header-anchor" href="#_5-5-回眸-有关对象内存分配和回收的一些细节问题" aria-hidden="true">#</a> 5.5 回眸：有关对象内存分配和回收的一些细节问题</h2><p>通过前面的学习，读者应该已经对已有的垃圾回收算法和具体的垃圾回收器及其使用有了一定的了解。本节来讨论一些有趣的问题，更进一步探讨对象在内存中的分配及回收方式。</p><h3 id="_5-5-1-禁用-system-gc" tabindex="-1"><a class="header-anchor" href="#_5-5-1-禁用-system-gc" aria-hidden="true">#</a> 5.5.1 禁用 System.gc()</h3><p>在默认情况下，System.gc() 会显式直接触发 Full GC，同时对老年代和新生代进行回收。而一般情况下，我们认为垃圾回收应该是自动进行的，无须手工触发。如果过于频繁地触发垃圾回收对系统性能是没有好处的。因此虚拟机提供了一个参数 DisableExplicitGC 来控制是否手工触发 GC。</p><p>System.gc() 的实现如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Runtime.gc() 是一个 native 方法，最终在 jvm.cpp 中实现，如下所示：</p><div class="language-c++ ext-c++ line-numbers-mode"><pre class="language-c++"><code>JVM_ENTRY_NO_ENV(void, JVM_GC(void))
    JVMWrapper(&quot;JVM_GC&quot;);
if (!DisableExplicitGC) {
    Universe::heap() -&gt; collect(GCCause::_java_lang_system_gc);
}
JVM_END
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，如果设置了 -XX:-+DisableExplicitGC，条件判断就无法成立，那么就会禁用显式 GC，System.gc() 等价于一个空函数调用。</p><h3 id="_5-5-2-system-gc-使用并发回收" tabindex="-1"><a class="header-anchor" href="#_5-5-2-system-gc-使用并发回收" aria-hidden="true">#</a> 5.5.2 System.gc() 使用并发回收</h3><p>在默认的情况下，即使 System.gc() 生效，会使用传统的 Full GC 方式回收整个堆，而忽略参数中的 UseG1GC 和 UseConcMarkSweepGC。比如使用以下参数运行程序：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+PrintGCDetails -XX:+UseConcMarkSweepGC
// 或者
-XX:+PrintGCDetails -XX:+UseG1GC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遇到 System.gc() 的时候，则会有以下日志输出。</p><p>对于 CMS：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Full GC[CMS: 454K-&gt;453K(10944K), 0.0046875 secs] 544K-&gt;453K(15936K), [CMS Perm: 1593K-&gt;1593K(12288K)], 0.0047210 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于 G1：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Full GC 616K-&gt;453K(5120K), 0.0049140 secs]
[Eden: 1024.0K(7168.0K)-&gt;0.0B(2048.0K) Survivors: 0.0B-&gt;0.0B Heap: 616.5K (16.0M)-&gt;453.4K(5120.0K)]
[Times: user=0.01 sys=0.00, real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，此时 CMS 和 G1是没有并发执行的，因为在日志中没有任何并发相关的信息。打开虚拟机参数 -XX:+ExplicitGCInvokesConcurrent 后，可以改变这种默认的行为，比如使用以下参数：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -XX:+ExplicitGCInvokesConcurrent
// 或者
-XX:+PrintGCDetails -XX:+UseGlGC -XX:+ExplicitGCInvokesConcurrent
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 CMS：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    [GC[ParNew: 620K-&gt;462K(4928K), 0.0012471 secs] 620K-&gt;462K(15872K), 0.0012948 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    [GC [1 CMS-initial-mark: 0K(10944K)] 462K(15872K), 0.0004039 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    [CMS-concurrent-mark: 0.006/0.006 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
    [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [GC[YG occupancy: 550K(4928K)][Rescan (parallel), 0.0002013 secs][weak refs processing, 0.0000060 secs] [scrub string table, 0.0000209 secs] [1 CMS-remark: 0K(10944K)] 550K(15872K), 0.0002639 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 G1（省略部分输出）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC pause (young) (initial-mark), 0.0013322 secs]
[Parallel Time: 1.1 ms, GC Workers: 2]
[Eden: 1024.0K(7168.0K)-&gt;0.0B(5120.0K) Survivors: 0.0B-&gt;1024.0K Heap: 616.5K(16.0M)-&gt;476.1K(16.0M)]
[Times: user=0.00 sys=0.00, real=0.00 secs]
[GC concurrent-root-region-scan-start]
[GC concurrent-root-region-scan-end, 0.0003496 secs]
[GC concurrent-mark-start]
[GC concurrent-mark-end, 0.0000331 secs]
[GC remark [GC ref-proc, 0.0000142 secs], 0.0003168 secs]
[Times: user=0.00 sys=0.00, real=0.00 secs]
[GC cleanup 517K-&gt;517K(16M), 0.0000742 secs]
[Times: user=0.00 sys=0.00, real=0.00 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，只有在打开 ExplicitGCInvokesConcurrent 开关后，System.gc() 这种显式 GC 才会使用并发的方式进行回收，否则，无论是否启用了 CMS 或者 G1，都不会进行并发回收。</p><h3 id="_5-5-3-并行-gc-前额外触发的新生代-gc" tabindex="-1"><a class="header-anchor" href="#_5-5-3-并行-gc-前额外触发的新生代-gc" aria-hidden="true">#</a> 5.5.3 并行 GC 前额外触发的新生代 GC</h3><p>对于并行回收器的 Full GC（使用 UseParallelOldGC 或者 UseParallelGC），细心的读者可能会发现，在每一次 FullGC 之前都会伴随一次新生代 GC。这和串行回收器相比，有很大的不同。</p><p>【示例 5-3】下面给出一个简单的比较示例。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScavengeBeforeFullGC</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码只是进行了一次简单的 Full GC。使用以下参数，设置为串行回收器运行代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+PrintGCDetails -XX:+UseSerialGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统进行的 GC 如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[Full GC[Tenured: 0K-&gt;376K(10944K), 0.0033328 secs] 603K-&gt;376K(15872K), [Perm: 142K-&gt;142K(12288K)], 0.0033825 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一切都在意料之中，System.gc() 触发了一次 Full GC。切换为并行回收器，再尝试同样的操作：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+PrintGCDetails -XX:+UseParallelOldGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>    [GC [PSYoungGen: 670K-&gt;480K(5120K)] 670K-&gt;480K(15872K), 0.0153729 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
    [Full GC [PSYoungGen: 480K-&gt;0K(5120K)] [ParOldGen: 0K-&gt;453K(10752K)] 480K-&gt;453K(15872K) [PSPermGen: 1592K-&gt;1591K(12288K)], 0.0073608 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在使用并行回收器时，触发 FullGC 之前，进行了一次新生代 GC。因此，这里的 System.gc() 实际上触发了两次 GC。这样做的目的是先将新生代进行一次回收，避免将所有回收工作同时交给一次 Full GC 进行，从而尽可能地缩短一次停顿时间。</p><p>如果不需要这个特性，那么可以使用参数 -XX:-ScavengeBeforeFullGC 去除发生在 Full GC 之前的那次新生代 GC。在默认情况下，ScavengeBeforeFullGC 的值为 true。</p><h3 id="_5-5-4-对象何时进入老年代" tabindex="-1"><a class="header-anchor" href="#_5-5-4-对象何时进入老年代" aria-hidden="true">#</a> 5.5.4 对象何时进入老年代</h3><p>对于一般情况而言，当对象首次创建时，会被放置在新生代的 eden 区。为什么取名叫 eden 呢？eden 是 “伊甸园” 的意思。根据圣经的记载，亚当和夏娃就住在伊甸园，那也是人类开始居住的地方。这里沿用伊甸园的名字也就是这个意思。在堆中分配的对象首先会被安置在 eden 区。如果没有 GC 的介入，那么这些对象不会离开 eden 区。</p><ol><li><p>初创的对象在 eden 区</p><p>【示例 5-4】下面的代码申请了大约 5MB 内存：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AllocEden</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1K <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token operator">*</span> _1K<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1K<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用如下参数运行上面的代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx64M -Xms64M -XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到输出：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Heap
def new generation total 19648K, used 6321K [0x30460000, 0x319b0000, 0x319b0000)
eden space 17472K, 36% used [0x30460000, 0x30a8c500, 0x31570000)
from space 2176K, 0% used [0x31570000, 0x31570000, 0x31790000)
to space 2176K, 0% used [0x31790000, 0x31790000, 0x319b0000)
tenured generation total 43712K, used 0K [0x319b0000, 0x34460000, 0x34460000)
the space 43712K, 0% used [0x319b0000, 0x319b0000, 0x319b0200, 0x34460000)
compacting perm gen total 12288K, used 142K [0x34460000, 0x35060000, 0x38460000)
the space 12288K, 1% used [0x34460000, 0x34483a88, 0x34483c00, 0x35060000)
ro space 10240K, 44% used [0x38460000, 0x388d73f0, 0x388d7400, 0x38e60000)
rw space 12288K, 52% used [0x38e60000, 0x394add28, 0x394ade00, 0x39a60000)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在整个过程中没有 GC 发生，分配的 5MB 数据都应该在堆中，从堆的日志中可以看到，eden 区占据了 6MB 左右的空间，from、to 和老年代 tenured 均未被使用。</p></li><li><p>老年对象进入老年代</p><p>eden 区中的对象何时能进入老年代呢？一般来说，当对象的年龄达到一定的大小，就自然可以离开年轻代，进入老年代。一般把对象进入老年代的事件，称为 “晋升”。对象的年龄是由对象经历过的 GC 次数决定的。在新生代中的对象每经历一次 GC，如果它没有被回收，它的年龄就加 1。虚拟机提供了一个参数来控制新生代对象的最大年龄：MaxTenuringThreshold。在默认情况下，这个参数的值为 15。也就是说，新生代的对象最多经历 15 次 GC，就可以晋升到老年代。</p><p>【示例 5-5】修改上例中的代码，使之如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxTenuringThreshold</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1M <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1K <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token operator">*</span> _1K<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1K<span class="token punctuation">]</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">17</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">270</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1M<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码依然申请了大约 5MB 空间，不同的是，在代码第 8 行将新生成的 byte 数组进行保存，防止它们在 GC 时被回收。代码第 11 ~ 15 行不停地在新生代分配内存，以触发新生代 GC。使用如下参数运行代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx1024M -Xms1024M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=15 -XX:+PrintHeapAtGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里分配了 1GB 的内存，用意是将对象尽可能预留在新生代（一个大的堆自然有一个大的新生代）。显式指定了 MaxTenuringThreshold 为 15（和默认值一样，这里方便读者理解），并打开了 PrintHeapAtGC 开关，在每次 GC 时都打印堆的详细信息。</p><p>程序的部分输出如下（由于打开了 PrintHeapAtGC，会产生大量信息，这里仅显示相关部分）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{Heap before GC invocations=0 (full 0):
def new generation total 314560K, used 279477K [0x04940000, 0x19e90000, 0x19e90000)
eden space 279616K, 99% used [0x04940000, 0x15a2d770, 0x15a50000)
from space 34944K, 0% used [0x15a50000, 0x15a50000, 0x17c70000)
to space 34944K, 0% used [0x17c70000, 0x17c70000, 0x19e90000)
tenured generation total 699072K, used 0K [0x19e90000, 0x44940000, 0x44940000)
the space 699072K, 0% used [0x19e90000, 0x19e90000, 0x19e90200, 0x44940000)
...
[GC[DefNew: 279477K-&gt;5888K(314560K), 0.0053669 secs] 279477K-&gt;5888K(1013632K), 0.0053970 secs] [Times: user=0.00 sys=0.02, real=0.01 secs]
Heap after GC invocations=1 (full 0):
def new generation total 314560K, used 5888K [0x04940000, 0x19e90000, 0x19e90000)
eden space 279616K, 0% used [0x04940000, 0x04940000, 0x15a50000)
from space 34944K, 16% used [0x17c70000, 0x18230358, 0x19e90000)
to space 34944K, 0% used [0x15a50000, 0x15a50000, 0x17c70000)
tenured generation total 699072K, used 0K [0x19e90000, 0x44940000, 0x44940000)
the space 699072K, 0% used [0x19e90000, 0x19e90000, 0x19e90200, 0x44940000)
...（这里省略中间十几次 GC，它们的情况和第一次 GC 是一样的）
{Heap before GC invocations=15 (full 0):
def new generation total 314560K, used 285452K [0x04940000, 0x19e90000, 0x19e90000)
eden space 279616K, 99% used [0x04940000, 0x15a43190, 0x15a50000)
from space 34944K, 16% used [0x17c70000, 0x18230250, 0x19e90000)
to space 34944K, 0% used [0x15a50000, 0x15a50000, 0x17c70000)
tenured generation total 699072K, used 0K [0x19e90000, 0x44940000, 0x44940000)
the space 699072K, 0% used [0x19e90000, 0x19e90000, 0x19e90200, 0x44940000)
...
[GC[DefNew: 285452K-&gt;0K(314560K) , 0.0045594 secs] 285452K-&gt;5888K(1013632K), 0.0045806 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap after GC invocations=16 (full 0):
def new generation total 314560K, used 0K [0x04940000, 0x19e90000, 0x19e90000)
eden space 279616K, 0% used [0x04940000, 0x04940000, 0x15a50000)
from space 34944K, 0% used [0x15a50000, 0x15a50100, 0x17c70000)
to space 34944K, 0% used [0x17c70000, 0x17c70000, 0x19e90000)
tenured generation total 699072K, used 5888K [0x19e90000, 0x44940000, 0x44940000)
the space 699072K, 0% used [0x19e90000, 0x1a450150, 0x1a450200, 0x44940000)
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>观察以上日志，在第一次 GC 开始前，eden 区使用了 99%，这也是触发新生代 GC 的原因。既然 eden 区不能容纳更多对象，之后又需要有新的对象产生，自然需要对 eden 区进行清理，清理的结果是将存活对象移入了 from 区。从堆日志中可知，from 区占用了 16%，349443 * 0.16 = 5591KB，大约为 5MB，与放置在 map 对象中的 byte 数量匹配，第一次 GC 的另一个影响是 eden 区被清空。</p><p>之后的 14 次 GC 情况和第 1 次是一样的，在日志中被省略。每一次 GC 都会使存活对象的年龄加 1，在第 16 次 GC 时，可以看到它己将新生代清空。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC[DefNew: 285452K-&gt;0K(314560K), 0.0045594 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对比第一次的日志：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>[GC[DefNew: 279477K-&gt;5888K(314560K), 0.0053669 secs]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里有明显的差异。从新生代被移除的对象，这里晋升到了老年代（指 map 对象中的 byte 数组），这从最后一次 GC 的后续堆日志中可以看到。老年代已经有 5888KB 被使用，而新生代有 0KB 被使用。这说明这 5MB 对象成功晋升到老年代。</p><p>读者可以尝试把 MaxTenuringThreshold 改为 10，那么在这个示例中，在第 11 次 GC 时，5MB 对象就会晋升到老年代，此处从略。</p><p>虽然有上述示例做铺垫，但仍然需要再次强调，MaxTenuringThreshold 指的是最大晋升年龄。它是对象晋升到老年代的充分非必要条件。即达到该年龄，对象必然晋升，而未达到该年龄，对象也有可能晋升。事实上，对象的实际晋升年龄，是由虚拟机在运行时自行判断的。</p><p>计算晋升年龄的基本逻辑代码如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>size_t desired_survivor_size = (size_t) ((((double) survivor_capacity) * TargetSurvivorRatio) / 100);
size_t total = 0;
int age = 1;
assert(sizes [0] == 0, &quot;no objects with age zero should be recorded&quot;);
while (age &lt; table_size) {
    total += sizes[age];
	// check if including objects of age &#39;age&#39; made us pass the desired
	// size, if so &#39;age&#39; is the new threshold
    if (total &gt; desired_survivor_size) break;
	age++;
}
int result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，第 1 行的 desired_survivor_size 定义了期望的 survivor 区的使用大小。在第 5 ~ 10 行，根据 desired_survivor_size 计算对象晋升年龄。其中 sizes 数组保存每一个年龄段的对象大小之和。比如 sizes[1] 保存年龄为 1 的所有对象的大小之和。第 6 行对每一个年龄段的对象大小进行累计求和，如果大于 desired_survivor_size 则退出循环，否则 age（对象晋升年龄）加 1。在对所有年龄段的对象进行统计后，如果发现 survivor 区的幸存对象超过了期望值 desired_survivor_size，那么 age 就成为了晋升年龄。之后，在 age 和 MaxTenuringThreshold 中取较小者作为对象的实际晋升年龄。确定对象何时晋升的另外一个重要参数为 TargetSurvivorRatio，它用于设置 survivor 区的目标使用率，默认为 50，即如果 survivor 区在 GC 后使用率超过 50%，那么就很可能会使用较小的 age 作为晋升年龄。</p><p>在本示例中，使用如下参数运行代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx1024M -Xms1024M -XX:+PrintGCDetails -XX:MaxTenuringThreshold=15 -XX:+PrintHeapAtGC -XX:TargetSurvivorRatio=15
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将 TargetSurvivorRatio 设置为 15。通过前文的 GC 日志可知，from 区的使用率会维持在 16%，而现在更改目标使用率为 15%，小于 16%，故应该会使对象更快地晋升到老年代。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>{Heap before GC invocations=1 (full 0):
def new generation total 314560K, used 285201K [0x04a10000, 0x19f60000, 0x19f60000) 
eden space 279616K, 99% used [0x04a10000, 0x15ad43e0, 0x15b20000)
from space 34944K, 16% used [0x17d40000, 0x18300368, 0x19f60000)
to space 34944K, 0% used [0x15b20000, 0x15b20000, 0x17d40000)
tenured generation total 699072K, used 0K [0x19f60000, 0x44a10000, 0x44a10000)
the space 699072K, 0% used [0x19f60000, 0x19f60000, 0x19f60200, 0x44a10000)
...
[GC[DefNew: 285201K-&gt;0K(314560K), 0.0040121 secs] 285201K-&gt;5888K(1013632K), 0.0040337 secs] [Times: user=0.00 sys=0.02, real=0.00 secs]
Heap after GC invocations=2 (full 0):
def new generation total 314560K, used 0K [0x04a10000, 0x19f60000, 0x19f60000) 
eden space 279616K, 0% used [0x04a10000, 0x04a10000, 0x15b20000)
from space 34944K, 0% used [0x15b20000, 0x15b20100, 0x17d40000)
to space 34944K, 0% used [0x17d40000, 0x17d40000, 0x19f60000)
tenured generation total 699072K, used 5888K [0x19f60000, 0x44a10000, 0x44a10000)
the space 699072K, 0% used [0x19f60000, 0x1a520158, 0x1a520200, 0x44a10000)
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上日志显示，在第 2 次 GC 时，map 中的 byte 数组对象都已经晋升到老年代。</p><p><strong>注意</strong>：对象的实际晋升年龄是根据 survivor区的使用情况动态计算得来的，而 MaxTenuringThreshold 只是表示这个年龄的最大值。</p></li><li><p>大对象进入老年代</p><p>除了年龄，对象的体积也会影响对象的晋升。试想，如果对象体积很大，新生代无论 eden 区还是 survivor 区都无法容纳这个对象，自然这个对象无法存放在新生代，也非常有可能被直接晋升到老年代。如图5.11 所示，如果需要一个连续的 6MB 空间，而新生代 survivor 区（只有 5MB）无法容纳这样的大小，此时无论该对象年龄如何，它都会被直接晋升到老年代。</p><p><img src="/assets/图5-11.3428382d.png" alt="图5-11" loading="lazy"></p><p>图5.11 新生代无法容纳大对象</p><p>另外一个有趣的参数是 PretenureSizeThreshold，它用来设置对象直接晋升到老年代的阈值，单位是字节。只要对象的大小大于指定值，就会绕过新生代，直接在老年代分配。这个参数只对串行回收器和 ParNew 有效，对于 ParallelGC 无效。默认情况下该值为 0，也就是不指定最大的晋升大小，一切由运行情况决定。</p><p>【示例 5-6】下面的示例演示了 PretenureSizeThreshold 的使用。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PretenureSizeThreshold</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> _1K <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token operator">*</span> _1K<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>_1K<span class="token punctuation">]</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码分配了约 5MB 空间，大约为 6 千个 byte 数组，每个数组大小为 1024 字节。使用下面参数运行这段代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx32m -Xms32m -XX:+UseSerialGC -XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到的部分输出如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Heap
def new generation total 9792K, used 6204K [0x32460000, 0x32f00000, 0x32f00000)
eden space 8704K, 71% used [0x32460000, 0x32a6f358, 0x32ce0000)
from space 1088K, 0% used [0x32ce0000, 0x32ce0000, 0x32df0000)
to space 1088K,	0% used [0x32df0000, 0x32df0000, 0x32f00000)
tenured generation total 21888K, used 0K [0x32f00000, 0x34460000, 0x34460000) 
the space 21888K, 0% used [0x32f00000, 0x32f00000, 0x32f00200, 0x34460000)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，所有的对象均分配在新生代，老年代的使用率为 0。接着附加参数 PretenureSizeThreshold，令 PretenureSizeThreshold = 1000，则大小为 1024 字节的 byte 数组理应被分配在老年代，参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Xmx32m -Xms32m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:PretenureSizeThreshold=1000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到的部分输出如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Heap
def new generation 9792K, used 6124K [0x32460000, 0x32f00000, 0x32f00000)
eden space 8704K, 70% used [0x32460000, 0x32a5b328, 0x32ce0000)
from space 1088K, 0% used [0x32ce0000, 0x32ce0000, 0x32df0000)
to space 1088K, 0% used [0x32df0000, 0x32df0000, 0x32f00000)
tenured generation total 21888K, used 80K [0x32f00000, 0x34460000, 0x34460000)
the space 21888K, 0% used [0x32f00000, 0x32f14030, 0x32f14200, 0x34460000)
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>读者也许会觉得非常奇怪，因为期望的结果是至少有 5MB 数据被分配在老年代，但为什么作为分配主体的 5MB 数组看起来依然在新生代呢？似乎 PretenureSizeThreshold 不起作用，但是老年代的情况却和不加 PretenureSizeThreshold 时有所不同，有 80KB 的空间被使用。</p><p>出现这种现象的原因是虚拟机在为线程分配空间时，会优先使用一块叫作 TLAB 的区域（TLAB 的相关内容在下一节详细介绍），对于体积不大的对象，很有可能会在 TLAB 上先行分配，因此就失去了在老年代分配的机会。这里简单地禁用 TLAB 即可。使用下述参数，再次运行程序：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx32m -Xms32m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:-UseTLAB -XX:PretenureSizeThreshold=1000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到的部分输出如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Heap
def new generation total 9792K, used 580K [0x32460000, 0x32f00000, 0x32f00000)
eden space 8704K, 6% used [0x32460000, 0x324fl3c0, 0x32ce0000)
from space 1088K, 0% used [0x32ce0000, 0x32ce0000, 0x32df0000)
to space 1088K,	0% used [0x32df0000, 0x32df0000, 0x32f00000)
tenured generation total 21888K, used 5413K [0x32f00000, 0x34460000, 0x34460000)
the space 21888K, 24% used [0x32f00000, 0x33449470, 0x33449600, 0x34460000)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在禁用 TLAB 后，大于 1000 字节的 byte 数组己经分配在老年代了。那么什么是 TLAB 呢？请读者继续阅读下一节。</p></li></ol><h3 id="_5-5-5-在-tlab-上分配对象" tabindex="-1"><a class="header-anchor" href="#_5-5-5-在-tlab-上分配对象" aria-hidden="true">#</a> 5.5.5 在 TLAB 上分配对象</h3><p>TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存。从名字上可以看到，TLAB 是一个线程专用的内存分配区域。</p><p>为什么需要 TLAB 这个区域呢？这是为了加速对象分配。由于对象一般会分配在堆上，而堆是全局共享的。在同一时间，可能会有多个线程在堆上申请空间。因此，每一次对象分配都必须进行同步，而在竞争激烈的场合分配的效率又会进一步下降。考虑到对象分配几乎是 Java 最常用的操作，因此 Java 虚拟机就使用了 TLAB 这种线程专属的区域来避免多线程冲突，提高对象分配的效率。TLAB 本身占用了 eden 区的空间。在 TLAB 启用的情况下，虚拟机会为每一个 Java 线程分配一块 TLAB 区域。</p><p>【示例 5-7】下面来看一下启用 TLAB 与关闭 TLAB 时的性能差异。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseTLAB</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> e <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码进行若干次数组分配，并统计了执行时间。使用如下参数执行：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+UseTLAB -Xcomp -XX:-Backgroundcompilation -XX:-DoEscapeAnalysis -server
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该参数打开了 TLAB（默认即为开启状态，这里使用参数打开是为了让表述更清晰），并启用了对所有函数的 JIT 及禁止后台编译（这里只是希望在相对一致的环境中测试），同时禁用了逃逸分析，以防止栈上分配的行为影响本次测试结果。开启 Server 模式是因为在 Client 模式下，不支持逃逸分析参数 DoEscapeAnalysis。最终程序输出：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>54
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改 Java 虚拟机参数为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:-UseTLAB -Xcomp -XX:-BackgroundCompilation -XX:-DoEscapeAnalysis -server
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>禁用了 TLAB，程序输出为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>141
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，TLAB 是否启用对于对象分配的影响是很大的。</p><p>由于 TLAB 区域一般不会太大，因此大对象无法在 TLAB 区域进行分配，总是会直接分配在堆上。由于 TLAB 空间比较小，很容易装满。比如，一个 100KB 的空间，如果已经使用了 80KB，当需要再分配一个 30KB 的对象时，肯定就无能为力了。这时，虚拟机有两种选择：第一，废弃当前的 TLAB 区域，这样就会浪费 20KB 空间；第二，将这 30KB 的对象直接分配在堆上，保留当前的 TLAB 区域，这样将来有小于 20KB 的对象分配请求时可以直接使用这块空间。当发生请求分配的对象大于 TLAB 内可用空间时，虚拟机如何在这两种行为中进行选择呢？虚拟机内部会维护一个叫作 refill_waste 的值，当请求对象大于 refill_waste 时，会选择在堆中分配，若小于该值，则会废弃当前 TLAB 区域，新建 TLAB 区域来分配新对象。这个阈值可以使用虚拟机参数 TLABRefillWasteFraction 来调整，它表示 TLAB 中允许产生这种浪费的比例。它的默认值为 64，即表示使用约为 1/64 的TLAB 区域作为 refill_waste。</p><p>默认情况下，TLAB 和 refill_waste 的大小都是会在运行时不断调整的，使系统的运行状态达到最优。如果想禁用自动调整 TLAB 的大小，可以使用 -XX:-ResizeTLAB 禁用 ResizeTLAB，并使用 -XX:TLABSize 手工指定 TLAB 的大小。</p><p>如果想观察 TLAB 区域的使用情况，可打开跟踪参数 -XX:+PrintTLAB（考虑到兼容性问题，JDK 9、JDK 10 不再支持此参数）。现使用如下参数再次运行这段代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-XX:+UseTLAB -XX:+PrintTLAB -XX:+PrintGC -XX:TLABSize=102400 -XX:-ResizeTLAB -XX:TLABRefillWasteFraction=100 -XX:-DoEscapeAnalysis -server
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到如下输出（篇幅有限，只截取部分输出）：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>	TLAB: gc thread: 0x4c623400 [id: 1932] desired_size: 100KB slow allocs: 0 refill_waste: 1024B alloc: 0.29593	5000KB refills: 1 waste 100.0% gc: 102368B slow: 0B fast: 0B
	TLAB: gc thread: 0x4c621000 [id: 1740] desired_size: 100KB slow allocs: 0 refill_waste: 1024B alloc: 0.29593	5000KB refills : 1 waste 100.0% gc: 102400B slow: 0B fast: 0B
	TLAB: gc thread: 0x0045c400 [id: 5168] desired_size: 100KB slow allocs: 0 refill_waste: 1024B alloc: 0.64808	10950KB refills: 167 waste 0.0% gc: 0B slow: 2672B fast: 0B
	TLAB totals: thrds: 3 refills: 169 max: 167 slow allocs: 0 max 0 waste: 1.2% gc: 204768B max: 102400B slow: 2672B max: 2672B fast: 0B max: 0B
	[GC 17392K-&gt;472K(79872K), 0.0027370 secs]
	...
	90
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述日志就是 TLAB 的使用日志，分为两部分，首先是每一个线程的 TLAB 的使用情况，其次是以 TLAB totals 为首的整体 TLAB 的统计情况。</p><p>在输出日志中，desired_size 为 TLAB 的大小，这里通过 -XX:TLABSize = 102400 指定为 100KB，slow allocs 表示从上一次新生代 GC 到现在为止的慢分配次数，这里的慢分配是指由于 TLAB 空闲空间太小不能满足较大对象的分配，而将对象直接分配到堆上。后面的 refill_waste 表示前文所述的 refill_waste 值。后续的 alloc 表示当前线程的 TLAB 分配比例和使用评估量，这是一个统计数据，前者表示自上一次新生代 GC 后的 number_of_refills * desired size / used_tlab 的加权平均值，后者为该平均值乘以 used_tlab（意为这个 TLAB 区域大约合计被分配了多少空间）。日志中后续的 refills 表示该线程的 TLAB 区域被重新分配并填充的次数，waste 表示空间的浪费比例。</p><p>浪费的空间由三部分组成，即后续的 gc、slow 和 fast。其中，gc 表示在当前新生代 GC 发生时尚空闲的 TLAB 空间，slow 和 fast 都表示当 TLAB 区域被废弃时尚未被使用的 TLAB 空间，两者的不同是，fast 表示这个 refill 操作是通过 JIT 编译优化的（禁用 JIT，fast 永远为 0）。而 waste 则是浪费空间之和（gc + slow + fast）与总分配大小（_number_of_refills * _desired_size）的比值。</p><p>最后的 TLAB totals 则显示了所有线程的统计情况。如 thrds 显示了相关线程总数，refills 表示所有线程 refills 的总数，紧跟在 refills 后的 max 表示 refills 次数最多的线程的 refills 次数。</p><p>图5.12 展示了简要的对象分配流程。如果开启了栈上分配，系统会先进行栈上分配，没有开启栈上分配或者不符合条件则会进行 TLAB 分配，如果 TLAB 分配不成功，再尝试在堆上分配，如果满足了直接进入老年代的条件（PretenureSizeThreshold 等参数），就在老年代分配，否则就在 eden 区分配，当然，如果有必要可能会进行一次新生代 GC。</p><p><img src="/assets/图5-12.18b452bc.png" alt="图5-12" loading="lazy"></p><p>图5.12 简要的对象分配流程</p><h3 id="_5-5-6-finalize-函数对垃圾回收的影响" tabindex="-1"><a class="header-anchor" href="#_5-5-6-finalize-函数对垃圾回收的影响" aria-hidden="true">#</a> 5.5.6 finalize() 函数对垃圾回收的影响</h3><p>Java 中提供了一个类似于 C++ 中析构函数的机制 finalize() 函数，它在 java.lang.Object 中被声明，形式如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该函数允许在子类中被重载，用于在对象被回收时进行资源释放。目前，普遍的认识是，尽量不要使用 finalize() 函数进行资源释放，原因主要有以下几点：</p><ul><li><p>第 4 章曾提到，在使用 finalize() 函数时可能会导致对象复活。</p></li><li><p>finalize() 函数的执行时间是没有保障的，它完全由 GC 线程决定，在极端情况下，若不发生 GC，finalize() 函数将没有机会执行。</p></li><li><p>一个糟糕的 finalize() 函数会严重影响 GC 的性能。</p></li></ul><p>finalize() 函数是由 FinalizerThread 线程处理的。每一个即将被回收并且包含 finalize() 函数的对象都会在正式回收前加入 FinalizerThread 的执行队列，该队列为 java.lang.ref.ReferenceQueue 引用队列，内部实现为链表结构，队列中每一项都为 java.lang.ref.Finalizer 引用，它本质为一个引用，如图5.13 所示，这和虚引用、弱引用等如出一辙。</p><p><img src="/assets/图5-13.6f36635d.png" alt="图5-13" loading="lazy"></p><p>图5.13 java.lang.ref.Finalizer 引用</p><p>Finalizer 内部封装了实际的回收对象，如图5.14 所示。可以看到 next、prev 为实现链表所需，它们分别指向队列中的下一个元素和上一个元素，而 referent 字段则指向实际的对象引用。比如，在后续的示例中就为 LongFinalize$LF。</p><p><img src="/assets/图5-14.ef475f60.png" alt="图5-14" loading="lazy"></p><p>图5.14 Finalizer 主要结构</p><p>由于对象在回收前被 Finalizer 的 referent 字段进行 “强引用”，并加入了 FinalizerThread 的执行队列，这意味着对象又变为可达对象，因此阻止了对象的正常回收。由于在引用队列中的元素排队执行 finalize() 函数，一旦出现性能问题，将导致这些垃圾对象长时间堆积在内存中，可能会导致 OOM。</p><p>图5.15 显示了 FinalizerThread 的工作过程和 FinalizerThread 执行队列中 Finalizer 的引用关系。</p><p><img src="/assets/图5-15.f01acd9d.png" alt="图5-15" loading="lazy"></p><p>图5.15 FinalizerThread 执行队列</p><p>【示例 5-8】以下代码演示了一个拥有糟糕的 finalize() 实现对象的回收过程。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongFinalize</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LF</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">LF</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> e <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中有一个拥有糟糕 finalize() 实现的类 LongFinalize$LF（这是一个内部类，因此带有 $ 符号）。可以看到，在第 8 行一个 sleep() 方法模拟了一个耗时操作，主函数则不断产生新的 LF 对象。使用如下参数执行上述代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx10m -Xms10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&quot;D:/f.dump&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果发生了 OOM，并在 D 盘下得到了堆的 Dump 文件。仔细阅读代码第 16 ~ 21 行，不难发现，每次循环中产生的 LF 对象（占用大约 512 字节）都会在下一次循环中失效（因为局部变量作用域过期，对象也无其他引用），因此所有产生的 LF 对象都应该可以被回收。10MB 堆空间理论上应该完全可以满足需要，只是需要多进行几次 GC，而这里为什么依然会出现 OOM 呢？使用 MAT（MAT 的具体介绍请参考第 7 章）打开得到的堆文件，如图5.16 所示。</p><p><img src="/assets/图5-16.dcf9cb18.png" alt="图5-16" loading="lazy"></p><p>图5.16 OOM 时显示大量 Finalizer</p><p>从最大对象中可以看到，目前系统中有大量的 Finalizer 类，这意味着 FinalizerThread 执行队列可能一直持有对象而来不及执行，因此大量的对象堆积而无法被释放，最终导致了这个 OOM。使用 MAT 自带的 ”Finalizer Overview“ 功能可以更好地观察系统中的 Finalizer，如图5.17 所示。</p><p><img src="/assets/图5-17.1f6ece41.png" alt="图5-17" loading="lazy"></p><p>图5.17 MAT 的 Finalizer 概览功能</p><p>使用该功能观察本例的 Finalizer，如图5.18 所示。该视图中显式了正在被执行 finalize() 函数的对象，以及准备执行的对象列表。读者可以根据这个功能，来分析系统中对象的 finalize() 函数执行情况。</p><p><img src="/assets/图5-18.5ee05c06.png" alt="图5-18" loading="lazy"></p><p>图5.18 FinalizerThread 执行队列的展示</p><p>去掉 LF 类的 finalize() 函数，即注释掉本例代码中的第 5 ~ 12 行，再次以相同的参数运行这段程序。可以观察到，程序很快正常结束。由此可以进一步说明 finalize() 函数对 GC 产生的影响。</p><p><strong>注意</strong>：一个糟糕的 finalize() 函数可能会使对象长时间被 Finalizer 引用，而得不到释放，这会进一步增加 GC 的压力。因此，应该是尽量少地使用 finalize() 函数。</p><p>虽然不推荐使用 finalize() 函数，但是在有些场合，使用 finalize() 函数可以起到双保险的作用。比如在 MySQL 的 JDBC 驱动中，com.mysql.jdbc.ConnectionImpl 就实现了 finalize() 函数，实现代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
    <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是，当一个 JDBC Connection 被回收时，需要进行连接的关闭，即这里的 cleanup() 方法。事实上，在回收前，开发人员如果正常调用了 Connection.close() 方法，连接就会被显式关闭，那样的话，在 cleanup() 方法中将什么都不会做。而如果开发人员忘记显式关闭连接，而 Connection 对象又被回收了，则会隐式地进行连接的关闭，确保没有数据库连接泄漏。而一般来说，官方鼓励开发人员在开发过程中显式关闭数据库连接。因此，finalize() 函数可能会被作为一种补偿措施，在正常方法出现意外时（开发人员疏忽）进行补偿，尽可能确保系统稳定。当然，由于其调用时间的不确定性，这不能单独作为可靠的资源回收手段。</p><h2 id="_5-6-温故又知新-常用的-gc-参数" tabindex="-1"><a class="header-anchor" href="#_5-6-温故又知新-常用的-gc-参数" aria-hidden="true">#</a> 5.6 温故又知新：常用的 GC 参数</h2><ol><li><p>与串行回收器相关的参数</p><ul><li>-XX:+UseSerialGC：在新生代和老年代使用串行回收器。</li><li>-XX:SurvivorRatio：设置 eden 区大小和 survivior 区大小的比例。</li><li>-XX:PretenureSizeThreshold：设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接被分配在老年代。</li><li>-XX:MaxTenuringThreshold：设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</li></ul></li><li><p>与并行 GC 相关的参数</p><ul><li>-XX:+UseParNewGC（考虑到兼容性问题，JDK 9、JDK 10 已经删除）：在新生代使用并行回收器。</li><li>-XX:+UseParallelOldGC：老年代使用并行回收器。</li><li>-XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等，但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。</li><li>-XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。它的值是一个大于 0 的整数。回收器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMillis 以内。</li><li>-XX:GCTimeRatio：设置吞吐量大小。它的值是一个 0 到 100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1 / (1 + n) 的时间用于垃圾回收。</li><li>-XX:+UseAdaptiveSizePolicy：打开自适应 GC 策略。在这种模式下，新生代的大小、edcn 区和 survivior 区的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡。</li></ul></li><li><p>与 CMS 回收器相关的参数（JDK 9、JDK 10 已经开始废弃 CMS 回收器，建议使用 G1回收器）</p><ul><li>-XX:+UseConcMarkSweepGC：新生代使用并行回收器，老年代使用 CMS + 串行回收器。</li><li>-XX:ParallelCMSThreads：设定 CMS 的线程数量。</li><li>-XX:CMSInitiatingOccupancyFraction：设置 CMS 回收器在老年代空间被使用多少后触发，默认为 68%。</li><li>-XX:+UseCMSCompactAtFullCollection：设置 CMS 回收器在完成垃圾回收后是否要进行一次内存碎片的整理。</li><li>-XX:CMSFullGCsBefbreCompaction：设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。</li><li>-XX:+CMSClassUnloadingEnabled：允许对类元数据区进行回收。</li><li>-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动 CMS 回收（前提是激活了 -XX:+CMSClassUnloadingEnabled）。</li><li>-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阈值的时候才进行 CMS 回收。</li><li>-XX:+CMSIncrementalMode：使用增量模式，比较适合单 CPU。增量模式在 JDK 8 中标记为废弃，并且将在 JDK 9 中彻底移除。</li></ul></li><li><p>与 G1 回收器相关的参数</p><ul><li>-XX:+UseG1GC：使用 G1 回收器。</li><li>-XX:MaxGCPauseMillis：设置最大垃圾回收停顿时间。</li><li>-XX:GCPauseIntervalMillis：设置停顿间隔时间。</li></ul></li><li><p>TLAB 相关</p><ul><li>-XX:+UseTLAB：开启 TLAB 分配。</li><li>-XX:+PrintTLAB（考虑到兼容性问题，JDK 9、JDK 10 不再支持此参数）：打印 TLAB 相关分配信息。</li><li>-XX:TLABSize：设置 TLAB 区域大小。</li><li>-XX:+ResizeTLAB：自动调整 TLAB 区域大小。</li></ul></li><li><p>其他参数</p><ul><li>-XX:+DisableExplicitGC：禁用显式 GC。</li><li>-XX:+ExplicitGClnvokesConcurrent：使用并发方式处理显式 GC。</li></ul></li></ol><h2 id="_5-7-动手才是真英雄-垃圾回收器对-tomcat-性能影响的实验" tabindex="-1"><a class="header-anchor" href="#_5-7-动手才是真英雄-垃圾回收器对-tomcat-性能影响的实验" aria-hidden="true">#</a> 5.7 动手才是真英雄：垃圾回收器对 Tomcat 性能影响的实验</h2><p>不同的垃圾回收器和堆大小对 Java 应用程序的性能有一定的影响。为了提高系统的性能，应该配置一些合理的虚拟机参数，比如堆大小、垃圾回收器类型等。系统的性能由很多方面决定，比如程序代码的质量、硬件的性能及网络带宽的延迟等，当然虚拟机参数也是重要的一环，是保障系统性能的必要非充分条件。也就是说，如果系统性能不令人满意，仅调整虚拟机参数也许根本无法解决问题，一个糟糕的系统实现是没有办法用虚拟机参数来弥补的，但一个良好的系统实现加上一个糟糕的参数配置，系统性能也不会有令人满意的表现。</p><h3 id="_5-7-1-配置实验环境" tabindex="-1"><a class="header-anchor" href="#_5-7-1-配置实验环境" aria-hidden="true">#</a> 5.7.1 配置实验环境</h3><p>本实验将使用不同的虚拟机参数启动 Tomcat 服务器，通过压力测试，获得虚拟机的主要性能指标，体验不同参数对系统性能的影响。实验背景如下：</p><ul><li><p>环境</p><ul><li>Tomcat 7</li><li>一个 JSP 网站</li><li>测试网站的吞吐量</li></ul></li><li><p>工具</p><ul><li>Apache JMeter</li></ul></li><li><p>实验原理</p><ul><li>通过 JMeter 对 Tomcat 增加压力，不同的虚拟机参数应该会有不同的性能表现</li></ul></li><li><p>目的</p><ul><li>观察不同参数配置对吞吐量的影响</li></ul></li></ul><p>实验系统结构如图5.19 所示，为防止 JMeter 对 Tomcat 产生影响，测试时使用两台独立的计算机，通过局域网连接。</p><p><img src="/assets/图5-19.d14e55ab.png" alt="图5-19" loading="lazy"></p><p>图5.19 实验系统结构</p><h3 id="_5-7-2-配置性能测试工具-jmeter" tabindex="-1"><a class="header-anchor" href="#_5-7-2-配置性能测试工具-jmeter" aria-hidden="true">#</a> 5.7.2 配置性能测试工具 JMeter</h3><p>JMeter 是 Apache 下基于 Java 的一款性能测试和压力测试工具。它基于 Java 开发，可对 HTTP 服务器和 FTP 服务器，甚至数据库进行压力测试。作为一款专业的压力测试工具，JMeter 功能强大，本节仅简要介绍与本次实验相关的功能。</p><p>JMeter 的运行主界面如图5.20 所示，下面开始详细讲述设置步骤。</p><p><img src="/assets/图5-20.b12273ec.png" alt="图5-20" loading="lazy"></p><p>图5.20 JMeter 的运行主界面</p><ol><li><p>为了能够使用 JMeter 对 Tomcat 服务器进行性能测试，首先需要添加线程组，线程组将模拟用户线程访问 Tomcat 服务器。图5.21 显示了如何在 JMeter 中添加线程组。</p><p><img src="/assets/图5-21.c077830b.png" alt="图5-21" loading="lazy"></p><p>图5.21 在 JMeter 中添加线程组</p></li><li><p>使用线程组可以设置请求的强度，如图5.22 所示，设置了 10 个线程，并且规定每个线程进行 1000 次请求。这样，Tomcat 就会在这次线程组的运行中，收到 10000 次请求。</p><p><img src="/assets/图5-22.32acd3bc.png" alt="图5-22" loading="lazy"></p><p>图5.22 在 JMeter 中配置线程组</p></li><li><p>除了线程组，要让 JMeter 正常工作还需要一个釆样器。釆样器用于对具体的请求进行性能数据的采样，如图5.23 所示。本例中，需要添加的是 HTTP 请求的采样。</p><p><img src="/assets/图5-23.c6e2f5d5.png" alt="图5-23" loading="lazy"></p><p>图5.23 添加采样器</p></li><li><p>对于添加的 HTTP 请求，还需要对请求的具体目标进行设置，比如目标服务器的地址、端口号、访问路径等信息，如图5.24 所示。JMeter 会按照设置的要求进行批量的请求访问。</p><p><img src="/assets/图5-24.2191c981.png" alt="图5-24" loading="lazy"></p><p>图5.24 设置HTTP请求</p></li><li><p>对于批量请求的访问结果，JMeter 可以以报告的形式呈现出来。在监听器中，添加聚合报告，如图5.25 所示。聚合报告可以统计整个测试的性能参数。</p><p><img src="/assets/图5-25.c11e3b1e.png" alt="图5-25" loading="lazy"></p><p>图5.25 添加聚合报告</p></li><li><p>添加后，聚合报告的内容如图5.26 所示。报告中主要内容为每次请求的延时情况和吞吐量。这里主要关注吞吐量，即图中用黑色矩形标注部分。</p><p><img src="/assets/图5-26.a3809fca.png" alt="图5-26" loading="lazy"></p><p>图5.26 聚合报告的内容</p></li></ol><p>至此，已经完整介绍了通过 JMeter 建立线程组、釆样器和聚合报告来进行压力测试并获得测试结果的方法，本实验将使用这个方法获得 Tomcat 的测试结果。</p><h3 id="_5-7-3-配置-web-应用服务器-tomcat" tabindex="-1"><a class="header-anchor" href="#_5-7-3-配置-web-应用服务器-tomcat" aria-hidden="true">#</a> 5.7.3 配置 Web 应用服务器 Tomcat</h3><p>Tomcat 服务器是一个免费的开放源代码 Web 应用服务器。Tomcat 是 Apache 软件基金会（Apache Software Foundation）的 Jakarta 项目中的一个核心项目，由 Apache、Sun 和其他一些公司及个人共同开发而成。它完全基于 Java 平台，也是目前使用最广泛的 Servlet 容器之一。Tomcat 安装完成后，目录结构如图5.27 所示。</p><p><img src="/assets/图5-27.e5e1078c.png" alt="图5-27" loading="lazy"></p><p>图5.27 Tomcat 目录结构</p><p>主要目录说明如下：</p><ul><li><p>bin 目录下是 Tomcat 的启动、关闭的程序。</p></li><li><p>conf 目录下是 Tomcat 服务器的配置文件，包括 Tomcat 的权限管理、线程池、端口号等配置信息。</p></li><li><p>webapps 目录下存放部署在 Tomcat 下的 Web 应用，每个应用对应一个文件夹或者 war 包。</p></li></ul><p>Tomcat 是一个标准的 Java 程序，因此 Tomcat 在启动的时候，自然可以配置 Java 虚拟机的参数。配置 Tomcat 启动虚拟机参数时，可以进入 bin 目录，查找 catalina.bat 文件（Linux 平台是 <a href="http://catalina.sh" target="_blank" rel="noopener noreferrer">catalina.sh<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>），可以通过修改 catalina.bat 文件来配置 Java 虚拟机参数。</p><p>在 catalina.bat 中，读者可以特别关注一下 JAVA_OPTS 和 CATALINA_OPTS 两个环境变量。它们在文件中的说明如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>rem  CATALINA_OPTS   (Optional) Java runtime options used when the &quot;start&quot;, 
rem	                &quot;run&quot; or &quot;debug&quot; command is executed.
rem	                Include here and not in JAVA_OPTS all options, that should
rem	                only be used by Tomcat itself, not by the stop process,
rem	                the version command etc.
rem	                Examples are heap size, GC logging, JMX ports etc.
rem  JAVA_OPTS       (Optional) Java runtime options used when any command rem	is executed.
rem	                Include here and not in CATALINA_OPTS all options, that
rem	                should be used by Tomcat and also by the stop process,
rem	                the version command etc.
rem	                Most options should	go into	CATALINA_OPTS.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个环境变量都可以用来控制 Tomcat 启动时的虚拟机参数。CATALINA_OPTS 用于控制 Tomcat 本身的虚拟机参数，比如堆大小、GC 日志等，这个配置不会被 Tomcat 的其他进程（比如 shutdown.bat）使用。JAVA_OPTS 变量的使用范围更广，除了 Tomcat，其他相关进程也会使用 JAVA_OPTS 的配置。我们在大部分情况下使用 CATALINA_OPTS 即可。</p><p>在本次实验中，均通过设置 CATALINA_OPTS 来控制虚拟机的行为。</p><h3 id="_5-7-4-实战案例-1——初试串行回收器" tabindex="-1"><a class="header-anchor" href="#_5-7-4-实战案例-1——初试串行回收器" aria-hidden="true">#</a> 5.7.4 实战案例 1——初试串行回收器</h3><p>使用 JDK 1.8 开启 Tomcat，设置参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS= -Xloggc:gc.log
-XX:+PrintGCDetails -Xmx32M -Xms32M
-XX:+HeapDumpOnOutOfMemoryError -XX:+UseSerialGC -XX:PermSize=32M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此参数中设置了最大堆为 32MB。在进行一段时间的请求后，部分 GC 日志如图5.28 所示。</p><p><img src="/assets/图5-28.8226e0e3.png" alt="图5-28" loading="lazy"></p><p>图5.28 实战案例 1 部分 GC 日志</p><p>可以看到，Tomcat 进行了大量频繁的 Full GC。老年代大小为 21888KB，并基本用完，整个堆可用大小为 31680KB，也基本使用殆尽。使用 JMeter 观察到的聚合报告如图5.29 所示。</p><p><img src="/assets/图5-29.1550917f.png" alt="图5-29" loading="lazy"></p><p>图5.29 实战案例 1 聚合报告</p><p>可以看到，在这 10000 次请求中最终的吞吐量定位在 540 次/秒。</p><h3 id="_5-7-5-实战案例-2——扩大堆以提升系统性能" tabindex="-1"><a class="header-anchor" href="#_5-7-5-实战案例-2——扩大堆以提升系统性能" aria-hidden="true">#</a> 5.7.5 实战案例 2——扩大堆以提升系统性能</h3><p>修改实战案例 1 中的最大堆大小，将其调整为 512MB，整理参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx512m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用相同的方式测试新的参数，得到的 GC 日志如图5.30 所示。</p><p><img src="/assets/图5-30.2b4aeba0.png" alt="图5-30" loading="lazy"></p><p>图5.30 实成案例 2 部分 GC 日志</p><p>可以看到，当设置最大堆为 512MB 后（未设置初始堆），启动初期，可用堆约为 16MB，随着请求的增加，最终堆大小扩展到 60MB 左右。在日志最后也未出现 FullGC，说明所有的回收都在新生代完成，这是和实战案例 1 最大的不同。同时，由于新生代 GC 速度普遍比 Full GC 更快，因此，单次 GC 耗时也相差约 1 个数量级。</p><p>最终，JMeter 的聚合报告如图5.31 所示。可以看到，吞吐量上升到了 651 次/秒。</p><p><img src="/assets/图5-31.542f7893.png" alt="图5-31" loading="lazy"></p><p>图5.31 实成案例 2 聚合告</p><h3 id="_5-7-6-实战案例-3——调整初始堆大小" tabindex="-1"><a class="header-anchor" href="#_5-7-6-实战案例-3——调整初始堆大小" aria-hidden="true">#</a> 5.7.6 实战案例 3——调整初始堆大小</h3><p>根据实战案例 2 的结果可知，系统的堆最终会稳定在 60MB 附近，因此小于 60MB 的堆很有可能会引起大量 GC。在实战案例 3 中扩大初始堆为 60MB，设置参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx512m -Xms64m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动 Tomcat，并运行 JMeter，得到 Tomcat 的部分 GC 日志如图5.32 所示。</p><p><img src="/assets/图5-32.b19a9566.png" alt="图5-32" loading="lazy"></p><p>图5.32 实战案例 3 部分 GC 日志</p><p>通过 GC 日志可以看到，在本次实验中，GC 数量大幅减少，并且存在的基本都是新生代 GC。从聚合报告中也可以看到，吞吐量为 674 次/秒，如图5.33 所示。</p><p><img src="/assets/图5-33.058386bb.png" alt="图5-33" loading="lazy"></p><p>图5.33 实战案例 3 聚合报告</p><h3 id="_5-7-7-实战案例-4——使用-parrelloldgc-回收器" tabindex="-1"><a class="header-anchor" href="#_5-7-7-实战案例-4——使用-parrelloldgc-回收器" aria-hidden="true">#</a> 5.7.7 实战案例 4——使用 ParrellOldGC 回收器</h3><p>使用 ParrellOldGC 回收器代替串行回收器。在笔者的计算机上，默认情况下使用的是串行回收器。设置虚拟机参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx512m -Xms64m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
-XX:+UseParallelGC -XX:+UseParallelOldGC -XX:ParallelGCThreads=4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>堆大小和实战案例 3 保持不变，但是更换了垃圾回收器。测试得到的聚合报告如图5.34 所示。</p><p><img src="/assets/图5-34.6810b93b.png" alt="图5-34" loading="lazy"></p><p>图5.34 实战案例 4 聚合报告</p><p>可以看到，由于 GC 压力在本次实验中并不大（由实战案例 3 的 GC 日志可以得出这个结论），更换垃圾回收器后，吞吐量并无改善。</p><h3 id="_5-7-8-实战案例-5——使用较小堆提高-gc-压力" tabindex="-1"><a class="header-anchor" href="#_5-7-8-实战案例-5——使用较小堆提高-gc-压力" aria-hidden="true">#</a> 5.7.8 实战案例 5——使用较小堆提高 GC 压力</h3><p>通过设置一个较小的堆，增加 GC 压力，以此来考察不同垃圾回收器的表现，依然使用串行回收器。设置虚拟机参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx40m -Xms40m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将初始堆和最大堆统一设置为 40MB，并使用串行回收器。得到的聚合报告如图5.35 所示。</p><p><img src="/assets/图5-35.08374a48.png" alt="图5-35" loading="lazy"></p><p>图5.35 实战案例 5 聚合报告</p><p>减小堆大小后，吞吐量有较为明显的下降（从实战案例 3 可以知道，本次实验堆大小在 60MB 左右是没有 GC 压力的，而小于 60MB 的堆会有一定的 GC 压力）。</p><h3 id="_5-7-9-实战案例-6——测试-paralleloldgc-的表现" tabindex="-1"><a class="header-anchor" href="#_5-7-9-实战案例-6——测试-paralleloldgc-的表现" aria-hidden="true">#</a> 5.7.9 实战案例 6——测试 ParallelOldGC 的表现</h3><p>在实战案例 5 的基础上，更换 ParallelOldGC 回收器进行测试。使用参数如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx40m -Xms40m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
-XX:+UseParallelOldGC -XX:ParallelGCThreads=4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的聚合报告如图5.36 所示。</p><p><img src="/assets/图5-36.de276309.png" alt="图5-36" loading="lazy"></p><p>图5.36 实战案例 6 聚合报告</p><p>可以看到，在有一定 GC 压力的情况下，使用 ParallelOldGC 回收器对系统性能有较为明显的改善。</p><p><strong>注意</strong>：ParallelOldGC 回收器在多核 CPU 上才有可能改善性能，对于单核 CPU 或者并行能力较弱的计算机，还是应该选择串行回收器。</p><h3 id="_5-7-10-实战案例-7——测试-parnew-回收器的表现" tabindex="-1"><a class="header-anchor" href="#_5-7-10-实战案例-7——测试-parnew-回收器的表现" aria-hidden="true">#</a> 5.7.10 实战案例 7——测试 ParNew 回收器的表现</h3><p>使用 ParNew 回收器代替 ParallelOldGC，这样在老年代依然使用串行回收器，仅在新生代使用并行回收器。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>set CATALINA_OPTS=-Xmx40m -Xms40m
-XX:MaxPermSize=32M
-Xloggc:gc.log -XX:+PrintGCDetails
-XX:+UseParNewGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的聚合报告如图5.37 所示。</p><p><img src="/assets/图5-37.ae0f9cdc.png" alt="图5-37" loading="lazy"></p><p>图5.37 实战案例 7 聚合报告</p><p>可以看到，性能比实战案例 6 差些，但仍然好于实战案例 5 的全串行结果。</p><h3 id="_5-7-11-实战案例-8——测试-jdk-1-8-的表现" tabindex="-1"><a class="header-anchor" href="#_5-7-11-实战案例-8——测试-jdk-1-8-的表现" aria-hidden="true">#</a> 5.7.11 实战案例 8——测试 JDK 1.8 的表现</h3><p>在本次实战案例中，使用 JDK 1.8，并使用如下参数：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>-Xmx40m -Xms40m -XX:MaxPermSize=32M -Xloggc:gc.log -XX:+PrintGCDetails -XX:+UseSerialGC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到的聚合报告如图5.38 所示。</p><p><img src="/assets/图5-38.c92cdcb7.png" alt="图5-38" loading="lazy"></p><p>图5.38 实战案例 8 聚合报告</p><h3 id="_5-7-12-实战案例-9——使用高版本虚拟机提升性能" tabindex="-1"><a class="header-anchor" href="#_5-7-12-实战案例-9——使用高版本虚拟机提升性能" aria-hidden="true">#</a> 5.7.12 实战案例 9——使用高版本虚拟机提升性能</h3><p>在本次实战案例中，使用和实战案例 8 相同的 Java 虚拟机参数，但是使用 JDK 10 运行 Tomcat 服务器，得到如图5.39 所示的结果。</p><p><img src="/assets/图5-39.92440167.png" alt="图5-39" loading="lazy"></p><p>图5.39 实战案例 9 聚合报告</p><p>可以看到，只是简单的升级虚拟机版本，也可以得到意外的性能提升。这种免费的午餐是值得大家尝试的，但是 JDK 版本升级依然伴随一定风险，也许在新版本的 JDK 中引入了某些未知的 Bug。因此，必须要做好充分的回归测试工作。</p><h2 id="_5-8-小结" tabindex="-1"><a class="header-anchor" href="#_5-8-小结" aria-hidden="true">#</a> 5.8 小结</h2><p>本章主要介绍了虚拟机支持的各种垃圾回收的种类、使用方法和相关参数，着重介绍了串行回收器、并行回收器、CMS 和 G1 回收器。此外，本章还介绍了有关对象分配和回收的一些细节问题。最后，笔者尝试使用各种垃圾回收器及各项参数，测试了它们对 Tomcat 服务器的性能影响。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/实战Java虚拟机：JVM故障诊断与性能优化/第5章垃圾收集器和内存分配.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC4%E7%AB%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link prev" aria-label="第 4 章 垃圾回收的概念与算法"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 4 章 垃圾回收的概念与算法</div></a><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%AC%AC6%E7%AB%A0%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7.html" class="nav-link next" aria-label="第 6 章 性能监控工具"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 6 章 性能监控工具<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
