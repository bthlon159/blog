<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 2 章 理解数据背后的二进制"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-16T11:56:17.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-16T11:56:17.000Z"><title>第 2 章 理解数据背后的二进制 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link active" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java 编程的逻辑</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第一部分 编程基础与二进制</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="第 1 章 编程基础"><!---->第 1 章 编程基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 2 章 理解数据背后的二进制"><!---->第 2 章 理解数据背后的二进制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-整数的二进制表示与位运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1 整数的二进制表示与位运算"><!---->2.1 整数的二进制表示与位运算<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-1-正整数的二进制表示" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1.1 正整数的二进制表示"><!---->2.1.1 正整数的二进制表示<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-2-负整数的二进制表示" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1.2 负整数的二进制表示"><!---->2.1.2 负整数的二进制表示<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-3-十六进制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1.3 十六进制"><!---->2.1.3 十六进制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-4-位运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.1.4 位运算"><!---->2.1.4 位运算<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-小数的二进制表示" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2 小数的二进制表示"><!---->2.2 小数的二进制表示<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-1-小数计算为什么会出错" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2.1 小数计算为什么会出错"><!---->2.2.1 小数计算为什么会出错<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-2-二进制表示" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.2.2 二进制表示"><!---->2.2.2 二进制表示<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-字符的编码与乱码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3 字符的编码与乱码"><!---->2.3 字符的编码与乱码<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-1-常见非-unicode-编码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3.1 常见非 Unicode 编码"><!---->2.3.1 常见非 Unicode 编码<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-2-unicode-编码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3.2 Unicode 编码"><!---->2.3.2 Unicode 编码<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-3-编码转换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3.3 编码转换"><!---->2.3.3 编码转换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-4-乱码的原因" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3.4 乱码的原因"><!---->2.3.4 乱码的原因<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-5-从乱码中恢复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.3.5 从乱码中恢复"><!---->2.3.5 从乱码中恢复<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-4-char-的真正含义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.4 char 的真正含义"><!---->2.4 char 的真正含义<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 面向对象</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC3%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 类的基础"><!---->第 3 章 类的基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类的继承"><!---->第 4 章 类的继承<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 类的继承"><!---->第 5 章 类的继承<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC6%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 异常"><!---->第 6 章 异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC7%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 常用基础类"><!---->第 7 章 常用基础类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第三部分 泛型与容器</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC8%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 泛型"><!---->第 8 章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC9%E7%AB%A0%20%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 列表和队列"><!---->第 9 章 列表和队列<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC10%E7%AB%A0%20Map%E5%92%8CSet.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 Map 和 Set"><!---->第 10 章 Map 和 Set<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC11%E7%AB%A0%20%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%97%E8%A1%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 堆与优先级列表"><!---->第 11 章 堆与优先级列表<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC12%E7%AB%A0%20%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E6%80%BB%E7%BB%93.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 通用容器和总结"><!---->第 12 章 通用容器和总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 文件</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC13%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 文件基本技术"><!---->第 13 章 文件基本技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC14%E7%AB%A0%20%E6%96%87%E4%BB%B6%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 14 章 文件高级技术"><!---->第 14 章 文件高级技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第五部分 并发</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC15%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 15 章 并发基础知识"><!---->第 15 章 并发基础知识<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC16%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E5%9F%BA%E7%9F%B3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 16 章 并发包的基石"><!---->第 16 章 并发包的基石<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC17%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 17 章 并发容器"><!---->第 17 章 并发容器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC18%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 18 章 异步任务执行服务"><!---->第 18 章 异步任务执行服务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC19%E7%AB%A0%20%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 19 章 同步和协作工具类"><!---->第 19 章 同步和协作工具类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC20%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93.html" class="nav-link sidebar-link sidebar-page" aria-label="第 20 章 并发总结"><!---->第 20 章 并发总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第六部分 动态与函数编程</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC21%E7%AB%A0%20%E5%8F%8D%E5%B0%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 21 章 反射"><!---->第 21 章 反射<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC22%E7%AB%A0%20%E6%B3%A8%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 22 章 注解"><!---->第 22 章 注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC23%E7%AB%A0%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 23 章 动态代理"><!---->第 23 章 动态代理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC24%E7%AB%A0%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 24 章 类加载机制"><!---->第 24 章 类加载机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC25%E7%AB%A0%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 25 章 正则表达式"><!---->第 25 章 正则表达式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC26%E7%AB%A0%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 26 章 函数式编程"><!---->第 26 章 函数式编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 2 章 理解数据背后的二进制</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月19日</span><meta property="datePublished" content="2022-06-19T14:33:42.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 11773 字</span><meta property="wordCount" content="11773"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-整数的二进制表示与位运算" class="router-link-active router-link-exact-active toc-link level2">2.1 整数的二进制表示与位运算</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-1-正整数的二进制表示" class="router-link-active router-link-exact-active toc-link level3">2.1.1 正整数的二进制表示</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-2-负整数的二进制表示" class="router-link-active router-link-exact-active toc-link level3">2.1.2 负整数的二进制表示</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-3-十六进制" class="router-link-active router-link-exact-active toc-link level3">2.1.3 十六进制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-1-4-位运算" class="router-link-active router-link-exact-active toc-link level3">2.1.4 位运算</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-小数的二进制表示" class="router-link-active router-link-exact-active toc-link level2">2.2 小数的二进制表示</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-1-小数计算为什么会出错" class="router-link-active router-link-exact-active toc-link level3">2.2.1 小数计算为什么会出错</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-2-2-二进制表示" class="router-link-active router-link-exact-active toc-link level3">2.2.2 二进制表示</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-字符的编码与乱码" class="router-link-active router-link-exact-active toc-link level2">2.3 字符的编码与乱码</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-1-常见非-unicode-编码" class="router-link-active router-link-exact-active toc-link level3">2.3.1 常见非 Unicode 编码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-2-unicode-编码" class="router-link-active router-link-exact-active toc-link level3">2.3.2 Unicode 编码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-3-编码转换" class="router-link-active router-link-exact-active toc-link level3">2.3.3 编码转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-4-乱码的原因" class="router-link-active router-link-exact-active toc-link level3">2.3.4 乱码的原因</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-3-5-从乱码中恢复" class="router-link-active router-link-exact-active toc-link level3">2.3.5 从乱码中恢复</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html#_2-4-char-的真正含义" class="router-link-active router-link-exact-active toc-link level2">2.4 char 的真正含义</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-2-章-理解数据背后的二进制" tabindex="-1"><a class="header-anchor" href="#第-2-章-理解数据背后的二进制" aria-hidden="true">#</a> 第 2 章 理解数据背后的二进制</h1><p>在第 1 章，我们遗留了几个问题。</p><ul><li>正整数相乘的结果居然出现了负数。</li><li>非常基本的小数运算结果居然不精确。</li><li>字符类型也可以进行算术运算和比较。</li></ul><p>要理解这些行为，我们需要理解数值和文本字符在计算机内部的二进制表示，本章就来介绍各种数据背后的二进制，具体分为 4 节：2.1 节介绍整数；2.2 节介绍小数；2.3 节介绍与语言无关的字符和文本的编码以及乱码；2.4 节介绍 Java 中表示字符的基本类型 char。</p><h2 id="_2-1-整数的二进制表示与位运算" tabindex="-1"><a class="header-anchor" href="#_2-1-整数的二进制表示与位运算" aria-hidden="true">#</a> 2.1 整数的二进制表示与位运算</h2><p>要理解整数的二进制，我们先来看下熟悉的十进制。我们对十进制是如此熟悉，可能已忽略了它的含义。比如 123，不假思索我们就知道它的值是多少。</p><p>但其实 123 表示 1x 10<sup>2</sup> + 2 x 10<sup>1</sup> + 3 x 10<sup>0</sup>，它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以 10 的 0 次方，即 1，第二位乘以 10 的 1 次方，即 10，第三位乘以 10 的 2 次方，即 100，以此类推。</p><p>换句话说，每个位置都有一个位权，从右到左，第一位为 1，然后依次乘以 10，即第二位为 10，第三位为 100，以此类推。</p><h3 id="_2-1-1-正整数的二进制表示" tabindex="-1"><a class="header-anchor" href="#_2-1-1-正整数的二进制表示" aria-hidden="true">#</a> 2.1.1 正整数的二进制表示</h3><p>正整数的二进制表示与此类似，只是在十进制中，每个位置可以有 10 个数字，为 0 ~ 9，但在二进制中，每个位置只能是 0 或 1。位权的概念是类似的，从右到左，第一位为 1，然后依次乘以 2，即第二位为 2，第三位为 4，以此类推。表2-1 列出了一些数字的二进制与对应的十进制。</p><table style="text-align:center;"><tr><th>二进制</th><th>十进制</th></tr><tr><td>10</td><td>2</td></tr><tr><td>11</td><td>3</td></tr><tr><td>111</td><td>7</td></tr><tr><td>1010</td><td>10</td></tr></table><div> 表2-1 二进制与对应的十进制 </div><h3 id="_2-1-2-负整数的二进制表示" tabindex="-1"><a class="header-anchor" href="#_2-1-2-负整数的二进制表示" aria-hidden="true">#</a> 2.1.2 负整数的二进制表示</h3><p>十进制的负数表示就是在前面加一个负数符号 -，例如 -123。但二进制如何表示负数呢？其实概念是类似的，二进制使用最高位表示符号位，用 1 表示负数，用 0 表示正数。但哪个是最高位呢？整数有 4 种类型 byte、short、int、long，分别占 1、2、4、8 个字节，即分别占 8、16、32、64 位，每种类型的符号位都是其最左边的一位。为方便举例，下面假定类型是 byte，即从右到左的第 8 位表示符号位。</p><p>但负数表示不是简单地将最高位变为 1，比如：</p><p>1）byte a = -1，如果只是将最高位变为 1，二进制应该是 10000001，但实际上，它应该是 11111111。</p><p>2）byte a = -127，如果只是将最高位变为 1，二进制应该是 11111111，但实际上，它却应该是 10000001。</p><p>和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加 1。取反就是将。变为 1, 1 变为 0。负数的二进制表示就是对应的正数的补码表示，比如：</p><p>1）-1：1 的原码表示是 00000001，取反是 11111110，然后再加 1，就是 11111111。</p><p>2）-2：2 的原码表示是 00000010，取反是 11111101，然后再加 1，就是 11111110。</p><p>3）-127：127 的原码表示是 01111111，取反是 10000000，然后再加 1，就是10000001。</p><p>给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为 01101101，然后加 1，结果为 01101110，它的十进制值为 110，所以原值就是 -110。直觉上，应该是先减 1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。</p><p>对于 byte 类型，正数最大表示是 01111111，即 127，负数最小表示（绝对值最大）是 10000000，即 -128，表示范围就是 -128 ~ 127。其他类型的整数也类似，负数能多表示一个数。</p><p>负整数为什么要采用这种奇怪的表示形式呢？原因是，只有这种形式，计算机才能实现正确的加减法。</p><p>计算机其实只能做加法，1 - 1 其实是 1 + (-1)。如果用原码表示，计算结果是不对的，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span>	 <span class="token operator">-&gt;</span> <span class="token number">00000001</span>
<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">10000001</span>
<span class="token operator">+</span>	______________
<span class="token operator">-</span><span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">10000010</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用符合直觉的原码表示，1 - 1 的结果是 -2，如果是补码表示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span>  <span class="token operator">-&gt;</span> <span class="token number">00000001</span>
<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">11111111</span>
<span class="token operator">+</span>	______________
<span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token number">00000000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是正确的。再如，5 - 3：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">5</span>  <span class="token operator">-&gt;</span> <span class="token number">00000101</span>
<span class="token operator">-</span><span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">11111101</span>
<span class="token operator">+</span>	______________
<span class="token number">2</span>  <span class="token operator">-&gt;</span> <span class="token number">00000010</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果也是正确的。就是这样，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？</p><p>理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是 1，然后就会被看作负数。比如，127 + 1：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">127</span>	 <span class="token operator">-&gt;</span> <span class="token number">01111111</span>
<span class="token number">1</span>	   <span class="token operator">-&gt;</span> <span class="token number">00000001</span>
<span class="token operator">+</span>	________________
<span class="token operator">-</span><span class="token number">128</span> <span class="token operator">-&gt;</span> <span class="token number">10000000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算结果超出了 byte 的表示范围，会被看作 -128。</p><h3 id="_2-1-3-十六进制" tabindex="-1"><a class="header-anchor" href="#_2-1-3-十六进制" aria-hidden="true">#</a> 2.1.3 十六进制</h3><p>二进制写起来太长，为了简化写法，可以将 4 个二进制位简化为一个 0 ~ 15 的数，10 ~ 15 用字符 A ~ F 表示，这种表示方法称为十六进制，如表2-2 所示。</p><table style="text-align:center;"><tr><th>二进制</th><th>十进制</th><th>十六进制</th></tr><tr><td>1010</td><td>10</td><td>A</td></tr><tr><td>1011</td><td>11</td><td>B</td></tr><tr><td>1100</td><td>12</td><td>C</td></tr><tr><td>1101</td><td>13</td><td>D</td></tr><tr><td>1110</td><td>14</td><td>E</td></tr><tr><td>1111</td><td>15</td><td>F</td></tr></table><div> 表2-2 十六进制 </div><p>可以用十六进制直接写常量数字，在数字前面加 0x 即可。比如十进制的 123，用十六进制表示是 0x7B，即 123 = 7 x 16 + 11。给整数赋值或者进行运算的时候，都可以直接使用十六进制，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x7B</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Java 7 之前不支持直接写二进制常量。比如，想写二进制形式的 11001，Java 7 之前不能直接写，可以在前面补 0，补足 8 位，为 00011001，然后用十六进制表示，即 0x19。Java 7 开始支持二进制常量，在前面加 0b 或 0B 即可，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0b11001</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 Java 中，可以方便地使用 Integer 和 Long 的方法查看整数的二进制和十六进制表示，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token comment">// 二进制</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 十六进制</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 二进制</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//十六进制</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-1-4-位运算" tabindex="-1"><a class="header-anchor" href="#_2-1-4-位运算" aria-hidden="true">#</a> 2.1.4 位运算</h3><p>理解了二进制表示，我们来看二进制级别的操作：位运算。Java 7 之前不能单独表示一个位，但可以用 byte 表示 8 位，用十六进制写二进制常量。比如，0010 表示成十六进制是 0x2，110110 表示成十六进制是 0x36。</p><p>位运算有移位运算和逻辑运算。移位有以下几种。</p><p>1）左移：操作符为 &lt;&lt;，向左移动，右边的低位补 0，高位的就舍弃掉了，将二进制看作整数，左移 1 位就相当于乘以 2。</p><p>2）无符号右移：操作符为 &gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补 0。</p><p>3）有符号右移：操作符为 &gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是 1 就补 1，原来是 0 就补 0，将二进制看作整数，右移 1 位相当于除以 2。</p><p>例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 100</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> 
<span class="token comment">// 001，等于 1</span>
a <span class="token operator">=</span> a <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span> 
<span class="token comment">//1000，变为 8</span>
a <span class="token operator">=</span> a <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逻辑运算有以下几种。</p><ul><li>按位与 &amp;：两位都为 1 才为 1。</li><li>按位或 |：只要有一位为 1，就为 1。</li><li>按位取反 ~：1 变为 0，0 变为 1。</li><li>按位异或 ^：相异为真，相同为假。</li></ul><p>大部分都比较简单，如下所示，具体就不赘述了。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token comment">// 返回 0 或 1，就是 a 最右边一位的值</span>
a <span class="token operator">=</span> a <span class="token operator">&amp;</span> <span class="token number">0x1</span> 
<span class="token comment">// 不管 a 原来最右边一位是什么，都将设为 1</span>
a <span class="token operator">=</span> a <span class="token operator">|</span> <span class="token number">0x1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-2-小数的二进制表示" tabindex="-1"><a class="header-anchor" href="#_2-2-小数的二进制表示" aria-hidden="true">#</a> 2.2 小数的二进制表示</h2><p>计算机之所以叫 “计算” 机，就是因为发明它主要是用来计算的，“计算” 当然是它的特长，在大家的印象中，计算一定是非常准确的。但实际上，即使在一些非常基本的小数运算中，计算的结果也是不精确的，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">0.1f</span> <span class="token operator">*</span> <span class="token number">0.1f</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结果看上去，应该是 0.01，但实际上，屏幕输出却是 0.010000001，后面多了个 1。看上去这么简单的运算，计算机怎么会出错了呢？</p><h3 id="_2-2-1-小数计算为什么会出错" tabindex="-1"><a class="header-anchor" href="#_2-2-1-小数计算为什么会出错" aria-hidden="true">#</a> 2.2.1 小数计算为什么会出错</h3><p>实际上，不是运算本身会出错，而是计算机根本就不能精确地表示很多数，比如 0.1 这个数。计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示 0.1，它只能表示一个非常接近 0.1 但又不等于 0.1 的一个数。数字都不能精确表示，在不精确数字上的运算结果不精确也就不足为奇了。</p><p>0.1 怎么就不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。</p><p>实际上，十进制也只能表示那些可以表述为 10 的多少次方和的数，比如 12.345，实际上表示的是 1 x 10 + 2 x 1 + 3 x 0.1 + 4 x 0.01 + 5 x 0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为 0.1，0.01，0.001，... 即 10<sup>-1</sup>，10<sup>-2</sup>，10<sup>-3</sup> 等。</p><p>很多数十进制也是不能精确表示的，比如 1/3，保留三位小数的话，十进制表示是 0.333，但无论后面保留多少位小数，都是不精确的，用 0.333 进行运算，比如乘以 3，期望结果是 1，但实际上却是 0.999。</p><p>二进制是类似的，但二进制只能表示那些可以表述为 2 的多少次方和的数。来看下 2 的次方的一些例子，如表2-3 所示。</p><table style="text-align:center;"><tr><th>二进制</th><th>十进制</th></tr><tr><td>2<sup>-1</sup></td><td>0.5</td></tr><tr><td>2<sup>-2</sup></td><td>0.25</td></tr><tr><td>2<sup>-3</sup></td><td>0.125</td></tr><tr><td>2<sup>-4</sup></td><td>0.0625</td></tr></table><div> 表2-3 2 的次方 </div><p>可以精确表示为 2 的某次方之和的数可以精确表示，其他数则不能精确表示。</p><p>为什么计算机中不能用我们熟悉的十进制呢？在最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，对应 0 和 1，使用二进制容易基于这些电子元器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。</p><p>如果编写程序进行试验，会发现有的计算结果是准确的。比如，用 Java 写</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">0.1f</span> <span class="token operator">+</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">0.1f</span> <span class="token operator">*</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行输出 0.2，第二行输出 0.010000001。按照上面的说法，第一行的结果应该也不对。其实，这只是 Java 语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和 0.2 足够接近，在输出的时候，Java 选择了输出 0.2 这个看上去非常精简的数字，而不是一个中间有很多 0 的小数。在误差足够小的时候，结果看上去是精确的，但不精确其实才是常态。</p><p>计算不精确，怎么办呢？大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。如果真的需要比较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数；另一种方法是使用十进制的数据类型，这个并没有统一的规范。在 Java 中是 BigDecimal，运算更准确，但效率比较低，本节就不介绍了。</p><h3 id="_2-2-2-二进制表示" tabindex="-1"><a class="header-anchor" href="#_2-2-2-二进制表示" aria-hidden="true">#</a> 2.2.2 二进制表示</h3><p>我们之前一直在用 “小数” 这个词表示 float 和 double 类型，其实，这是不严谨的，“小数” 是在数学中用的词，在计算机中，我们一般说的是“浮点数”。float 和 double 被称为浮点数据类型，小数运算被称为浮点运算。</p><p>为什么要叫浮点数呢？这是由于小数的二进制表示中，表示那个小数点的时候，点不是固定的，而是浮动的。</p><p>我们还是用十进制类比，十进制有科学记数法，比如 123.45 这个数，直接这么写，就是固定表示法，如果用科学记数法，在小数点前只保留一位数字，可以写为 1.2345E2 即 1.2345 x 10<sup>2</sup>，即在科学记数法中，小数点向左浮动了两位。</p><p>二进制中为表示小数，也采用类似的科学表示法，形如 m x 2<sup>e</sup>。m 称为尾数，e 称为指数。指数可以为正，也可以为负，负的指数表示那些接近 0 的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负。</p><p>几乎所有的硬件和编程语言表示小数的二进制格式都是一样的。这种格式是一个标准，叫做 IEEE 754 标准，它定义了两种格式：一种是 32 位的，对应于 Java 的 float；另一种是 64 位的，对应于 Java 的 double。</p><p>32 位格式中，1 位表示符号，23 位表示尾数，8 位表示指数。64 位格式中，1 位表示符号，52 位表示尾数，11 位表示指数。在两种格式中，除了表示正常的数，标准还规定了一些特殊的二进制形式表示一些特殊的值，比如负无穷、正无穷、0、NaN（非数值，比如 0 乘以无穷大）。IEEE 754 标准有一些复杂的细节，初次看上去难以理解，对于日常应用也不常用，本书就不介绍了。</p><p>如果想查看浮点数的具体二进制形式，在 Java 中，可以使用如下代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">floatToIntBits</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">doubleToIntBits</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-3-字符的编码与乱码" tabindex="-1"><a class="header-anchor" href="#_2-3-字符的编码与乱码" aria-hidden="true">#</a> 2.3 字符的编码与乱码</h2><p>本节讨论与语言无关的字符和文本的编码以及乱码。我们在处理文件、浏览网页、编写程序时，时不时会碰到乱码的情况。乱码几乎总是令人心烦，让人困惑，通过阅读本节，相信你就可以自信从容地面对乱码，进而恢复乱码了。</p><p>编码和乱码听起来比较复杂，但其实并不复杂，请耐心阅读，让我们逐步来探讨。我们先介绍各种编码，然后介绍编码转换，分析乱码出现的原因，最后介绍如何从乱码中恢复。编码有两大类：一类是非 Unicode 编码；另一类是 Unicode 编码。我们先介绍非 Unicode 编码。</p><h3 id="_2-3-1-常见非-unicode-编码" tabindex="-1"><a class="header-anchor" href="#_2-3-1-常见非-unicode-编码" aria-hidden="true">#</a> 2.3.1 常见非 Unicode 编码</h3><p>下面我们看一些主要的非 Unicode 编码，包括 ASCII、ISO 8859-1、Windows-1252、GB2312、GBK、GB18030 和 Big5。</p><ol><li><p><strong>ASCII</strong></p><p>世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求。美国大概只需要 128 个字符，所以就规定了 128 个字符的二进制表示方法。这个方法是一个标准，称为 ASCII 编码，全称是 American Standard Code for Information Interchange，即美国信息互换标准代码。</p><p>128 个字符用 7 位刚好可以表示，计算机存储的最小单位是 byte，即 8 位，ASCII 码中最高位设置为 0，用剩下的 7 位表示字符。这 7 位可以看作数字 0 ~ 127，ASCII 码规定了从 0 ~ 127 的每个数字代表什么含义。</p><p>我们先来看数字 32 ~ 126 的含义，如图2-1 所示，除了中文之外，我们平常用的字符基本都涵盖了，键盘上的字符大部分也都涵盖了。</p><img src="/assets/图2-1.cb1f4ffa.png" alt="图2-1.png" style="zoom:50%;"><p>数字 32 ~ 126 表示的字符都是可打印字符，0 ~ 31 和 127 表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，表 2-4 列出了其中相对常用的字符。</p><table style="text-align:center;"><tr><th>数字</th><th>缩写 / 字符</th><th>解释</th><th>转义字符</th></tr><tr><td>0</td><td>NUL (null)</td><td>空字符</td><td>\0</td></tr><tr><td>8</td><td>BS (backspace)</td><td>退格</td><td>\b</td></tr><tr><td>9</td><td>HT (horizontal tab)</td><td>水平制表符</td><td>\t</td></tr><tr><td>10</td><td>LF (NL line feed, new line)</td><td>换行符</td><td>\n</td></tr><tr><td>13</td><td>CR (carriage return)</td><td>回车符</td><td>\r</td></tr><tr><td>27</td><td>ESC</td><td>换码</td><td></td></tr><tr><td>127</td><td>DEL (delete)</td><td>删除</td><td></td></tr></table><div> 表2-4 ASCII 编码：常用不可打印字符 </div><p>ASCII 码对美国是够用了，但对其他国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与 ASCII 码的兼容性，一般都是将最高位设置为 1。也就是说，当最高位为 0 时，表示 ASCII 码，当为 1 时就是各个国家自己的字符。在这些扩展的编码中，在西欧国家中流行的是 ISO 8859-1 和 Windows-1252，在中国是 GB2312、GBK、GB18030 和 Big5，我们逐个介绍这些编码。</p></li><li><p><strong>ISO 8859-1</strong></p><p>ISO 8859-1 又称 Latin-1，它也是使用一个字节表示一个字符，其中 0 ~ 127 与 ASCII 一样，128 ~ 255 规定了不同的含义。在 128 ~ 255 中，128 ~ 159 表示一些控制字符，这些字符也不常用，就不介绍了。160 ~ 255 表示一些西欧字符，如图2-2 所示。</p><img src="/assets/图2-2.6886e781.png" alt="图2-2" style="zoom:50%;"></li><li><p><strong>Windows-1252</strong></p><p>ISO 8859-1 虽然号称是标准，用于西欧国家，但它连欧元（€）这个符号都没有，因为欧元比较晚，而标准比较早。实际中使用更为广泛的是 Windows-1252 编码，这个编码与 ISO 8859-1 基本是一样的，区别只在于数字 128 ~ 159。Windows-1252 使用其中的一些数字表示可打印字符，这些数字表示的含义如图2-3 所示。</p><img src="/assets/图2-3.dff7dbad.png" alt="图2-3" style="zoom:50%;"><p>这个编码中加入了欧元符号以及一些其他常用的字符。基本上可以认为，ISO 8859-1 已被 Windows-1252 取代，在很多应用程序中，即使文件声明它采用的是 ISO 8859-1 编码，解析的时候依然被当作 Windows-1252 编码。</p><p>HTML5 甚至明确规定，如果文件声明的是 ISO 8859-1 编码，它应该被看作 Win-dows-1252 编码。为什么要这样呢？因为大部分人搞不清楚 ISO 8859-1 和 Windows-1252 的区别，当他说 ISO 8859-1 的时候，其实他指的是 Windows-1252，所以标准干脆就这么强制规定了。</p></li><li><p><strong>GB2312</strong></p><p>美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是 GB2312。GB2312 标准主要针对的是简体中文常见字符，包括约 700。个汉字和一些罕用词和繁体字。</p><p>GB2312 固定使用两个字节表示汉字，在这两个字节中，最高位都是 1，如果是 0，就认为是 ASCII 字符。在这两个字节中，其中高位字节范围是 0xA1 ~ 0xF7，低位字节范围是0 xA1 ~ 0xFE。</p><p>比如，“老马” 的 GB2312 编码（十六进制表示）如表2-5 所示。</p><table style="text-align:center;"><tr><th>老</th><th>马</th></tr><tr><td>C0 CF</td><td>C2 ED</td></tr></table><div> 表2-5 GB2312 编码示例 </div></li><li><p><strong>GBK</strong></p><p>GBK 建立在 GB2312 的基础上，向下兼容 GB2312，也就是说，GB2312 编码的字符和二进制表示，在 GBK 编码里是完全一样的。GBK 增加了 14000 多个汉字，共计约 21000 个汉字，其中包括繁体字。</p><p>GBK 同样使用固定的两个字节表示，其中高位字节范围是 0x81 ~ 0xFE，低位字节范围是 0x40 ~ 0x7E 和 0x80 ~ 0xFE。</p><p>需要注意的是，低位字节是从 0x40（也就是 64）开始的，也就是说，低位字节的最高位可能为 0。那怎么知道它是汉字的一部分，还是一个 ASCII 字符呢？其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为 1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。</p></li><li><p><strong>GB18030</strong></p><p>GB18030 向下兼容 GBK，增加了 55000 多个字符，共 76000 多个字符，包括了很多少数民族字符，以及中日韩统一字符。</p><p>用两个字节已经表示不了 GB18030 中的所有字符，GB18030 使用变长编码，有的字符是两个字节，有的是四个字节。在两字节编码中，字节表示范围与 GBK 一样。在四字节编码中，第一个字节的值为 0x81 ~ 0xFE，第二个字节的值为 0x30 ~ 0x39，第三个字节的值为 0x81 ~ 0xFE，第四个字节的值为 0x30 ~ 0x39。</p><p>解析二进制时，如何知道是两个字节还是 4 个字节表示一个字符呢？看第二个字节的范围，如果是 0x30 ~ 0x39 就是 4 个字节表示，因为两个字节编码中第二个字节都比这个大。</p></li><li><p><strong>Big5</strong></p><p>Big5 是针对繁体中文的，广泛用于我国台湾地区和我国香港特别行政区等地。Big5 包括 13000 多个繁体字，和 GB2312 类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是 0x81 ~ 0xFE，低位字节范围是 0x40 ~ 0x7E 和 0xA1 ~ 0xFE。</p></li><li><p><strong>编码汇总</strong></p><p>我们简单汇总一下前面的内容。</p><p>ASCII 码是基础，使用一个字节表示，最高位设为 0，其他 7 位表示 128 个字符。其他编码都是兼容 ASCII 的，最高位使用 1 来进行区分。</p><p>西欧主要使用 Windows-1252，使用一个字节，增加了额外 128 个字符。</p><p>我国内地的三个主要编码 GB2312、GBK、GB18030 有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312 和 GBK 都是用两个字节表示，而 GB18030 则使用两个或四个字节表示。</p><p>我国香港特别行政区和我国台湾地区的主要编码是 Big5。</p><p>如果文本里的字符都是 ASCII 码字符，那么采用以上所说的任一编码方式都是一样的。</p><p>但如果有高位为 1 的字符，除了 GB2312、GBK、GB18030 外，其他编码都是不兼容的。比如，Windows-1252 和中文的各种编码是不兼容的，即使 Big5 和 GB18030 都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码，具体我们稍后介绍。</p></li></ol><h3 id="_2-3-2-unicode-编码" tabindex="-1"><a class="header-anchor" href="#_2-3-2-unicode-编码" aria-hidden="true">#</a> 2.3.2 Unicode 编码</h3><p>以上我们介绍了中文和西欧的字符与编码，但世界上还有很多其他国家的字符，每个国家的各种计算机厂商都对自己常用的字符进行编码，在编码的时候基本忽略了其他国家的字符和编码，甚至忽略了同一国家的其他计算机厂商，这样造成的结果就是，出现了太多的编码，且互相不兼容。</p><p>世界上所有的字符能不能统一编码呢？可以，这就是 Unicode。</p><p>Unicode 做了一件事，就是给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 ~ 0x10FFFF，包括 110 多万。但大部分常用字符都在 0x0000 ~ 0xFFFF 之间，即 65536 个数字之内。每个字符都有一个 Unicode 编号，这个编号一般写成十六进制，在前面加 U+。大部分中文的编号范围为 U+4E00 ~ U+9FFF，例如，“马” 的 Unicode 是 U+9A6C。</p><p>简单理解，Unicode 主要做了这么一件事，就是给所有字符分配了唯一数字编号。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都既规定了能表示哪些字符，又规定了每个字符对应的二进制是什么，而 Unicode 本身只规定了每个字符的数字编号是多少。</p><p>那编号怎么对应到二进制表示呢？有多种方案，主要有 UTF-32、UTF-16 和 UTF-8。</p><ol><li><p><strong>UTF-32</strong></p><p>这个最简单，就是字符编号的整数二进制形式，4 个字节。</p><p>但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫 “大端”（Big Endian, BE），否则，就叫 “小端”（Little Endian, LE）。对应的编码方式分别是 UTF-32BE 和 UTF-32LE。</p><p>可以看出，每个字符都用 4 个字节表示，非常浪费空间，实际采用的也比较少。</p></li><li><p><strong>UTF-16</strong></p><p>UTF-16 使用变长字节表示：</p><p>1）对于编号在 U+0000 ~ U+FFFF 的字符（常用字符集），直接用两个字节表示。需要说明的是，U+D800 ~ U+DBFF 的编号其实是没有定义的。</p><p>2）字符值在 U+10000 ~ U+10FFFF 的字符（也叫做增补字符集），需要用 4 个字节表示。前两个字节叫高代理项，范围是 U+D800 ~ U+DBFF；后两个字节叫低代理项，范围是 U+DC00 ~ U+DFFF。数字编号和这个二进制表示之间有一个转换算法，本书就不介绍了。</p><p>区分是两个字节还是 4 个字节表示一个字符就看前两个字节的编号范围，如果是 U+D800 ~ U+DBFF，就是 4 个字节，否则就是两个字节。</p><p>UTF-16 也有和 UTF-32 一样的字节序问题，如果高位存放在前面就叫大端（BE），编码就叫 UTF-16BE，否则就叫小端，编码就叫UTF-16LE。</p><p>UTF-16 常用于系统内部编码，UTF-16 比 UTF-32 节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费的。</p></li><li><p><strong>UTF-8</strong></p><p>UTF-8 使用变长字节表示，每个字符使用的字节个数与其 Unicode 编号的大小有关，编号小的使用的节就少，编号大的使用的字节就多，使用的字节个数为1 ~ 4 不等。</p><p>具体来说，各个 Unicode 编号范围对应的二进制格式如表2-6 所示。</p><table style="text-align:center;"><tr><th>编号范围</th><th>二进制格式</th></tr><tr><td>0x00 ~ 0x7F（0 ~ 127）</td><td>0xxxxxxx</td></tr><tr><td>0x80 ~ 0x7FF（128 ~ 2047）</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x800 ~ 0xFFFF（2048 ~ 65535）</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x10000 ~ 0x10FFFF（65536 以上）</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></table><div> 表2-6 UTF-8 编码的编号范围与对应的二进制格式 </div><p>表 2-6 中的 x 表示可以用的二进制位，而每个字节开头的 1 或。是固定的。</p><p>小于 128 的，编码与 ASCII 码一样，最高位为 0。其他编号的第一个字节有特殊含义，最高位有几个连续的 1 就表示用几个字节表示，而其他字节都以 10 开头。</p><p>对于一个 Unicode 编号，具体怎么编码呢？首先将其看作整数，转化为二进制形式（去掉高位的 0），然后将二进制位从右向左依次填入对应的二进制格式 x 中，填完后，如果对应的二进制格式还有没填的 x，则设为 0。</p><p>我们来看个例子，“马” 的 Unicode 编号是 0x9A6C，整数编号是 39532，其对应的 UTF-8 二进制格式是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1110</span>xxxx <span class="token number">10</span>xxxxxx <span class="token number">10</span>xxxxxx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>整数编号 39532 的二进制格式是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1001</span> <span class="token number">101001</span> <span class="token number">101100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将这个二进制位从右到左依次填入二进制格式中，结果就是其 UTF-8 编码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">11101001</span> <span class="token number">10101001</span> <span class="token number">10101100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>十六进制表示为 0xE9A9AC。</p><p>和 UTF-32 / UTF-16 不同，UTF-8 是兼容 ASCII 的，对大部分中文而言，一个中文字符需要用三个字节表示。</p></li><li><p><strong>Unicode 编码小结</strong></p><p>Unicode 给世界上所有字符都规定了一个统一的编号，编号范围达到 110 多万，但大部分字符都在 65536 以内。Unicode 本身没有规定怎么把这个编号对应到二进制形式。</p><p>UTF-32 / UTF-16 / UTF-8 都在做一件事，就是把 Unicode 编号对应到二进制形式，其对应方法不同而已。UTF-32 使用 4 个字节，UTF-16 大部分是两个字节，少部分是 4 个字节，它们都不兼容 ASCII 编码，都有字节顺序的问题。UTF-8 使用 1 ~ 4 个字节表示，兼容 ASCII 编码，英文字符使用 1 个字节，中文字符大多用 3 个字节。</p></li></ol><h3 id="_2-3-3-编码转换" tabindex="-1"><a class="header-anchor" href="#_2-3-3-编码转换" aria-hidden="true">#</a> 2.3.3 编码转换</h3><p>有了 Unicode 之后，每一个字符就有了多种不兼容的编码方式，比如说 “马” 这个字符，它的各种编码方式对应的十六进制如表2-7 所示。</p><table style="text-align:center;"><tr><th>编码方式</th><th>十六进制编码</th></tr><tr><td>GB18030</td><td>C2 ED</td></tr><tr><td>Unicode 编号</td><td>9A 6C</td></tr><tr><td>UTF-8</td><td>E9 A9 AC</td></tr><tr><td>UTF-16LE</td><td>6C 9A</td></tr></table><div> 表2-7 字符 “马” 多种编码方式 </div><p>这几种格式之间可以借助 Unicode 编号进行编码转换。可以认为：每种编码都有一个映射表，存储其特有的字符编码和 Unicode 编号之间的对应关系，这个映射表是一个简化的说法，实际上可能是一个映射或转换方法。</p><p>编码转换的具体过程可以是：一个字符从 A 编码转到 B 编码，先找到字符的 A 编码格式，通过 A 的映射表找到其 Unicode 编号，然后通过 Unicode 编号再查 B 的映射表，找到字符的 B 编码格式。</p><p>举例来说，“马” 从 GB18030 转到 UTF-8，先查 GB18030 -&gt; Unicode 编号表，得到其编号是 9A 6C，然后查 Unicode 编号 -&gt; UTF-8 表，得到其 UTF-8 编码：E9 A9 AC。</p><p>编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子。</p><h3 id="_2-3-4-乱码的原因" tabindex="-1"><a class="header-anchor" href="#_2-3-4-乱码的原因" aria-hidden="true">#</a> 2.3.4 乱码的原因</h3><p>理解了编码，我们来看乱码。乱码有两种常见原因：一种比较简单，就是简单的解析错误；另外一种比较复杂，在错误解析的基础上进行了编码转换。我们分别介绍。</p><ol><li><p><strong>解析错误</strong></p><p>看个简单的例子。一个法国人采用 Windows-1252 编码写了个文件，发送给了一个中国人，中国人使用 GB18030 来解析这个字符，看到的可能就是乱码。比如，法国人发送的是 Pékin，Windows-1252 的二进制（采用十六进制）是 50 E9 6B 69 6E，第二个字节 E9 对应，其他都是 ASCII é 码，中国人收到的也是这个二进制，但是他把它看成了 GB18030 编码，GB18030 中 E9 6B 对应的是字符 “閗”，于是他看到的就是 “P閗in”，这看来就是一个乱码。</p><p>反之也是一样的，一个 GB18030 编码的文件如果被看作 Windows-1252 也是乱码。</p><p>这种情况下，之所以看起来是乱码，是因为看待或者说解析数据的方式错了。只要使用正确的编码方式进行解读就可以纠正了。很多文件编辑器，如 EditPlus、NotePad++、UltraEdit 都有切换查看编码方式的功能，浏览器也都有切换查看编码方式的功能，如 Firefox，在菜单 “查看” 一 “文字编码” 中即可找到该功能。</p><p>切换查看编码的方式并没有改变数据的二进制本身，而只是改变了解析数据的方式，从而改变了数据看起来的样子，这与前面提到的编码转换正好相反。很多时候，做这样一个编码查看方式的切换就可以解决乱码的问题，但有的时候这样是不够的。</p></li><li><p><strong>错误的解析和编码转换</strong></p><p>如果怎么改变查看方式都不对，那很有可能就不仅仅是解析二进制的方式不对，而是文本在错误解析的基础上还进行了编码转换。我们举个例子来说明：</p><p>1）两个字 “老马”，本来的编码格式是 GB18030，编码（十六进制）是 C0 CF C2 ED。</p><p>2）这个二进制形式被错误当成了 Windows-1252 编码，解读成了字符 “ÀÏÂí”。</p><p>3）随后这个字符进行了编码转换，转换成了 UTF-8 编码，形式还是 “ÀÏÂí”，但二进制变成了 C3 80 C3 8F C3 82 C3 AD，每个字符两个字节。</p><p>4）这个时候再按照 GB18030 解析，字符就变成了乱码形式 “脌脧脗铆”，而且这时无论怎么切换查看编码的方式，这个二进制看起来都是乱码。</p><p>这种情况是乱码产生的主要原因。</p><p>这种情况其实很常见，计算机程序为了便于统一处理，经常会将所有编码转换为一种方式，比如 UTF-8，在转换的时候，需要知道原来的编码是什么，但可能会搞错，而一旦搞错并进行了转换，就会出现这种乱码。这种情况下，无论怎么切换查看编码方式都是不行的，如表2-8 所示。</p><table style="text-align:center;"><tr><th>编码方式</th><th>结果</th></tr><tr><td>十六进制</td><td>C3 80 C3 8F C3 82 C3 AD</td></tr><tr><td>UTF-8</td><td>ÀÏÂí</td></tr><tr><td>Windows-1252</td><td>Ã€Ã�Ã‚Ã­</td></tr><tr><td>GB18030</td><td>脌脧脗铆</td></tr><tr><td>Big5</td><td>���穩</td></tr></table><div> 表 2-8 用不同编码方式查看错误转换后的二进制 </div><p>虽然有这么多形式，但我们看到的乱码形式很可能是 “ÀÏÂí”，因为在例子中 UTF-8 是编码转换的目标编码格式，既然转换为了 UTF-8，一般也是要按 UTF-8 查看。</p><p>那有没有办法恢复呢？如果有，怎么恢复呢?</p></li></ol><h3 id="_2-3-5-从乱码中恢复" tabindex="-1"><a class="header-anchor" href="#_2-3-5-从乱码中恢复" aria-hidden="true">#</a> 2.3.5 从乱码中恢复</h3><p>“乱” 主要是因为发生了一次错误的编码转换，所谓恢复，是指要恢复两个关键信息：一个是原来的二进制编码方式 A；另一个是错误解读的编码方式 B。</p><p>恢复的基本思路是尝试进行逆向操作，假定按一种编码转换方式 B 获取乱码的二进制格式，然后再假定一种编码解读方式 A 解读这个二进制，查看其看上去的形式，这要尝试多种编码，如果能找到看着正常的字符形式，应该就可以恢复。</p><p>这听上去可能比较抽象，我们举个例子来说明，假定乱码形式是 “ÀÏÂí”，尝试多种 B 和 A 来看字符形式。我们先使用编辑器，以 UltraEdit 为例，然后使用 Java 编程来看。</p><ol><li><p>使用 UltraEdit</p><p>UltraEdit 支持编码转换和切换查看编码方式，也支持文件的二进制显示和编辑，所以我们以 UltraEdit 为例，其他一些编辑器可能也有类似功能。</p><p>新建一个 UTF-8 编码的文件，复制 “ÀÏÂí” 到文件中。使用编码转换，转换到 Windows-1252 编码，执行 “文件” -&gt; “转换到” -&gt; “西欧” -&gt; WIN-1252 命令。</p><p>转换完后，打开十六进制编辑，查看其二进制形式，如图2-4 所示。</p><img src="/assets/图2-4.5dfecdea.png" alt="图2-4" style="zoom:50%;"><p>可以看出，其形式还是 “ÀÏÂí“ 但二进制格式变成了 C0 CF C2 ED。这个过程相当于假设 B 是 Windows-1252。这个时候，再按照多种编码格式查看这个二进制，在 UltraEdit 中，关闭十六进制编辑，切换查看编码方式为 GB18030，执行 “视图” -&gt; “查看方式（文件编码）” -&gt; “东亚语言” -&gt; GB18030 命令，切换完后，同样的二进制神奇地变为了正确的字符形式 “老马”，打开十六进制编辑器，可以看出二进制还是 C0 CF C2 ED，这个 GB18030 相当于假设 A 是 GB18030。</p><p>这个例子我们碰巧第一次就猜对了。实际中，可能要做多次尝试，过程是类似的，先进行编码转换（使用 B 编码），然后使用不同编码方式查看（使用 A 编码），如果能找到看上去对的形式，就恢复了。表2-9 列出了主要的 B 编码格式、对应的二进制，以及按 A 编码解读的各种形式。</p><table style="text-align:center;"><tr><th>B 编码（获取二进制）</th><th>ÀÏÂí 的二进制（B 编码）</th><th>A 编码（解读二进制）</th><th>结果形式</th></tr><tr><td>Windows-1252</td><td>C0 CF C2 ED</td><td>GB18030</td><td>老马</td></tr><tr><td>Windows-1252</td><td>C0 CF C2 ED</td><td>GB18030</td><td>老马</td></tr><tr><td>Windows-1252</td><td>C0 CF C2 ED</td><td>Big5</td><td>橾鎮</td></tr><tr><td>Windows-1252</td><td>C0 CF C2 ED</td><td>UTF-8</td><td>����</td></tr><tr><td>GB18030</td><td>81 30 86 38 81 30 88 33 81 30 87 30 A8 AA</td><td>Windows-1252</td><td>�0†8�0ˆ3�0‡0¨ª</td></tr><tr><td>GB18030</td><td>81 30 86 38 81 30 88 33 81 30 87 30 A8 AA</td><td>Big5</td><td>�0�8�0�3�0�0赤</td></tr><tr><td>GB18030</td><td>81 30 86 38 81 30 88 33 81 30 87 30 A8 AA</td><td>UTF-8</td><td>�0�8�0�3�0�0��</td></tr><tr><td>Big5</td><td>3F 3F 3F 3F</td><td>Windows-1252</td><td>????</td></tr><tr><td>Big5</td><td>3F 3F 3F 3F</td><td>GB18030</td><td>????</td></tr><tr><td>Big5</td><td>81 30 86 38 81 30 88 33 81 30 87 30 A8 AA</td><td>UTF-8</td><td>????</td></tr><tr><td>UTF-8</td><td>C3 80 C3 8F C3 82 C3 AD</td><td>Windows-1252</td><td>Ã€Ã�Ã‚Ã­</td></tr><tr><td>UTF-8</td><td>C3 80 C3 8F C3 82 C3 AD</td><td>GB18030</td><td>���穩</td></tr><tr><td>UTF-8</td><td>C3 80 C3 8F C3 82 C3 AD</td><td>Big5</td><td>脌脧脗铆</td></tr></table><div> 表2-9 尝试不同编码方式进行恢复 </div><p>可以看出，第一行是正确的，也就是说原来的编码其实是 A 即 GB18030，但被错误解读成了 B 即 Windows-1252 了。</p></li><li><p>使用 Java</p><p>下面我们来看如何使用 Java 恢复乱码。关于使用 Java 我们还有很多知识没有介绍，为了完整性起见，本节一并列出相关代码，初学者不明白的可以暂时略过。Java 中处理字符串的类有 String，String 中有我们需要的两个重要方法。</p><p>1）public byte[] getBytes(String charsetName)，这个方法可以获取一个字符串的给定编码格式的二进制形式。</p><p>2）public String(byte bytes[], String charsetName)，这个构造方法以给定的二进制数组 bytes 按照编码格式 charsetName 解读为一个字符串。</p><p>将 A 看作 GB18030，将 B 看作 Windows-1252，进行恢复的 Java 代码如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;ÀÏÂí&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> newStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;windows-1252&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;GB18030&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先按照 B 编码（Windows-1252——获取字符串的二进制，然后按 A 编码（GB18030）解读这个二进制，得到一个新的字符串，然后输出这个字符串的形式，输出为 “老马”。</p><p>同样，一次碰巧就对了，实际中，我们可以写一个循环，测试不同的 A / B 编码中的结果形式，如代码清单2-1 所示。</p><p>代码清单2-1 恢复乱码的方法</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnsupportedEncodingException</span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charsets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;windows-1252&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GB18030&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Big5&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> charsets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> charsets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>charsets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> charsets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;原来编码 (A) 假设是：&quot;</span><span class="token operator">+</span> charsets<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                           <span class="token operator">+</span> <span class="token string">&quot;，被错误解读为了 (B): &quot;</span><span class="token operator">+</span> charsets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码使用不同的编码格式进行测试，如果输出有正确的，那么就可以恢复。</p><p>可以看出，恢复的尝试需要进行很多次，上面例子尝试了常见编码 GB18030、Windows 1252、Big5、UTF-8 共 12 种组合。这 4 种编码是常见编码，在大部分实际应用中应该够了。如果有其他编码，可以增加一些尝试。</p><p>不是所有的乱码形式都是可以恢复的，如果形式中有很多不能识别的字符（如 ?），则很难恢复。另外，如果乱码是由于进行了多次解析和转换错误造成的，也很难恢复。</p></li></ol><h2 id="_2-4-char-的真正含义" tabindex="-1"><a class="header-anchor" href="#_2-4-char-的真正含义" aria-hidden="true">#</a> 2.4 char 的真正含义</h2><p>通过前面小节，我们应该对字符和文本的编码和乱码有了一个清晰的认识，但前面小节基本是与编程语言无关的，我们还是不知道怎么在程序中处理字符和文本。本节讨论在 Java 中进行字符处理的基础 char，Java 中还有 Character、String、StringBuilder 等类用于文本处理，它们的基础都是 char，我们在第 7 章再介绍这些类。</p><p>char 看上去是很简单的，正如我们在 1.2 节所说，char 用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> z <span class="token operator">=</span> <span class="token char">&#39;马&#39;</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但为什么字符类型也可以进行算术运算和比较呢？它的本质到底是什么呢？</p><p>在 Java 内部进行字符处理时，采用的都是 Unicode，具体编码格式是 UTF-16BE。简单回顾一下，UTF-16 使用两个或 4 个字节表示一个字符，Unicode 编号范围在 65536 以内的占两个字节，超出范围的占 4 个字节，BE 就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的。</p><p>char 本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于 Unicode 编号，用于表示那个 Unicode 编号对应的字符。由于固定占用两个字节，char 只能表示 Unicode 编号在 65536 以内的字符，而不能表示超出范围的字符。那超出范围的字符怎么表示呢？使用两个 char。类 Character、String 有一些相关的方法，我们到第 7 章再介绍。</p><p>在这个认识的基础上，我们再来看下 char 的一些行为。</p><p>char 有多种赋值方式：</p><ol><li><p>char c = &#39;A&#39;;</p></li><li><p>char c = &#39;马&#39;;</p></li><li><p>char c = 39532;</p></li><li><p>char c = 0x9a6c;</p></li><li><p>char c = &#39;\u9a6c&#39;;</p></li></ol><p>第 1 种赋值方式是最常见的，将一个能用 ASCII 码表示的字符赋给一个字符变量。第 2 种赋值方式也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如，GBK 编码的代码文件按 UTF-8 打开，字符会变成乱码，赋值的时候是按当前的编码解读方式，将这个字符形式对应的 Unicode 编号值赋给变量，“马” 对应的 Unicode 编号是 39532，所以第 2 种赋值方式和第 3 种赋值方式是一样的。第 3 种赋值方式是直接将十进制的常量赋给字符。第 4 种赋值方式是将十六进制常量赋给字符，第 5 种赋值方式是按 Unicode 字符形式。所以，第 2、3、4、5 种赋值方式都是一样的，本质都是将 Unicode 编号 39532 赋给了字符。</p><p>由于 char 本质上是一个整数，所以可以进行整数能做的一些运算，在进行运算时会被看作 int，但由于 char 占两个字节，运算结果不能直接赋值给 char 类型，需要进行强制类型转换，这和 byte、short 参与整数运算是类似的。char 类型的比较就是其 Unicode 编号的比较。</p><p>char 的加减运算就是按其 Unicode 编号进行运算，一般对字符做加减运算没什么意义，但 ASCII 码字符是有意义的。比如大小写转换，大写 A ~ Z 的编号是 65 ~ 90，小写 a ~ z 的编号是 97 ~ 122，正好相差 32，所以大写转小写只需加 32，而小写转大写只需减 32。加减运算的另一个应用是加密和解密，将字符进行某种可逆的数学运算可以做加解密。</p><p>char 的位运算可以看作是对应整数的位运算，只是它是无符号数，也就是说，有符号右移 &gt;&gt; 和无符号右移 &gt;&gt;&gt; 的结果是一样的。既然char 本质上是整数，查看 char 的二进制表示，同样可以用 Integer 的方法，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;马&#39;</span>；
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1001101001101100</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>至此，关于整数、小数以及字符的二进制表示就介绍完了，下一章让我们一起来探索类的世界。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Java编程的逻辑/第2章 理解数据背后的二进制.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/16 下午7:56:17</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html" class="nav-link prev" aria-label="第 1 章 编程基础"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第 1 章 编程基础</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
