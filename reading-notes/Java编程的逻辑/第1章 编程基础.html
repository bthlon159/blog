<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 1 章 编程基础"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-08-06T09:11:40.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-08-06T09:11:40.000Z"><title>第 1 章 编程基础 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link active" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">Java 编程的逻辑</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><!----><span class="title">第一部分 编程基础与二进制</span><!----></p><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 1 章 编程基础"><!---->第 1 章 编程基础<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-1-数据类型和变量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 数据类型和变量"><!---->1.1 数据类型和变量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-赋值" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 赋值"><!---->1.2 赋值<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-1-基本类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.1 基本类型"><!---->1.2.1 基本类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-2-数组类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.2 数组类型"><!---->1.2.2 数组类型<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-基本运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 基本运算"><!---->1.3 基本运算<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-1-算术运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.1 算术运算"><!---->1.3.1 算术运算<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-2-比较运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.2 比较运算"><!---->1.3.2 比较运算<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-3-逻辑运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.3 逻辑运算"><!---->1.3.3 逻辑运算<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-4-小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.4 小结"><!---->1.3.4 小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-条件执行" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 条件执行"><!---->1.4 条件执行<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-1-语法和陷阱" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.1 语法和陷阱"><!---->1.4.1 语法和陷阱<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-2-实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.2 实现原理"><!---->1.4.2 实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-循环" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 循环"><!---->1.5 循环<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-1-循环的-4-种形式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.1 循环的 4 种形式"><!---->1.5.1 循环的 4 种形式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-2-循环控制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.2 循环控制"><!---->1.5.2 循环控制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-3-实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.3 实现原理"><!---->1.5.3 实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-4-小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.4 小结"><!---->1.5.4 小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-函数的用法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6 函数的用法"><!---->1.6 函数的用法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-1-基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.1 基本概念"><!---->1.6.1 基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-2-进一步理解函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.2 进一步理解函数"><!---->1.6.2 进一步理解函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-3-小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.6.3 小结"><!---->1.6.3 小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-函数调用的基本原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7 函数调用的基本原理"><!---->1.7 函数调用的基本原理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-1-栈的概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7.1 栈的概念"><!---->1.7.1 栈的概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-2-函数执行的基本原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7.2 函数执行的基本原理"><!---->1.7.2 函数执行的基本原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-3-数组和对象的内存分配" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7.3 数组和对象的内存分配"><!---->1.7.3 数组和对象的内存分配<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-4-递归调用的原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7.4 递归调用的原理"><!---->1.7.4 递归调用的原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-5-小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.7.5 小结"><!---->1.7.5 小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 理解数据背后的二进制"><!---->第 2 章 理解数据背后的二进制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第二部分 面向对象</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC3%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 类的基础"><!---->第 3 章 类的基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC4%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 类的继承"><!---->第 4 章 类的继承<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 类的继承"><!---->第 5 章 类的继承<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC6%E7%AB%A0%20%E5%BC%82%E5%B8%B8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 异常"><!---->第 6 章 异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC7%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 常用基础类"><!---->第 7 章 常用基础类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第三部分 泛型与容器</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC8%E7%AB%A0%20%E6%B3%9B%E5%9E%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 泛型"><!---->第 8 章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC9%E7%AB%A0%20%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 列表和队列"><!---->第 9 章 列表和队列<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC10%E7%AB%A0%20Map%E5%92%8CSet.html" class="nav-link sidebar-link sidebar-page" aria-label="第 10 章 Map 和 Set"><!---->第 10 章 Map 和 Set<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC11%E7%AB%A0%20%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%97%E8%A1%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 11 章 堆与优先级列表"><!---->第 11 章 堆与优先级列表<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC12%E7%AB%A0%20%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E6%80%BB%E7%BB%93.html" class="nav-link sidebar-link sidebar-page" aria-label="第 12 章 通用容器和总结"><!---->第 12 章 通用容器和总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第四部分 文件</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC13%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 13 章 文件基本技术"><!---->第 13 章 文件基本技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC14%E7%AB%A0%20%E6%96%87%E4%BB%B6%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF.html" class="nav-link sidebar-link sidebar-page" aria-label="第 14 章 文件高级技术"><!---->第 14 章 文件高级技术<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第五部分 并发</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC15%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 15 章 并发基础知识"><!---->第 15 章 并发基础知识<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC16%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E5%9F%BA%E7%9F%B3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 16 章 并发包的基石"><!---->第 16 章 并发包的基石<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC17%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html" class="nav-link sidebar-link sidebar-page" aria-label="第 17 章 并发容器"><!---->第 17 章 并发容器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC18%E7%AB%A0%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1.html" class="nav-link sidebar-link sidebar-page" aria-label="第 18 章 异步任务执行服务"><!---->第 18 章 异步任务执行服务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC19%E7%AB%A0%20%E5%90%8C%E6%AD%A5%E5%92%8C%E5%8D%8F%E4%BD%9C%E5%B7%A5%E5%85%B7%E7%B1%BB.html" class="nav-link sidebar-link sidebar-page" aria-label="第 19 章 同步和协作工具类"><!---->第 19 章 同步和协作工具类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC20%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93.html" class="nav-link sidebar-link sidebar-page" aria-label="第 20 章 并发总结"><!---->第 20 章 并发总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">第六部分 动态与函数编程</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC21%E7%AB%A0%20%E5%8F%8D%E5%B0%84.html" class="nav-link sidebar-link sidebar-page" aria-label="第 21 章 反射"><!---->第 21 章 反射<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC22%E7%AB%A0%20%E6%B3%A8%E8%A7%A3.html" class="nav-link sidebar-link sidebar-page" aria-label="第 22 章 注解"><!---->第 22 章 注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC23%E7%AB%A0%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html" class="nav-link sidebar-link sidebar-page" aria-label="第 23 章 动态代理"><!---->第 23 章 动态代理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC24%E7%AB%A0%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link sidebar-link sidebar-page" aria-label="第 24 章 类加载机制"><!---->第 24 章 类加载机制<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC25%E7%AB%A0%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 25 章 正则表达式"><!---->第 25 章 正则表达式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC26%E7%AB%A0%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" class="nav-link sidebar-link sidebar-page" aria-label="第 26 章 函数式编程"><!---->第 26 章 函数式编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 1 章 编程基础</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年6月19日</span><meta property="datePublished" content="2022-06-19T14:33:42.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 60 分钟</span><meta property="timeRequired" content="PT60M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年6月19日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 17986 字</span><meta property="wordCount" content="17986"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-1-数据类型和变量" class="router-link-active router-link-exact-active toc-link level2">1.1 数据类型和变量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-赋值" class="router-link-active router-link-exact-active toc-link level2">1.2 赋值</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-1-基本类型" class="router-link-active router-link-exact-active toc-link level3">1.2.1 基本类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-2-2-数组类型" class="router-link-active router-link-exact-active toc-link level3">1.2.2 数组类型</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-基本运算" class="router-link-active router-link-exact-active toc-link level2">1.3 基本运算</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-1-算术运算" class="router-link-active router-link-exact-active toc-link level3">1.3.1 算术运算</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-2-比较运算" class="router-link-active router-link-exact-active toc-link level3">1.3.2 比较运算</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-3-逻辑运算" class="router-link-active router-link-exact-active toc-link level3">1.3.3 逻辑运算</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-3-4-小结" class="router-link-active router-link-exact-active toc-link level3">1.3.4 小结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-条件执行" class="router-link-active router-link-exact-active toc-link level2">1.4 条件执行</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-1-语法和陷阱" class="router-link-active router-link-exact-active toc-link level3">1.4.1 语法和陷阱</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-4-2-实现原理" class="router-link-active router-link-exact-active toc-link level3">1.4.2 实现原理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-循环" class="router-link-active router-link-exact-active toc-link level2">1.5 循环</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-1-循环的-4-种形式" class="router-link-active router-link-exact-active toc-link level3">1.5.1 循环的 4 种形式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-2-循环控制" class="router-link-active router-link-exact-active toc-link level3">1.5.2 循环控制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-3-实现原理" class="router-link-active router-link-exact-active toc-link level3">1.5.3 实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-5-4-小结" class="router-link-active router-link-exact-active toc-link level3">1.5.4 小结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-函数的用法" class="router-link-active router-link-exact-active toc-link level2">1.6 函数的用法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-1-基本概念" class="router-link-active router-link-exact-active toc-link level3">1.6.1 基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-2-进一步理解函数" class="router-link-active router-link-exact-active toc-link level3">1.6.2 进一步理解函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-6-3-小结" class="router-link-active router-link-exact-active toc-link level3">1.6.3 小结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-函数调用的基本原理" class="router-link-active router-link-exact-active toc-link level2">1.7 函数调用的基本原理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-1-栈的概念" class="router-link-active router-link-exact-active toc-link level3">1.7.1 栈的概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-2-函数执行的基本原理" class="router-link-active router-link-exact-active toc-link level3">1.7.2 函数执行的基本原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-3-数组和对象的内存分配" class="router-link-active router-link-exact-active toc-link level3">1.7.3 数组和对象的内存分配</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-4-递归调用的原理" class="router-link-active router-link-exact-active toc-link level3">1.7.4 递归调用的原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC1%E7%AB%A0%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html#_1-7-5-小结" class="router-link-active router-link-exact-active toc-link level3">1.7.5 小结</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-1-章-编程基础" tabindex="-1"><a class="header-anchor" href="#第-1-章-编程基础" aria-hidden="true">#</a> 第 1 章 编程基础</h1><p>我们先来简单介绍何谓编程，以及编出来的程序大概是什么样子。</p><p>计算机是个机器，这个机器主要由 CPU、内存、硬盘和输入/输出设备组成。计算机上跑着操作系统，如 Windows 或 Linux，操作系统上运行着各种应用程序，如 Word、QQ 等。</p><p>操作系统将时间分成很多细小的时间片，一个时间片给一个程序用，另一个时间片给另一个程序用，并频繁地在程序间切换。不过，在应用程序看来，整个机器资源好像都归它使用，操作系统给它制造了这种假象。对程序员而言，编写程序时基本不用考虑其他应用程序，做好自己的事就可以了。</p><p>应用程序看上去能做很多事情，能读写文档、能播放音乐、能聊天、能玩游戏、能下围棋等，但本质上，计算机只会执行预先写好的指令而已，这些指令也只是操作数据或者设备。所谓程序，基本上就是告诉计算机要操作的数据和执行的指令序列，即对什么数据做什么操作，比如：</p><ol><li>读文档，就是将数据从磁盘加载到内存，然后输出到显示器上；</li><li>写文档，就是将数据从内存写回磁盘；</li><li>播放音乐，就是将音乐的数据加载到内存，然后写到声卡上；</li><li>聊天，就是从键盘接收聊天数据，放到内存，然后传给网卡，通过网络传给另一个人的网卡，再从网卡传到内存，显示在显示器上。</li></ol><p>基本上，所有数据都需要放到内存进行处理，程序的很大一部分工作就是操作在内存中的数据。那具体如何表示和操作数据呢？本章介绍一些基础知识，具体分为 7 个小节。</p><p>数据在计算机内部都是二进制表示的，不方便操作，为了方便操作数据，高级语言引入了数据类型和变量的概念，这两个概念我们在 1.1 节介绍。</p><p>表示了数据后，1.2 节介绍能对数据进行的第一个操作：赋值。</p><p>数据有了初始值之后，1.3 节介绍可以对数据进行的一些基本运算，计算机之所以称为“计算”机，是因为最初发明它的主要目的也是运算。</p><p>为了编写有实用功能的程序，只进行基本运算是远远不够的，至少需要对操作的过程进行流程控制。流程控制有两种：一种是条件执行；另外一种是循环。我们分别在 1.4 节和 1.5 节介绍。</p><p>为了减少重复代码和分解复杂操作，计算机程序引入了函数和子程序的概念，我们分别在 1.6 节和 1.7 节介绍函数的用法和函数调用的基本原理。</p><h2 id="_1-1-数据类型和变量" tabindex="-1"><a class="header-anchor" href="#_1-1-数据类型和变量" aria-hidden="true">#</a> 1.1 数据类型和变量</h2><p>数据类型用于对数据归类，以便于理解和操作。对 Java 语言而言，有如下基本数据类型。</p><ul><li>整数类型：有 4 种整型 byte/short/int/long，分别有不同的取值范围；</li><li>小数类型：有两种类型 float/double，有不同的取值范围和精度；</li><li>字符类型：char，表示单个字符；</li><li>真假类型：boolean，表示真假。</li></ul><p>基本数据类型都有对应的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中连续存放。比如，一个自然数可以用一个整数类型数据表示，100 个连续的自然数可以用一个长度为 100 的整数数组表示。一个字符可以用一个 char 类型数据表示，一段文字可以用一个 char 数组表示。</p><p>Java 是面向对象的语言，除了基本数据类型，其他都是对象类型。对象到底是什么呢？简单地说，对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。比如，一个学生对象，可以由如下信息组成。</p><ul><li>姓名：一个字符数组；</li><li>年龄：一个整数；</li><li>性别：一个字符；</li><li>入学分数：一个小数。</li></ul><p>日期在 Java 中也是一个对象，内部表示为整型 long。</p><p>世界万物都是由元素周期表中的基本元素组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世界万物。</p><p>为了操作数据，需要把数据存放到内存中。所谓内存在程序看来就是一块有地址编号的连续的空间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过变量这个概念来表示这个过程。</p><p>声明一个变量，比如 int a，其实就是在内存中分配了一块空间，这块空间存放 int 数据类型，a 指向这块内存空间所在的位置，通过对 a 操作即可操作 a 指向的内存空间，比如 a = 5 这个操作即可将 a 指向的内存空间的值改为 5。</p><p>之所以叫“变”量，是因为它表示的是内存中的位置，这个位置存放的值是可以变化的。</p><p>虽然变量的值是可以变化的，但变量的名字是不变的，这个名字应该代表程序员心目中这块内存空间的意义，这个意义应该是不变的。比如，变量 int second 表示时钟秒数，在不同时间可以被赋予不同的值，但它表示的始终是时钟秒数。之所以说应该，是因为这不是必需的，如果一定要为一个名为 age 的变量赋予身高的值，计算机也拿你没办法。</p><p>重要的话再说一遍！变量就是给数据起名字，方便找不同的数据，它的值可以变，但含义不应变。再比如说一个合同，可以有 4 个变量：</p><ul><li>first_party：含义是甲方；</li><li>second_party：含义是乙方；</li><li>contract_body：含义是合同内容；</li><li>contract_sign_date：含义是合同签署日期。</li></ul><p>这些变量表示的含义是确定的，但对不同的合同，它们的值是不同的。初学编程的人经常使用像 a、b、c、hehe、haha 这种无意义的名字。在此建议为变量起一个有意义的名字吧！通过声明变量，每个变量赋予一个数据类型和一个有意义的名字，我们就告诉了计算机要操作的数据。</p><p>有了数据，如何对数据进行操作呢？我们先来看对数据能做的第一个操作：赋值。</p><h2 id="_1-2-赋值" tabindex="-1"><a class="header-anchor" href="#_1-2-赋值" aria-hidden="true">#</a> 1.2 赋值</h2><p>声明变量之后，就在内存分配了一块位置，但这个位置的内容是未知的，赋值就是把这块位置的内容设为一个确定的值。Java 中基本类型、数组、对象的赋值有明显不同，本节介绍基本类型和数组的赋值，对象的赋值第 3 章再介绍。</p><h3 id="_1-2-1-基本类型" tabindex="-1"><a class="header-anchor" href="#_1-2-1-基本类型" aria-hidden="true">#</a> 1.2.1 基本类型</h3><p>（1）整数类型</p><p>整数类型有 byte、short、int 和 long，分别占 1、2、4、8 个字节，取值范围如表1-1 所示。</p><table style="text-align:center;"><tr><th>类型名</th><th>取值范围</th></tr><tr><td>byte</td><td>-2<sup>7</sup> ~ 2<sup>7</sup>-1</td></tr><tr><td>short</td><td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td></tr><tr><td>int</td><td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td></tr><tr><td>long</td><td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td></tr></table><div> 表1-1 整数类型和取值范围 </div><p>我们用 ^ 表示指数，2^7 即 2 的 7 次方。这个范围我们不需要记得那么清楚，有个大概范围认识就可以了。第 2 章会从二进制的角度进一步分析表示范围为什么会是这样的。</p><p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。但常量不能超过对应类型的表示范围。例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">3333</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9999</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">32323</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，在给 long 类型赋值时，如果常量超过了 int 的表示范围，需要在常量后面加大写或小写字母 L，即 L 或 l，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">3232343433L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>之所以需要加 L 或 l，是因为数字常量默认为是 int 类型。</p><p>（2）小数类型</p><p>小数类型有 float 和 double，占用的内存空间分别是 4 和 8 字节，有不同的取值范围和精度，double 表示的范围更大，精度更高，具体如表1-2 所示。</p><table style="text-align:center;"><tr><th>类型名</th><th>取值范围</th></tr><tr><td>float</td><td> 1.4E-45 ~ 3.4E+38 <br> -3.4E+38 ~ -1.4E-45 </td></tr><tr><td>double</td><td> 4.9E-324 ~ 1.7E+308 <br> -1.7E+308 ~ -4.9E-324 </td></tr><tr><td>int</td><td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td></tr><tr><td>long</td><td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td></tr></table><div> 表1-2 小数类型和取值范围 </div><p>取值范围看上去很奇怪，一般也不需要记住，有个大概印象就可以了。E 表示以 10 为底的指数，E 后面的 + 号和 - 号代表正指数和负指数，例如：1.4E-45 表示 1.4 乘以10 的 -45 次方。第 2 章会进一步分析小数的二进制表示。</p><p>对于 double，直接把熟悉的小数表示赋值给变量即可，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">333.33</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但对于 float，需要在数字后面加大写字母 F 或小写字母 f，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">333.33f</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是由于小数常量默认是 double 类型。</p><p>除了小数，也可以把整数直接赋值给 float 或 double，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3333333333333L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）真假类型</p><p>真假（boolean）类型很简单，直接使用 true 或 false 赋值，分别表示真和假，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）字符类型</p><p>字符类型 char 用于表示一个字符，这个字符可以是中文字符，也可以是英文字符，char 占用的内存空间是两个字节。赋值时把常量字符用单引号括起来，不要使用双引号，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> z <span class="token operator">=</span> <span class="token char">&#39;马&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大部分的常用字符用一个 char 就可以表示，但有的特殊字符用一个 char 表示不了。此外，关于 char 还有一些其他细节，我们在 2.4 节再进一步解释。</p><p>前面介绍的赋值都是直接给变量设置一个常量值，但也可以把变量赋给变量，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变量可以进行各种运算（1.3 节介绍），也可以将变量的运算结果赋给变量，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 2 乘以 a 的值再加上 b 的值赋给 c</span>
<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面介绍的赋值都是在声明变量的时候就进行了赋值，但这不是必需的，可以先声明变量，随后再进行赋值。</p><h3 id="_1-2-2-数组类型" tabindex="-1"><a class="header-anchor" href="#_1-2-2-数组类型" aria-hidden="true">#</a> 1.2.2 数组类型</h3><p>基本类型的数组有 3 种赋值形式，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 第 1 种</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 第 2 种</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 第 3 种</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> 
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> 
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第 1 种和第 2 种都是预先知道数组的内容，而第 3 种是先分配长度，然后再给每个元素赋值。第 3 种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关，数值类型的值为 0，boolean 为 false，char 为空字符。</p><p>数组长度可以动态确定，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//根据一些条件动态计算 </span>
<span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组长度虽然可以动态确定，但定了之后就不可以变。数组有一个 length 属性，但只能读，不能改。还有一个小细节，不能在给定初始值的同时给定长度，即如下格式是不允许的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以这么理解，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p><p>数组类型和基本类型是有明显不同的，一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个 int 变量 a，以及一个 int 数组变量 arr，其代码、变量对应的内存地址和内存内容如表1-3 所示。</p><table style="text-align:center;"><tr><th>代码</th><th>内存地址</th><th>内存数据</th></tr><tr><td>int a = 100;</td><td>1000</td><td>100</td></tr><tr><td rowspan="9">int[] arr = {1, 2, 3}</td><td>2000</td><td>3000</td></tr><tr><td>3000</td><td>1</td></tr><tr><td>3004</td><td>2</td></tr><tr><td>3008</td><td>3</td></tr></table><div> 表1-3 变量对应的内存地址和内容 </div><p>基本类型 a 的内存地址是 1000，这个位置存储的就是它的值 100。数组类型 arr 的内存地址是 2000，这个位置存储的值是一个位置 3000，3000 开始的位置存储的才是实际的数据 &quot;1, 2, 3&quot;。</p><p>为什么数组要用两块空间？不能只用一块空间吗？我们来看下面这段代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrB <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
arrA <span class="token operator">=</span> arrB<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码中，arrA 初始的长度是 3，arrB 的长度是 4，后来将 arrB 的值赋给了 arrA。如果 arrA 对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳 arrB 的所有元素。</p><p>用两块空间存储就简单得多，arrA 存储的值就变成了和 arrB 的一样，存储的都是数组内容 {4, 5, 6, 7} 的地址，此后访问 arrA 就和 arrB 是一样的了，而 arrA {1, 2, 3} 的内存空间由于不再被引用会进行垃圾回收，如下所示：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>arrA       {1, 2, 3}
     \
      \
arrB   -&gt;  {4, 5, 6, 7}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由上也可以看出，给数组变量赋值和给数组中元素赋值是两回事，给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p><p>上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中 arrA 后来指向了 arrB 一样。</p><p>给变量赋值就是将变量对应的内存空间设置为一个明确的值，有了值之后，变量可以被加载到 CPU，CPU 可以对这些值进行各种运算，运算后的结果又可以被赋值给变量，保存到内存中。数据可以进行哪些运算？如何进行运算呢？我们下节介绍。</p><h2 id="_1-3-基本运算" tabindex="-1"><a class="header-anchor" href="#_1-3-基本运算" aria-hidden="true">#</a> 1.3 基本运算</h2><p>有了初始值之后，可以对数据进行运算。运算有不同的类型，不同的数据类型支持的运算也不一样，本节介绍 Java 中基本类型数据的主要运算。</p><ul><li>算术运算：主要是日常的加减乘除。</li><li>比较运算：主要是日常的大小比较。</li><li>逻辑运算：针对布尔值进行运算。</li></ul><h3 id="_1-3-1-算术运算" tabindex="-1"><a class="header-anchor" href="#_1-3-1-算术运算" aria-hidden="true">#</a> 1.3.1 算术运算</h3><p>算术运算符有加、减、乘、除，符号分别是 +、-、*、/，另外还有取模运算符 ％，以及自增（++）和自减（--）运算符。取模运算适用于整数和字符类型，其他算术运算适用于所有数值类型和字符类型。大部分运算都符合我们的数学常识，但字符怎么也可以进行算术运算？我们到 2.4 节再解释。</p><p>减号（-）通常用于两个数相减，但也可以放在一个数前面，例如 -a，这表示改变 a 的符号，原来的正数会变为负数，原来的负数会变为正数，这也是符合我们常识的。</p><p>取模（％）就是数学中的求余数，例如，5 % 3 是 2，10 % 5 是 0。</p><p>自增（++）和自减（--），是一种快捷方式，是对自己进行加 1 或减 1 操作。</p><p>加、减、乘、除大部分情况和数学运算是一样的，都很容易理解，但有一些需要注意的地方，而自增、自减稍微复杂一些，下面我们解释下。</p><ol><li><p><strong>加、减、乘、除注意事项</strong></p><p>运算时要注意结果的范围，使用恰当的数据类型。两个正数都可以用 int 表示，但相乘的结果可能就会超出，超出后结果会令人困惑，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//2147483647是 int 能表示的最大值</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2147483647</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>a 的结果是 -2。为什么是 -2 我们暂不解释，要避免这种情况，我们的结果类型应使用 long，但只改为 long 也是不够的，因为运算还是默认按照 int 类型进行，需要将至少一个数据表示为 long 形式，即在后面加 L 或 l，下面这样才会出现期望的结果：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> a <span class="token operator">=</span> <span class="token number">2147483647</span> <span class="token operator">*</span> <span class="token number">2L</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外，需要注意的是，整数相除不是四舍五入，而是直接舍去小数位，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果是 2 而不是 2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转化，即在数字前面加（double），表示将数字看作 double 类型，如下所示任意一种形式都可以：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 第 1 种</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">4.0</span><span class="token punctuation">;</span>
<span class="token comment">// 第 2 种</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>小数计算结果不精确</strong></p><p>无论是使用 float 还是 double，进行运算时都会出现一些非常令人困惑的现象，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">0.1f</span> <span class="token operator">*</span> <span class="token number">0.1f</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结果看上去应该是 0.01，但实际上，屏幕输出却是 0.010000001，后面多了个 1。换用 double 看看：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>屏幕输出 0.010000000000000002，一连串的。之后多了个 2，结果也不精确。</p><p>这是怎么回事？看上去这么简单的运算，计算机计算的结果怎么不精确呢？但事实就是这样，究其原因，我们需要理解 float 和 double 的二进制表示，我们到 2.2 节再进行分析。</p></li><li><p><strong>自增（++）/ 自减（--）</strong></p><p>自增 / 自减是对自己做加 1 或减 1 操作，但每个都有两种形式，一种是放在变量后，例如 a++、a--，另一种是放在变量前，例如++a、--a。</p><p>如果只是对自己操作，这两种形式也没什么差别，区别在于还有其他操作的时候。放在变量后（a++）是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前（++a）是先对自己做修改，再用修改后的值进行其他操作。例如，快捷运算和其等同的运算如表1-4 所示。</p><table style="text-align:center;"><tr><th>快捷运算</th><th>等同运算</th></tr><tr><td>b = a++ - 1</td><td> b = a - 1 <br> a = a + 1 </td></tr><tr><td>c = ++a - 1</td><td> a = a + 1 <br> c = a - 1 </td></tr><tr><td>arrA[i++] = arrB[++j]</td><td> j = j + 1 <br> arrA[i] = arrB[j] <br> i = i + 1 </td></tr></table><div> 表1-4 快捷运算和其等同的运算 </div><p>自增/自减是“快捷”操作，是让程序员少写代码的，但遗憾的是，由于比较奇怪的语法和诡异的行为，给初学者带来了一些困惑。</p></li></ol><h3 id="_1-3-2-比较运算" tabindex="-1"><a class="header-anchor" href="#_1-3-2-比较运算" aria-hidden="true">#</a> 1.3.2 比较运算</h3><p>比较运算就是计算两个值之间的关系，结果是一个布尔类型（boolean）的值。比较运算适用于所有数值类型和字符类型。数值类型容易理解，但字符怎么比呢？我们到 2.4 节再解释。</p><p>比较操作符有大于（&gt;）、大于等于（&gt;=）、小于（&lt;）、小于等于（＜=）、等于（==）、不等于（!=）。</p><p>大部分也都是比较直观的，需要注意的是等于。首先，它使用两个等号 ==，而不是一个等号 =。为什么不用一个等号呢？因为一个等号 = 已经被占了，表示赋值操作。另外，对于数组，== 判断的是两个变量指向的是不是同一个数组，而不是两个数组的元素内容是否一样，即使两个数组的内容是一样的，但如果是两个不同的数组，== 依然会返回 false，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// a == b 的结果是 false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要比较数组的内容是否一样，需要逐个比较里面存储的每个元素。</p><h3 id="_1-3-3-逻辑运算" tabindex="-1"><a class="header-anchor" href="#_1-3-3-逻辑运算" aria-hidden="true">#</a> 1.3.3 逻辑运算</h3><p>逻辑运算根据数据的逻辑关系，生成一个布尔值 true 或者 false。逻辑运算只可应用于 boolean 类型的数据，但比较运算的结果是布尔值，所以其他类型数据的比较结果可进行逻辑运算。</p><p>逻辑运算符具体有以下这些。</p><ul><li>与（&amp;）：两个都为 true 才是 true，只要有一个是 false 就是 false；</li><li>或（|）：只要有一个为 true 就是 true，都是 false 才是 false；</li><li>非（！）：针对一个变量，true 会变成 false，false 会变成 true；</li><li>异或（^）：两个相同为 false，两个不相同为 true；</li><li>•短路与（&amp;&amp;）：和 &amp; 类似，不同之处稍后解释；</li><li>•短路或（||）：与 | 类似，不同之处稍后解释。</li></ul><p>逻辑运算的大部分都是比较直观的，需要注意的是 &amp; 和 &amp;&amp;，以及 | 和 || 的区别。如果只是进行逻辑运算，它们也都是相同的，区别在于同时有其他操作的情况下，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> flag <span class="token operator">=</span> a <span class="token operator">|</span> b<span class="token operator">++</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 a 为 true，所以 flag 也为 true，但 b 的结果为1，因为 | 后面的式子也会进行运算，即使只看 a 已经知道 flag 的结果，还是会进行后面的运算。而 || 则不同，如果最后一句的代码是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> flag <span class="token operator">=</span> a <span class="token operator">||</span> b<span class="token operator">++</span> <span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>则 b 的值还是0，因为 || 会 “短路”，即在看到 || 前面部分就可以判定结果的情况下，忽略 || 后面的运算。</p><h3 id="_1-3-4-小结" tabindex="-1"><a class="header-anchor" href="#_1-3-4-小结" aria-hidden="true">#</a> 1.3.4 小结</h3><p>本节介绍了 Java 中基本类型数据的主要运算，包括算术运算、比较运算和逻辑运算。</p><p>一个稍微复杂的运算可能会涉及多个变量和多种运算，那哪个先算，哪个后算呢？程序语言规定了不同运算符的优先级，有的会先算，有的会后算，大部分情况下，这个优先级与我们的常识理解是相符的。但在一些复杂情况下，我们可能会搞不明白其运算顺序。但这个我们不用太操心，可以使用括号 () 来表达我们想要的顺序，括号里的会先进行运算。简单来说，不确定顺序的时候，就使用括号。</p><p>本节遗留了一些问题，比如：</p><ul><li>正整数相乘的结果居然出现了负数；</li><li>非常基本的小数运算结果居然不精确；</li><li>字符类型也可以进行算术运算和比较。</li></ul><h2 id="_1-4-条件执行" tabindex="-1"><a class="header-anchor" href="#_1-4-条件执行" aria-hidden="true">#</a> 1.4 条件执行</h2><p>流程控制中最基本的就是条件执行，也就是说，一些操作只能在某些条件满足的情况下才执行，在一些条件下执行某种操作，在另外一些条件下执行另外的操作。这与交通控制中的红灯停、绿灯行条件执行是类似的。我们先来看 Java 中表达条件执行的语法，然后介绍其实现原理。</p><h3 id="_1-4-1-语法和陷阱" tabindex="-1"><a class="header-anchor" href="#_1-4-1-语法和陷阱" aria-hidden="true">#</a> 1.4.1 语法和陷阱</h3><p>Java 中表达条件执行的基本语法是 if 语句，它的语法是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>条件语句<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  代码块
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>条件语句<span class="token punctuation">)</span> 代码<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表达的含义也非常简单，只在条件语句为真的情况下，才执行后面的代码，为假就不执行了。具体来说，条件语句必须为布尔值，可以是一个直接的布尔变量，也可以是变量运算后的结果。我们在 1.3 节介绍过，比较运算和逻辑运算的结果都是布尔值，所以可作为条件语句。条件语句为 true，则执行括号。中的代码，如果后面没有括号，则执行后面第一个分号（；）前的代码。</p><p>比如，只在变量为偶数的情况下输出：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> 
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>if 的陷阱：初学者有时会忘记在 if 后面的代码块中加括号，有时希望执行多条语句而没有加括号，结果只会执行第一条语句，建议所有 if 后面都加括号。</p><p>if 实现的是条件满足的时候做什么操作，如果需要根据条件做分支，即满足的时候执行某种逻辑，而不满足的时候执行另一种逻辑，则可以用 if / else，语法是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>判断条件<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	代码块<span class="token number">1</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
  代码块<span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>if / else 也非常简单，判断条件是一个布尔值，为 true 的时候执行代码块1，为假的时候执行代码块2。</p><p>1.3 节介绍了各种基本运算，这里介绍一个条件运算，和 if / else 很像，叫三元运算符，语法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>判断条件 <span class="token operator">?</span> 表达式<span class="token number">1</span> <span class="token operator">:</span> 表达式<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>三元运算符会得到一个结果，判断条件为真的时候就返回表达式1 的值，否则就返回表达式2 的值。三元运算符经常用于对某个变量赋值，例如求两个数的最大值：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> max <span class="token operator">=</span> x <span class="token operator">&gt;</span> y <span class="token operator">?</span> x <span class="token operator">:</span> y<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>三元运算符完全可以用 if / else 代替，但三元运算符的书写方式更简洁。</p><p>如果有多个判断条件，而且需要根据这些判断条件的组合执行某些操作，则可以使用 if / else if / else，语法是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>条件<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  代码块<span class="token number">1</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>条件<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  代码块<span class="token number">2</span>
<span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>条件n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  代码块n
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  代码块n<span class="token operator">+</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>if / else if / else 也比较简单，但可以表达复杂的条件执行逻辑，它逐个检查条件，条件 1 满足则执行代码块 1，不满足则检查条件 2，...，最后如果没有条件满足，且有 else 语句，则执行 else 里面的代码。最后的 else 语句不是必需的，没有就什么都不执行。</p><p>if / else if / else 陷阱：需要注意的是，在 if / else if / else 中，判断的顺序是很重要的，后面的判断只有在前面的条件为 false 的时候才会执行。</p><p>初学者有时会搞错这个顺序，如下面的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">&gt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token string">&quot;及格&quot;</span>；
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">&gt;</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;良好&quot;</span>；
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;优秀&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看出问题了吧？如果 score 是 90，可能期望返回 “优秀”，但实际只会返回 “及格”。</p><p>在 if / else if / else 中，如果判断的条件基于的是同一个变量，只是根据变量值的不同而有不同的分支，如果值比较多，比如根据星期几进行判断，有 7 种可能性，或者根据英文字母进行判断，有 26 种可能性，使用 if / else if / else 比较烦琐，这种情况可以使用 switch，语法是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> 值<span class="token number">1</span><span class="token operator">:</span>
    代码<span class="token number">1</span><span class="token punctuation">;</span> 
    <span class="token keyword">break</span><span class="token punctuation">;</span> 
  <span class="token keyword">case</span> 值<span class="token number">2</span><span class="token operator">:</span>
    代码<span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> 值n<span class="token operator">:</span>
    代码n<span class="token punctuation">;</span> 
    <span class="token keyword">break</span><span class="token punctuation">;</span> 
  <span class="token keyword">default</span><span class="token operator">:</span>
    代码n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>switch 也比较简单，根据表达式的值执行不同的分支，具体来说，根据表达式的值找匹配的 case，找到后执行后面的代码，碰到 break 时结束，如果没有找到匹配的值则执行 default 后的语句。表达式值的数据类型只能是 byte、short、int、char、枚举和 String（Java 7 以后）。枚举和 String 我们在后续章节介绍。</p><p>switch 会简化一些代码的编写，但 break 和 case 语法会给初学者造成一些困惑。</p><p>break 是指跳出 switch 语句，执行 switch 后面的语句。每条 case 语句后面都应该跟 break 语句，否则会继续执行后面 case 中的代码直到碰到 break 语句或 switch 结束。比如，下面的代码会输出所有数字而不只是 1。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case 语句后面可以没有要执行的代码，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 某字符</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;A&#39;</span><span class="token punctuation">;</span>  
<span class="token keyword">switch</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token char">&#39;A&#39;</span><span class="token operator">:</span>
  <span class="token keyword">case</span> <span class="token char">&#39;B&#39;</span><span class="token operator">:</span>
  <span class="token keyword">case</span> <span class="token char">&#39;C&#39;</span><span class="token operator">:</span> 
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A-Z&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> <span class="token char">&#39;D&#39;</span><span class="token operator">:</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case &#39;A&#39; / &#39;B&#39; 后都没有紧跟要执行的代码，它们实际会执行第一块碰到的代码，即 case &#39;C&#39; 匹配的代码。</p><p>简单总结下，条件执行总体上是比较简单的：单一条件满足时，执行某操作使用 if；根据一个条件是否满足执行不同分支使用 if / else；表达复杂的条件使用 if / else if / else；条件赋值使用三元运算符，根据某一个表达式的值不同执行不同的分支使用 switch。</p><p>从逻辑上讲，if / else、if / else if / else、三元运算符、switch 都可以只用 if 代替，但使用不同的语法表达更简洁，在条件比较多的时候，switch 从性能上看也更高（稍后解释原因）。</p><h3 id="_1-4-2-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-4-2-实现原理" aria-hidden="true">#</a> 1.4.2 实现原理</h3><p>条件执行具体是怎么实现的呢？程序最终都是一条条的指令，CPU 有一个指令指示器，指向下一条要执行的指令，CPU 根据指示器的指示加载指令并且执行。指令大部分是具体的操作和运算，在执行这些操作时，执行完一个操作后，指令指示器会自动指向挨着的下一条指令。</p><p>但有一些特殊的指令，称为跳转指令，这些指令会修改指令指示器的值，让 CPU 跳到一个指定的地方执行。跳转有两种：一种是条件跳转；另一种是无条件跳转。条件跳转检查某个条件，满足则进行跳转，无条件跳转则是直接进行跳转。</p><p>if / else 实际上会转换为这些跳转指令，比如下面的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token number">2</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token number">3</span> <span class="token punctuation">{</span>

<span class="token number">4</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">5</span> <span class="token punctuation">}</span>

<span class="token number">6</span> <span class="token comment">// 其他代码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换到的转移指令可能是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token number">2</span> 条件跳转：如果 a <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span>，跳转到第<span class="token number">4</span>行

<span class="token number">3</span> 无条件跳转：跳转到第 <span class="token number">7</span> 行

<span class="token number">4</span> <span class="token punctuation">{</span>

<span class="token number">5</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">6</span> <span class="token punctuation">}</span>

<span class="token number">7</span> <span class="token comment">// 其他代码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会奇怪第 3 行的无条件跳转指令，没有它不行吗？不行，没有这条指令，它会顺序执行接下来的指令，导致不管什么条件，括号中的代码都会执行。不过，对应的跳转指令也可能是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span> <span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token number">2</span> 条件跳转：如果 a <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span>，跳转到第 <span class="token number">6</span> 行

<span class="token number">3</span> <span class="token punctuation">{</span>

<span class="token number">4</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;偶数&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">5</span> <span class="token punctuation">}</span>

<span class="token number">6</span> <span class="token comment">// 其他代码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里就没有无条件跳转指令，具体怎么对应和编译器实现有关。在单一 if 的情况下可能不用无条件跳转指令，但稍微复杂一些的情况都需要。if、if / else、if / else if / else。三元运算符都会转换为条件跳转和无条件跳转，但 switch 不太一样。</p><p>switch 的转换和具体系统实现有关。如果分支比较少，可能会转换为跳转指令。如果分支比较多，使用条件跳转会进行很多次的比较运算，效率比较低，可能会使用一种更为高效的方式，叫跳转表。跳转表是一个映射表，存储了可能的值以及要跳转到的地址，如表1-5 所示。</p><table style="text-align:center;"><tr><th>条件值</th><th>跳转地址</th></tr><tr><td>值1</td><td>代码块1 的地址</td></tr><tr><td>值2</td><td>代码块2 的地址</td></tr><tr><td>...</td><td>...</td></tr><tr><td>值n</td><td>代码块n 的地址</td></tr></table><div> 表1-5 跳转表 </div><p>跳转表为什么会更为高效呢？因为其中的值必须为整数，且按大小顺序排序。按大小排序的整数可以使用高效的二分查找，即先与中间的值比，如果小于中间的值，则在开始和中间值之间找，否则在中间值和末尾值之间找，每找一次缩小一半查找范围。如果值是连续的，则跳转表还会进行特殊优化，优化为一个数组，连找都不用找了，值就是数组的下标索引，直接根据值就可以找到跳转的地址。即使值不是连续的，但数字比较密集，差的不多，编译器也可能会优化为一个数组型的跳转表，没有的值指向 default 分支。</p><p>程序源代码中的 case 值排列不要求是排序的，编译器会自动排序。之前说 switch 值的类型可以是 byte、short、int、char、枚举和 String。其中 byte / short / int 本来就是整数，char 本质上也是整数（2.4 节介绍），而枚举类型也有对应的整数（5.4 节介绍），String 用于 switch 时也会转换为整数。不可以使用 long，为什么呢？跳转表值的存储空间一般为 32 位，容纳不下 long。简单说明下 String，String 是通过 hashCode 方法（7.2 节介绍）转换为整数的，但不同 String 的 hashCode 可能相同，跳转后会再次根据 String 的内容进行比较判断。</p><p>简单总结下，条件执行的语法是比较自然和容易理解的，需要注意的是其中的一些语法细节和陷阱。它执行的本质依赖于条件跳转、无条件跳转和跳转表。条件执行中的跳转只会跳转到跳转语句以后的指令，能不能跳转到之前的指令呢？可以，那样就会形成循环。</p><h2 id="_1-5-循环" tabindex="-1"><a class="header-anchor" href="#_1-5-循环" aria-hidden="true">#</a> 1.5 循环</h2><p>所谓循环，就是多次重复执行某些类似的操作，这个操作一般不是完全一样的操作，而是类似的操作。都有哪些操作呢？这种例子太多了，比如：</p><p>1）展示照片，我们查看手机上的照片，背后的程序需要将照片一张张展示给我们。</p><p>2）播放音乐，我们听音乐，背后程序按照播放列表一首首给我们放。</p><p>3）查看消息，我们浏览朋友圈消息，背后程序将消息一条条展示给我们。</p><p>循环除了用于重复读取或展示某个列表中的内容，日常中的很多操作也要靠循环完成，比如：</p><p>1）在文件中，查找某个词，程序需要和文件中的词逐个比较（当然可能有更高效的方式，但也离不开循环）；</p><p>2）使用 Excel 对数据进行汇总，比如求和或平均值，需要循环处理每个单元的数据；</p><p>3）群发祝福消息给好友，程序需要循环给每个好友发。</p><p>当然，以上这些例子只是冰山一角。计算机程序运行时大致只能顺序执行、条件执行和循环执行。顺序和条件其实没什么特别的，而循环大概才是程序强大的地方。凭借循环，计算机能够非常高效地完成人很难或无法完成的事情。比如，在大量文件中查找包含某个搜索词的文档，对几十万条销售数据进行统计汇总等。下面，我们先来介绍循环的 4 种形式，然后介绍循环控制，最后讨论循环的实现原理并进行总结。</p><h3 id="_1-5-1-循环的-4-种形式" tabindex="-1"><a class="header-anchor" href="#_1-5-1-循环的-4-种形式" aria-hidden="true">#</a> 1.5.1 循环的 4 种形式</h3><p>在 Java 中，循环有 4 种形式，分别是 while、do / while、for 和 foreach，下面我们分别介绍。</p><ol><li><p><strong>while</strong></p><p>while 的语法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>条件语句<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  代码块
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>条件语句<span class="token punctuation">)</span>
  代码<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>while 和 if 的语法很像，只是把 if 换成了 while，它表达的含义也非常简单，只要条件语句为真，就一直执行后面的代码，为假就停止不做了。比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Scanner</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;please input password&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> password <span class="token operator">=</span> <span class="token number">6789</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;please input password&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  num <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;correct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，我们使用类型为 Scanner 的 reader 变量从屏幕控制台接收数字，reader.nextInt() 从屏幕接收一个数字，如果数字不是 6789，就一直提示输入，否则跳出循环。以上代码中的 Scanner 我们会在 13.3 节介绍，目前可以忽略其细节。</p><p>while 循环中，代码块中会有影响循环中断或退出的条件，但经常不知道什么时候循环会中断或退出。比如，上例中在匹配的时候会退出，但什么时候能匹配取决于用户的输入。</p></li><li><p><strong>do / while</strong></p><p>如果不管条件语句是什么，代码块都会至少执行一次，则可以使用 do / while 循环，其语法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
  代码块<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>条件语句<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个也很容易理解，先执行代码块，然后再判断条件语句，如果成立，则继续循环，否则退出循环。也就是说，不管条件语句是什么，代码块都会至少执行一次。上面的例子，改为 do / while 循环，代码为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Scanner</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> password <span class="token operator">=</span> <span class="token number">6789</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;please input password&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  num <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;correct&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>for</strong></p><p>实际中应用最为广泛的循环语法可能是 for 了，尤其是在循环次数已知的情况。其语法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>初始化语句<span class="token punctuation">;</span> 循环条件<span class="token punctuation">;</span> 步进操作<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  循环体
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>for 后面的括号中有两个分号 ;，分隔了三条语句。除了循环条件必须返回一个 boolean 类型外，其他语句没有什么要求，但通常情况下第一条语句用于初始化，尤其是循环的索引变量，第三条语句修改循环变量，一般是步进，即递增或递减索引变量，循环体是在循环中执行的语句。</p><p>for 循环简化了书写，但执行过程对初学者而言不是那么明显，实际上，它执行的流程如下：</p><p>1）执行初始化指令；</p><p>2）检查循环条件是否为 true，如果为 false，则跳转到第 6 步；</p><p>3）循环条件为真，执行循环体；</p><p>4）执行步进操作；</p><p>5）步进操作执行完后，跳转到第 2 步，即继续检查循环条件；</p><p>6）for 循环后面的语句。</p><p>下面是一个简单的 for 循环：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺序打印数组中的每个元素，初始化语句初始化索引 i 为 0，循环条件为索引小于数组长度，步进操作为递增索引 i，循环体打印数组元素。</p><p>在 for 中，每条语句都是可以为空的，也就是说：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>是有效的，这是个死循环，一直在空转，和 while(true)。的效果是一样的。可以省略某些语句，但分号 ; 不能省。如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>索引变量在外面初始化了，所以初始化语句可以为空。</p></li><li><p><strong>foreach</strong></p><p>foreach 的语法如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>foreach 不是一个关键字，它使用冒号 :，冒号前面是循环中的每个元素，包括数据类型和变量名称，冒号后面是要遍历的数组或集合（第 9 章介绍），每次循环 element 都会自动更新。对于不需要使用索引变量，只是简单遍历的情况，foreach 语法上更为简洁。</p></li></ol><h3 id="_1-5-2-循环控制" tabindex="-1"><a class="header-anchor" href="#_1-5-2-循环控制" aria-hidden="true">#</a> 1.5.2 循环控制</h3><p>在循环的时候，会以循环条件作为是否结束的依据，但有时可能会需要根据别的条件提前结束循环或跳过一些代码，这时可以使用 break 或 continue 关键字对循环进行控制。</p><ol><li><p><strong>break</strong></p><p>break 用于提前结束循环。比如，在一个数组中查找某个元素的时候，循环条件可能是到数组结束，但如果找到了元素，可能就会想提前结束循环，这时就可以使用 break。</p><p>我们在介绍 switch 的时候提到过 break，它用于跳转到 switch 外面。在循环的循环体中也可以使用 break，它的含义和 switch 中的类似，用于跳出循环，开始执行循环后面的语句。以在数组中查找元素作为例子，代码可能是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//在该数组中查找元素</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token comment">//要查找的元素</span>
<span class="token keyword">int</span> toSearch <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> toSearch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;found&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;not found&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果找到了，会调用 break，break 执行后会跳转到循环外面，不会再执行 i++ 语句，所以即使是最后一个元素匹配，i 也小于 arr.length，而如果没有找到，i 最后会变为 arr.length，所以可根据 i 是否等于 arr.length 来判断是否找到了。以上代码中，也可以将判断是否找到的检查放到循环条件中，但通常情况下，使用 break 会使代码更清楚一些。</p></li><li><p><strong>continue</strong></p><p>在循环的过程中，有的代码可能不需要每次循环都执行，这时候，可以使用 continue 语句，continue 语句会跳过循环体中剩下的代码，然后执行步进操作。我们看个例子，以下代码统计一个数组中某个元素的个数：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 在该数组中查找元素</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token comment">// 要查找的元素</span>
<span class="token keyword">int</span> toSearch <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> toSearch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;found count&quot;</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码统计数组中值等于 toSearch 的元素个数，如果值不等于 toSearch，则跳过剩下的循环代码，执行 i++。以上代码也可以不用 continue，使用相反的 if 判断也可以得到相同的结果。这只是个人偏好的问题，如果类似要跳过的情况比较多，使用 continue 可能会更易读。</p></li></ol><h3 id="_1-5-3-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-5-3-实现原理" aria-hidden="true">#</a> 1.5.3 实现原理</h3><p>和 if 一样，循环内部也是靠条件转移和无条件转移指令实现的，比如下面的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其对应的跳转过程可能为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">2</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token number">3</span> 条件跳转：如果 i <span class="token operator">&gt;=</span> arr<span class="token punctuation">.</span>length，跳转到第 <span class="token number">7</span> 行
<span class="token number">4</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span> i<span class="token operator">++</span>
<span class="token number">6</span> 无条件跳转，跳转到第 <span class="token number">3</span> 行
<span class="token number">7</span> 其他代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 if 中，跳转只会往后面跳，而 for 会往前面跳，第 6 行就是无条件跳转指令，跳转到了前面的第 3 行。break / continue 语句也都会转换为跳转指令，具体就不赘述了。</p><h3 id="_1-5-4-小结" tabindex="-1"><a class="header-anchor" href="#_1-5-4-小结" aria-hidden="true">#</a> 1.5.4 小结</h3><p>循环的语法总体上也是比较简单的，初学者需要注意的是 for 的执行过程，以及 break 和 continue 的含义。虽然循环看起来只是重复执行一些类似的操作而已，但它其实是计算机程序解决问题的一种基本思维方式，凭借循环（当然还有别的），计算机程序可以发挥出强大的威力，比如批量转换数据、查找过滤数据、统计汇总等。</p><p>使用基本数据类型、数组、基本运算，加上条件和循环，其实已经可以写很多程序了，但这样写出来的程序往往难以理解，尤其是程序逻辑比较复杂的时候。</p><p>解决复杂问题的基本策略是分而治之，将复杂问题分解为若干相对简单的子问题，然后子问题再分解为更小的子问题程序由数据和指令组成，大程序可以分解为小程序，小程序接着分解为更小的程序。那如何表示子程序，以及子程序之间如何协调呢？我们下节介绍。</p><h2 id="_1-6-函数的用法" tabindex="-1"><a class="header-anchor" href="#_1-6-函数的用法" aria-hidden="true">#</a> 1.6 函数的用法</h2><p>如果需要经常做某一种操作，则类似的代码需要重复写很多遍。比如在一个数组中查找某个数，第一次查找一个数，第二次可能查找另一个数，每查一个数，类似的代码都需要重写一遍，很啰唆。另外，有一些复杂的操作，可能分为很多个步骤，如果都放在一起，则代码难以理解和维护。</p><p>计算机程序使用函数这个概念来解决这个问题，即使用函数来减少重复代码和分解复杂操作。本节我们就来谈谈 Java 中的函数，包括函数的基本概念和一些细节，下节我们讨论函数的基本实现原理。</p><h3 id="_1-6-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-6-1-基本概念" aria-hidden="true">#</a> 1.6.1 基本概念</h3><p>函数这个概念，我们学数学的时候都接触过，其基本格式是 y = f(x)，表示的是 x 到 y 的对应关系，给定输入 x，经过函数变换 f，输出 y。程序中的函数概念与其类似，也由输入、操作和输出组成，但它表示的是一段子程序，这个子程序有一个名字，表示它的目的（类比 f），有零个或多个参数（类比 x），有可能返回一个结果（类比 y）。我们来看两个简单的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print3Lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个函数的名字叫做 sum，它的目的是对输入的两个数求和，有两个输入参数，分别是 int 整数 a 和 b，它的操作是对两个数求和，求和结果放在变量 sum 中（这个 sum 和函数名字的 sum 没有任何关系），然后使用 return 语句将结果返回，最开始的 public static 是函数的修饰符，我们后续介绍。</p><p>第二个函数的名字叫做 print3Lines，它的目的是在屏幕上输出三个空行，它没有输入参数，操作是使用一个循环输出三个空行，它没有返回值。</p><p>以上代码都比较简单，主要是演示函数的基本语法结构，即：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>修饰符 返回值类型 函数名字<span class="token punctuation">(</span>参数类型 参数名字<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  操作
  <span class="token keyword">return</span> 返回值<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数的主要组成部分有以下几种。</p><ol><li><p>函数名字：名字是不可或缺的，表示函数的功能。</p></li><li><p>参数：参数有 0 个到多个，每个参数由参数的数据类型和参数名字组成。</p></li><li><p>操作：函数的具体操作代码。</p></li><li><p>返回值：函数可以没有返回值，如果没有返回值则类型写成 void，如果有则在函数代码中必须使用 return 语句返回一个值，这个值的类型需要和声明的返回值类型一致。</p></li><li><p>修饰符：Java 中函数有很多修饰符，分别表示不同的目的，本节假定修饰符为 public static，且暂不讨论这些修饰符的目的。</p></li></ol><p>以上就是定义函数的语法。定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p><p>Java 中，任何函数都需要放在一个类中。类还没有介绍，我们暂时可以把类看作函数的一个容器，即函数放在类中，类中包括多个函数，Java 中的函数一般叫做方法，我们不特别区分函数和方法，可能会交替使用。一个类里面可以定义多个函数，类里面可以定义一个叫做 main 的函数，形式如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数有特殊的含义，表示程序的入口，String[] args 表示从控制台接收到的参数，我们暂时可以忽略它。Java 中运行一个程序的时候，需要指定一个定义了 main 函数的类，Java 会寻找 main 函数，并从 main 函数开始执行。</p><p>刚开始学编程的人可能会误以为程序从代码的第一行开始执行，这是错误的，不管 main 函数定义在哪里，Java 函数都会先找到它，然后从它的第一行开始执行。</p><p>main 函数中除了可以定义变量，操作数据，还可以调用其他函数，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">print3Lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用函数需要传递参数并处理返回值。main 函数首先定义了两个变量 a 和 b，接着调用了函数 sum，并将 a 和 b 传递给了 sum 函数，然后将 sum 的结果赋值给了变量 sum。</p><p>这里初学者需要注意的是，参数和返回值的名字是没有特别含义的。调用者 main 中的参数名字 a 和 b，和函数定义 sum 中的参数名字 a 和 b 只是碰巧一样而已，它们完全可以不一样，而且名字之间没有关系，sum 函数中不能使用 main 函数中的名字，反之也一样。调用者 main 中的 sum 变量和 sum 函数中的 sum 变量的名字也是碰巧一样而已，完全可以不一样。另外，变量和函数可以取一样的名字，但一样不代表有特别的含义。</p><p>调用函数如果没有参数要传递，也要加括号 ()，如 print3Lines()。</p><p>传递的参数不一定是个变量，可以是常量，也可以是某个运算表达式，可以是某个函数的返回结果。比如：System.out.println(sum (3, 4));，第一个函数调用 sum (3, 4)，传递的参数是常量 3 和 4，第二个函数调用 System.out.println 传递的参数是 sum(3, 4) 的返回结果。</p><p>关于参数传递，简单总结一下，定义函数时声明参数，实际上就是定义变量，只是这些变量的值是未知的，调用函数时传递参数，实际上就是给函数中的变量赋值。</p><p>函数可以调用同一个类中的其他函数，也可以调用其他类中的函数，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 Integer 类中的 toBinaryString 函数，toBinaryString 是 Integer 类中修饰符为 public static 的函数，表示输出一个整数的二进制表示。</p><p>对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，会使得代码更加易读。</p><p>我们知道，程序执行基本上只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从 main 函数开始执行，碰到函数调用的时候，会跳转进函数内部，函数调用了其他函数，会接着进入其他函数，函数返回后会继续执行调用后面的语句，返回到 main 函数并且 main 函数没有要执行的语句后程序结束。1.7 节会更深入地介绍执行过程细节。在 Java 中，函数在程序代码中的位置和实际执行的顺序是没有关系的。</p><h3 id="_1-6-2-进一步理解函数" tabindex="-1"><a class="header-anchor" href="#_1-6-2-进一步理解函数" aria-hidden="true">#</a> 1.6.2 进一步理解函数</h3><p>函数的定义和基本调用应该是比较容易理解的，但有很多细节可能令初学者困惑，包括参数传递、返回、函数命名、调用过程等，我们逐个介绍。</p><ol><li><p><strong>参数传递</strong></p><p>有两类特殊类型的参数：数组和可变长度的参数。</p><p>(1) 数组</p><p>数组作为参数与基本类型是不一样的，基本类型不会对调用者中的变量造成任何影响，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。我们看个例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
  <span class="token function">reset</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 reset 函数内给参数数组元素赋值，在 main 函数中数组 arr 的值也会变。</p><p>这个其实也容易理解，我们在 1.2 节介绍过，一个数组变量有两块空间，一块用于存储数组内容本身，另一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会让数组变量指向一个不同的数组内容空间。</p><p>在上例中，函数参数中的数组变量 arr 和 main 函数中的数组变量 arr 存储的都是相同的位置，而数组内容本身只有一份数据，所以，在 reset 中修改数组元素内容和在 main 中修改是完全一样的。</p><p>(2) 可变长度的参数</p><p>前面介绍的函数，参数个数都是固定的，但有时候可能希望参数个数不是固定的，比如求若干个数的最大值，可能是两个，也可能是多个。Java 支持可变长度的参数，如下例所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> max <span class="token operator">=</span> min<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>max <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      max <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 max 函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点在函数内，可变长度参数可以看作是数组。可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。</p><p>可变长度参数实际上会转换为数组参数，也就是说，函数声明 max(int min, int... a) 实际上会转换为 max(int min, int[] a)，在 main 函数调用 max(0, 2, 4, 5)的时候，实际上会转换为调用 max(0, new int[]{2, 4, 5})，使用可变长度参数主要是简化了代码书写。</p></li><li><p><strong>理解返回</strong></p><p>对初学者，我们强调下 return 的含义。函数返回值类型为 void 时，return 不是必需的，在没有 return 的情况下，会执行到函数结尾自动返回。return 用于显式结束函数执行，返回调用方。</p><p>return 可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在 if 语句内，可以在 for 循环内，用于提前结束函数执行，返回调用方。</p><p>函数返回值类型为 void 也可以使用 return，即 &quot;return;”，不用带值，含义是返回调用方，只是没有返回值而已。</p><p>函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。</p><p>如果实际情况需要的返回值是一种复合结果呢？比如，查找一个字符数组中所有重复出现的字符以及重复出现的次数。这个可以用对象作为返回值，我们在第 3 章介绍类和对象。虽然返回值最多只能有一个，但其实一个也够了。</p></li><li><p><strong>重复的命名</strong></p><p>每个函数都有一个名字，这个名字表示这个函数的意义，名字可以重复吗？在不同的类里，答案是肯定的，在同一个类里，要看情况。</p><p>同一个类里，函数可以重名，但是参数不能完全一样，即要么参数个数不同，要么参数个数相同但至少有一个参数类型不一样。</p><p>同一个类中函数名相同但参数不同的现象，一般称为函数重载。为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但参数个数或类型不一样。比如，求两个数的最大值，在 Java 的 Math 库中就定义了 4 个函数，如下所示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">long</span> a<span class="token punctuation">,</span> <span class="token keyword">long</span> b<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>调用的匹配过程</strong></p><p>在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？Java 编译器会自动进行类型转换，并寻找最匹配的函数，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token char">&#39;b&#39;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数是字符类型的，但 Math 并没有定义针对字符类型的 max 函数，这是因为 char 其实是一个整数（我们在 2.4 节会说明），Java 会自动将 char 转换为 int，然后调用 Math.max(int a, int b)，屏幕会输出整数结果 98。</p><p>如果 Math 中没有定义针对 int 类型的 max 函数呢？调用也会成功，会调用 long 类型的 max 函数。如果 long 也没有呢？会调用 float 型的 max 函数。如果 float 也没有，会调用 double 型的。Java 编译器会自动寻找最匹配的。</p><p>在只有一个函数的情况下，即没有重载，只要可以进行类型转换，就会调用该函数，在有函数重载的情况下，会调用最匹配的函数。</p></li><li><p><strong>递归函数</strong></p><p>函数大部分情况下都是被别的函数调用的，但其实函数也可以调用它自己，调用自己的函数就叫递归函数。为什么需要自己调用自己呢？我们来看一个例子，求一个数的阶乘，数学中一个数 n 的阶乘，表示为 n!，它的值定义是这样的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">0</span> <span class="token operator">!=</span> <span class="token number">1</span>
n <span class="token operator">!=</span> <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!</span> x n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>0 的阶乘是 1，n 的阶乘的值是 n-1 的阶乘的值乘以 n，这个定义是一个递归的定义，为求 n 的值，需先求 n-1 的值，直到 0，然后依次往回退。用递归表达的计算用递归函数容易实现，代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看上去应该是比较容易理解的，和数学定义类似。递归函数形式上往往比较简单，但递归其实是有开销的，而且使用不当，可能会出现意外的结果，比如说这个调用：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统并不会给出任何结果，而会抛出异常。异常我们在第 6 章介绍，此处理解为系统错误就可以了。异常类型 java.lang.StackOverflowError，这是什么意思呢？这表示栈溢出错误，要理解这个错误，我们需要理解函数调用的实现原理，我们 1.7 节介绍。</p><p>那递归不可行的情况下怎么办呢？递归函数经常可以转换为非递归的形式，通过循环实现。比如，求阶乘的例子，其非递归形式的定义是：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>n <span class="token operator">!=</span> <span class="token number">1</span> x <span class="token number">2</span> x <span class="token number">3</span> x <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> x n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个可以用循环来实现，代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
result<span class="token operator">=</span>result<span class="token operator">*</span>i<span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="_1-6-3-小结" tabindex="-1"><a class="header-anchor" href="#_1-6-3-小结" aria-hidden="true">#</a> 1.6.3 小结</h3><p>函数是计算机程序的一种重要结构，通过函数来减少重复代码、分解复杂操作是计算机程序的一种重要思维方式。本节我们介绍了函数的基础概念，以及关于参数传递、返回值、重载、递归方面的一些细节。</p><p>在 Java 中，函数还有大量的修饰符，如 public、private、static、final、synchronized、abstract 等，本节假定函数的修饰符都是 public static，在后续章节中，我们再介绍这些修饰符。函数中还可以声明异常，我们也到第 6 章再介绍。</p><h2 id="_1-7-函数调用的基本原理" tabindex="-1"><a class="header-anchor" href="#_1-7-函数调用的基本原理" aria-hidden="true">#</a> 1.7 函数调用的基本原理</h2><p>在介绍递归函数的时候，我们看到了一个系统错误：java.lang.StackOveflowError，理解这个错误，需要理解函数调用的实现机制。下面，我们先来了解一个重要的概念：栈，然后再通过一些例子来仔细分析函数调用的过程。</p><h3 id="_1-7-1-栈的概念" tabindex="-1"><a class="header-anchor" href="#_1-7-1-栈的概念" aria-hidden="true">#</a> 1.7.1 栈的概念</h3><p>我们之前谈过程序执行的基本原理：CPU 有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</p><p>基本上，这依然是成立的，程序从 main 函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到 return 语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</p><p>但这里面有几个问题。</p><p>1）参数如何传递？</p><p>2）函数如何知道返回到什么地方？在 if / else、for 中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。</p><p>3）函数结果如何传给调用方？</p><p>解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫栈。</p><p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据称为入栈，最下面的称为栈底，最上面的称为栈顶，从栈顶拿出数据通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最低的。</p><p>计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，以及函数内定义的局部变量。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用 CPU 内的一个存储器存储返回值，我们可以简单认为存在一个专门的返回值存储器。main 函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。</p><h3 id="_1-7-2-函数执行的基本原理" tabindex="-1"><a class="header-anchor" href="#_1-7-2-函数执行的基本原理" aria-hidden="true">#</a> 1.7.2 函数执行的基本原理</h3><p>以上描述可能有点抽象，我们通过一个例子来具体说明函数执行的过程，看个简单例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token number">1</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sum</span> <span class="token punctuation">{</span>
<span class="token number">2</span> 
<span class="token number">3</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">4</span>          <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token number">5</span>          <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token number">6</span>          <span class="token punctuation">}</span>
<span class="token number">7</span> 
<span class="token number">8</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">9</span>          <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token class-name">Sum</span><span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span>     <span class="token punctuation">}</span>
<span class="token number">12</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个简单的例子，main 函数调用了 sum 函数，计算 1 和 2 的和，然后输出计算结果，从概念上，这是容易理解的，让我们从栈的角度来讨论下。</p><p>当程序在 main 函数调用 Sum.sum 之前，栈的情况大概如图1-1 所示。</p><img src="/assets/图1-1.b49a8e6f.png" alt="图1-1" style="zoom:50%;"><p>栈中主要存放了两个变量 args 和 d。在程序执行到 Sum.sum 的函数内部，准备返回之前，即第 5 行，栈的情况大概如图1-2 所示。</p><img src="/assets/图1-2.fbc8e169.png" alt="图1-2" style="zoom:50%;"><p>我们解释下，在 main 函数调用 Sum.sum 时，首先将参数 1 和 2 入栈，然后将返回地址（也就是调用函数结束后要执行的指令地址）入栈，接着跳转到 sum 函数，在 sum 函数内部，需要为局部变量 c 分配一个空间，而参数变量 a 和 b 则直接对应于入栈的数据 1 和 2，在返回之前，返回值保存到了专门的返回值存储器中。</p><p>在调用 return 后，程序会跳转到栈中保存的返回地址，即 main 的下一条指令地址，而 sum 函数相关的数据会出栈，从而又变回图1-1 的样子。</p><p>main 的下一条指令是根据函数返回值给变量 d 赋值，返回值从专门的返回值存储器中获得。</p><p>函数执行的基本原理，简单来说就是这样。但有一些需要介绍的点，我们讨论一下。</p><p>我们在 1.1 节的时候说过，定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。</p><p>从以上关于栈的描述我们可以看出，函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。但这个说法主要针对基本数据类型，接下来我们介绍数组和对象。</p><h3 id="_1-7-3-数组和对象的内存分配" tabindex="-1"><a class="header-anchor" href="#_1-7-3-数组和对象的内存分配" aria-hidden="true">#</a> 1.7.3 数组和对象的内存分配</h3><p>对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续章节会进一步介绍）中，但存放地址的空间是分配在栈上的。我们来看个例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayMax</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">int</span> max <span class="token operator">=</span> min<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        max <span class="token operator">=</span> a<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序也很简单，main 函数新建了一个数组，然后调用函数 max 计算。和数组中元素的最大值，在程序执行到 max 函数的 return 语句之前的时候，内存中栈和堆的情况如图1-3 所示。</p><img src="/assets/图1-3.f039538c.png" alt="图1-3" style="zoom:50%;"><p>对于数组 arr，在栈中存放的是实际内容的地址 0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。</p><p>但说堆空间完全不受影响是不正确的，在这个例子中，当 main 函数执行结束，栈空间没有变量指向它的时候，Java 系统会自动进行垃圾回收，从而释放这块空间。</p><h3 id="_1-7-4-递归调用的原理" tabindex="-1"><a class="header-anchor" href="#_1-7-4-递归调用的原理" aria-hidden="true">#</a> 1.7.4 递归调用的原理</h3><p>我们再通过栈的角度来理解一下递归函数的调用过程，代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span> 
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在factorial 第一次被调用的时候，n 是 4，在执行到 n * factorial(n - 1)，即 4 * factorial(3) 之前的时候，栈的情况大概如图1-4 所示。</p><img src="/assets/图1-4.2298cd8a.png" alt="图1-4" style="zoom:50%;"><p>注意，返回值存储器是没有值的，在调用 factorial(3) 后，栈的情况如图1-5 所示。</p><img src="/assets/图1-5.af244c77.png" alt="图1-5" style="zoom:50%;"><p>栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用到 n 等于 0 的时候，栈的情况如图1-6 所示。</p><img src="/assets/图1-6.28228240.png" alt="图1-6" style="zoom:50%;"><p>这个时候，终于有返回值了，我们将 factorial 简写为 f。f(0) 的返回值为 1；f(0) 返回到 f(1)，f(1) 执行 1 * f(0)，结果也是1；然后返回到 f(2)，f(2) 执行 2 * f(1)，结果是 2；接着返回到 f(3)，f(3) 执行 3 * f(2)，结果是 6；然后返回到 f(4)，执行 4 * f(3)，结果是 24。</p><p>以上就是递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。</p><h3 id="_1-7-5-小结" tabindex="-1"><a class="header-anchor" href="#_1-7-5-小结" aria-hidden="true">#</a> 1.7.5 小结</h3><p>本节介绍了函数调用的基本原理，函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的。</p><p>从函数调用的过程可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易地改为其他方式，应该考虑其他方式。另外，栈的空间不是无限的，一般正常调用都是没有问题的，但如果栈空间过深，系统就会抛出错误 java.lang.StackOverflowError，即栈溢出。</p><p>至此，关于编程的基础知识，包括数据类型和变量、赋值、基本运算、流程控制中的条件执行和循环，以及函数的概念和基本原理，就介绍完了。我们谈到，在 Java 中，函数必须放在类中，目前我们简单认为类只是函数的容器，但类在 Java 中远不止有这个功能，它还承载了很多概念和思维方式，在探讨类的概念之前，在下一章，我们先来进一步理解下各种基本数据类型和文本背后的二进制表示。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/Java编程的逻辑/第1章 编程基础.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/8/6 下午5:11:40</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/%E7%AC%AC2%E7%AB%A0%20%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.html" class="nav-link next" aria-label="第 2 章 理解数据背后的二进制"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 2 章 理解数据背后的二进制<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
