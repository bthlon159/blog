<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.48" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://www.cxlsn.cn/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html"><meta property="og:site_name" content="MyBlog"><meta property="og:title" content="第 1 章 走入并行世界"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-07-28T13:05:06.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-07-28T13:05:06.000Z"><title>第 1 章 走入并行世界 | MyBlog</title><meta name="description" content="MyBlog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.09a441ee.css">
    <link rel="modulepreload" href="/assets/app.0d56c066.js"><link rel="modulepreload" href="/assets/第1章走入并行世界.html.d4a7a8b1.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/第1章走入并行世界.html.bf2758d5.js"><link rel="prefetch" href="/assets/index.html.18f6ed2e.js"><link rel="prefetch" href="/assets/home.html.32fca429.js"><link rel="prefetch" href="/assets/slide.html.a293c482.js"><link rel="prefetch" href="/assets/index.html.bcf51f43.js"><link rel="prefetch" href="/assets/index.html.3768ee5f.js"><link rel="prefetch" href="/assets/index.html.b7a9ea16.js"><link rel="prefetch" href="/assets/第10章 异常.html.33f3792f.js"><link rel="prefetch" href="/assets/第11章 并发.html.41f89aa7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.08c4c0cc.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.1b6f55e3.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.e81922f0.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.bbf64366.js"><link rel="prefetch" href="/assets/第5章 泛型.html.053306ed.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.cb21ea0d.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.664c81b8.js"><link rel="prefetch" href="/assets/第8章 方法.html.bfc52ab1.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.6a1d88a2.js"><link rel="prefetch" href="/assets/index.html.153be5a1.js"><link rel="prefetch" href="/assets/index.html.4b079bc8.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.f4c43a60.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.24971a2d.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.e9963ba8.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.bc309d92.js"><link rel="prefetch" href="/assets/第5章定时器.html.aaf2b6ee.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.a87eb20f.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.2cbb6898.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.1739cc6b.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.186199c8.js"><link rel="prefetch" href="/assets/index.html.62274579.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.afd475cd.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.06be1f5d.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.ab9d71ca.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.c3382339.js"><link rel="prefetch" href="/assets/第5章并发容器.html.ef80cb1d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.e4a6ecca.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.98e49c17.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.f7a413b4.js"><link rel="prefetch" href="/assets/index.html.12f0ee52.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.b977fee1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.623c5cbb.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.3967f815.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.1c7f7072.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.8f28f52d.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.2e32d2f3.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.4b8c96f3.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.57b14c73.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.21d8c694.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.44cbbd21.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.b4fa44fb.js"><link rel="prefetch" href="/assets/index.html.e5d1d6c3.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.a55e5985.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.e280a8e4.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.7f8f71e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.5f4b89df.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.8c6479e2.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.5cb53a4c.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.142bea88.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.3acbf1e5.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.1b161f70.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.addf5980.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.baf9d7d3.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.0b3bb480.js"><link rel="prefetch" href="/assets/第21章 反射.html.af2446cd.js"><link rel="prefetch" href="/assets/第22章 注解.html.d1e27bc4.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.7995d8c2.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.b0642f1c.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.8b5d5322.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.7b517aff.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.94e4cb31.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.5639d229.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2f958e91.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.7d7e56a6.js"><link rel="prefetch" href="/assets/第6章 异常.html.adb3eef3.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.17e1b88d.js"><link rel="prefetch" href="/assets/第8章 泛型.html.9d1aa562.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.1b223279.js"><link rel="prefetch" href="/assets/index.html.213dbe07.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.2d819cce.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.e045243d.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.f2cf1cf0.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.84620d72.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.57e9f10a.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.e1837d6e.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.509db6c5.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.fab16b37.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.8a2e8902.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.ede4146b.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.e7e64f52.js"><link rel="prefetch" href="/assets/index.html.ccabe8d8.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.288ef3a6.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.66974eb6.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.064eea71.js"><link rel="prefetch" href="/assets/第13章显式锁.html.bf44c451.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.23a2e0be.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.06dd6e43.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.977d59cd.js"><link rel="prefetch" href="/assets/第1章简介.html.90b5e48c.js"><link rel="prefetch" href="/assets/第2章线程安全.html.2501a94b.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.faeb65aa.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.1fe1b50c.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.1fe6799b.js"><link rel="prefetch" href="/assets/第6章任务执行.html.70613e72.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1e1c2d49.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.72ef0a90.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.11c377b5.js"><link rel="prefetch" href="/assets/001-two-sum.html.a3f3595a.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.e7703c4f.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.0c6329c6.js"><link rel="prefetch" href="/assets/index.html.d8ad8d07.js"><link rel="prefetch" href="/assets/index.html.5a513471.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.2a6b1789.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.59704c7c.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.deaa5ea6.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.fd873e3a.js"><link rel="prefetch" href="/assets/第1章走近Java.html.0897d78c.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.0978cdd4.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.a47791fa.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.61f80277.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.7a5b7c4c.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.3e8cd2c6.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.3af5a31c.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.dc5c593e.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.c3e2fd28.js"><link rel="prefetch" href="/assets/index.html.c2e9c36e.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.8a27b9a6.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.55a5bb57.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.0ac6ac12.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.6e857f15.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.61173fb4.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.610f0e53.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.dcf9af72.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.1b25b9bb.js"><link rel="prefetch" href="/assets/index.html.8c841845.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.800b1d8e.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.fd59242f.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.80ec8c68.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.bbf499e1.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.10cb1042.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.90d52151.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.98dc8566.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.d9178ab7.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.76f053df.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.c6edc3b8.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.ce3b9ffe.js"><link rel="prefetch" href="/assets/404.html.a61819a1.js"><link rel="prefetch" href="/assets/index.html.196bf7d0.js"><link rel="prefetch" href="/assets/index.html.6474b04a.js"><link rel="prefetch" href="/assets/index.html.12d9ea9f.js"><link rel="prefetch" href="/assets/index.html.8cf1d97b.js"><link rel="prefetch" href="/assets/index.html.b1d72dff.js"><link rel="prefetch" href="/assets/index.html.6a433ed8.js"><link rel="prefetch" href="/assets/index.html.292db8d2.js"><link rel="prefetch" href="/assets/index.html.db46c28d.js"><link rel="prefetch" href="/assets/home.html.b3222fa8.js"><link rel="prefetch" href="/assets/slide.html.3b4fa46d.js"><link rel="prefetch" href="/assets/index.html.eab01647.js"><link rel="prefetch" href="/assets/index.html.f6997ce1.js"><link rel="prefetch" href="/assets/index.html.4f492e58.js"><link rel="prefetch" href="/assets/第10章 异常.html.b369a82a.js"><link rel="prefetch" href="/assets/第11章 并发.html.1e83a7e7.js"><link rel="prefetch" href="/assets/第12章 序列化.html.934b2280.js"><link rel="prefetch" href="/assets/第2章 创建和销毁对象.html.bf39597f.js"><link rel="prefetch" href="/assets/第3章 对于所有对象都通用的方法.html.c2f582c1.js"><link rel="prefetch" href="/assets/第4章 类和接口.html.d616fa92.js"><link rel="prefetch" href="/assets/第5章 泛型.html.fe9bf71e.js"><link rel="prefetch" href="/assets/第6章 枚举和注解.html.b0c192a2.js"><link rel="prefetch" href="/assets/第7章 Lambda和Stream.html.11e132a3.js"><link rel="prefetch" href="/assets/第8章 方法.html.0f5952cd.js"><link rel="prefetch" href="/assets/第9章 通用编程.html.a9158c44.js"><link rel="prefetch" href="/assets/index.html.66d9275e.js"><link rel="prefetch" href="/assets/index.html.e1e195ac.js"><link rel="prefetch" href="/assets/第1章Java多线程技能.html.d201a503.js"><link rel="prefetch" href="/assets/第2章对象及变量的并发访问.html.8eff37f9.js"><link rel="prefetch" href="/assets/第3章线程间通信.html.96ad7aa4.js"><link rel="prefetch" href="/assets/第4章锁的使用.html.0b108a46.js"><link rel="prefetch" href="/assets/第5章定时器.html.079d1655.js"><link rel="prefetch" href="/assets/第6章单例模式与多线程.html.dd40cab9.js"><link rel="prefetch" href="/assets/第7章拾遗增补.html.c98b6afc.js"><link rel="prefetch" href="/assets/第8章并发集合框架.html.c47636a0.js"><link rel="prefetch" href="/assets/第9章线程池ThreadPoolExecutor的使用.html.fdd06e63.js"><link rel="prefetch" href="/assets/index.html.970ebb57.js"><link rel="prefetch" href="/assets/第1章多线程基础.html.f6e06884.js"><link rel="prefetch" href="/assets/第2章Atomic类.html.5c9a96af.js"><link rel="prefetch" href="/assets/第3章Lock与Condition.html.dd94c834.js"><link rel="prefetch" href="/assets/第4章同步工具类.html.f32cb37a.js"><link rel="prefetch" href="/assets/第5章并发容器.html.11ef3b3d.js"><link rel="prefetch" href="/assets/第6章线程池与Future.html.f2664d19.js"><link rel="prefetch" href="/assets/第7章ForkJoinPool.html.5b09c440.js"><link rel="prefetch" href="/assets/第8章CompletableFuture.html.00ddc982.js"><link rel="prefetch" href="/assets/index.html.05f6dacd.js"><link rel="prefetch" href="/assets/第10章Java并发包中线程同步器原理剖析.html.22c349a1.js"><link rel="prefetch" href="/assets/第11章并发编程实践.html.5db30ba4.js"><link rel="prefetch" href="/assets/第1章并发编程线程基础.html.59828def.js"><link rel="prefetch" href="/assets/第2章并发编程的其他基础知识.html.95634460.js"><link rel="prefetch" href="/assets/第3章Java并发包中ThreadLocalRandom类原理剖析.html.5e3f88be.js"><link rel="prefetch" href="/assets/第4章Java并发包中原子操作类原理剖析.html.aa40f522.js"><link rel="prefetch" href="/assets/第5章Java并发包中并发List源码剖析.html.19da87be.js"><link rel="prefetch" href="/assets/第6章Java并发包中锁原理剖析.html.e64d1f1d.js"><link rel="prefetch" href="/assets/第7章Java并发包中并发队列原理剖析.html.05c55f53.js"><link rel="prefetch" href="/assets/第8章Java并发包中线程池ThreadPoolExecutor原理探究.html.355c02bf.js"><link rel="prefetch" href="/assets/第9章Java并发包中ScheduledThreadPoolExecutor原理探究.html.bc89022d.js"><link rel="prefetch" href="/assets/index.html.0812d30d.js"><link rel="prefetch" href="/assets/第10章 Map和Set.html.d15ebc0a.js"><link rel="prefetch" href="/assets/第11章 堆与优先级列表.html.22879ed0.js"><link rel="prefetch" href="/assets/第12章 通用容器和总结.html.af4e25e8.js"><link rel="prefetch" href="/assets/第13章 文件基本技术.html.e9de4ab6.js"><link rel="prefetch" href="/assets/第14章 文件高级技术.html.6944682e.js"><link rel="prefetch" href="/assets/第15章 并发基础知识.html.fbf03dc9.js"><link rel="prefetch" href="/assets/第16章 并发包的基石.html.f5fbd049.js"><link rel="prefetch" href="/assets/第17章 并发容器.html.d522da1e.js"><link rel="prefetch" href="/assets/第18章 异步任务执行服务.html.76e9a36e.js"><link rel="prefetch" href="/assets/第19章 同步和协作工具类.html.669856bd.js"><link rel="prefetch" href="/assets/第1章 编程基础.html.3f747685.js"><link rel="prefetch" href="/assets/第20章 并发总结.html.1e326470.js"><link rel="prefetch" href="/assets/第21章 反射.html.25579869.js"><link rel="prefetch" href="/assets/第22章 注解.html.10b1af26.js"><link rel="prefetch" href="/assets/第23章 动态代理.html.76b2167b.js"><link rel="prefetch" href="/assets/第24章 类加载机制.html.2dc4cd09.js"><link rel="prefetch" href="/assets/第25章 正则表达式.html.d3486e09.js"><link rel="prefetch" href="/assets/第26章 函数式编程.html.dd3f8bd7.js"><link rel="prefetch" href="/assets/第2章 理解数据背后的二进制.html.3d5eaefa.js"><link rel="prefetch" href="/assets/第3章 类的基础.html.c86161b4.js"><link rel="prefetch" href="/assets/第4章 类的继承.html.2bce738f.js"><link rel="prefetch" href="/assets/第5章 类的继承.html.ad950d91.js"><link rel="prefetch" href="/assets/第6章 异常.html.09ddca79.js"><link rel="prefetch" href="/assets/第7章 常用基础类.html.12c88740.js"><link rel="prefetch" href="/assets/第8章 泛型.html.81d0949a.js"><link rel="prefetch" href="/assets/第9章 列表和队列.html.38c68a48.js"><link rel="prefetch" href="/assets/index.html.bf5d33db.js"><link rel="prefetch" href="/assets/第10章Executor框架.html.a7e672e0.js"><link rel="prefetch" href="/assets/第11章Java并发编程实践.html.debb41c7.js"><link rel="prefetch" href="/assets/第1章并发编程的挑战.html.1b00855d.js"><link rel="prefetch" href="/assets/第2章Java并发机制的底层实现原理.html.f005f932.js"><link rel="prefetch" href="/assets/第3章Java内存模型.html.6ec525fb.js"><link rel="prefetch" href="/assets/第4章Java并发编程基础.html.bd275d3c.js"><link rel="prefetch" href="/assets/第5章Java中的锁.html.83cc4dba.js"><link rel="prefetch" href="/assets/第6章Java并发容器和框架.html.8a83a2ef.js"><link rel="prefetch" href="/assets/第7章Java中的13个原子操作类.html.2c3c8029.js"><link rel="prefetch" href="/assets/第8章Java中的并发工具类.html.61794c87.js"><link rel="prefetch" href="/assets/第9章Java中的线程池.html.9434f936.js"><link rel="prefetch" href="/assets/index.html.93c2aee6.js"><link rel="prefetch" href="/assets/第10章避免活跃性危险.html.e7ea1e3a.js"><link rel="prefetch" href="/assets/第11章性能与可伸缩性.html.42d4a3a1.js"><link rel="prefetch" href="/assets/第12章并发程序的测试.html.690d2aba.js"><link rel="prefetch" href="/assets/第13章显式锁.html.1171f97b.js"><link rel="prefetch" href="/assets/第14章构建自定义的同步工具.html.6c72f888.js"><link rel="prefetch" href="/assets/第15章原子变量与非阻塞同步机制.html.9de6dd1b.js"><link rel="prefetch" href="/assets/第16章Java内存模型简介.html.847d1584.js"><link rel="prefetch" href="/assets/第1章简介.html.5ff3b256.js"><link rel="prefetch" href="/assets/第2章线程安全.html.34a72eca.js"><link rel="prefetch" href="/assets/第3章对象的共享.html.088b59e3.js"><link rel="prefetch" href="/assets/第4章对象的组合.html.420592f2.js"><link rel="prefetch" href="/assets/第5章基础构建模块.html.b697dc08.js"><link rel="prefetch" href="/assets/第6章任务执行.html.d2692cee.js"><link rel="prefetch" href="/assets/第7章取消与关闭.html.1033df86.js"><link rel="prefetch" href="/assets/第8章线程池的使用.html.5655d9dd.js"><link rel="prefetch" href="/assets/第9章图形用户界面应用程序.html.2c9a92f0.js"><link rel="prefetch" href="/assets/001-two-sum.html.bd5b42b8.js"><link rel="prefetch" href="/assets/002-add-two-numbers.html.1cd12f58.js"><link rel="prefetch" href="/assets/003-longest-substring-without-repeating-characters.html.3f87474a.js"><link rel="prefetch" href="/assets/index.html.346ee126.js"><link rel="prefetch" href="/assets/index.html.bddb9164.js"><link rel="prefetch" href="/assets/第10章前端编译与优化.html.27f33bd6.js"><link rel="prefetch" href="/assets/第11章后端编译与优化.html.2d98e937.js"><link rel="prefetch" href="/assets/第12章Java内存模型与线程.html.e5d51c84.js"><link rel="prefetch" href="/assets/第13章线程安全与锁优化.html.2e377ef2.js"><link rel="prefetch" href="/assets/第1章走近Java.html.7c41e7a9.js"><link rel="prefetch" href="/assets/第2章Java内存区域与内存溢出异常.html.82365a5f.js"><link rel="prefetch" href="/assets/第3章垃圾收集器与内存分配策略.html.1360e884.js"><link rel="prefetch" href="/assets/第4章虚拟机性能监控、故障处理工具.html.0a90211f.js"><link rel="prefetch" href="/assets/第5章调优案例分析与实战.html.e7e286da.js"><link rel="prefetch" href="/assets/第6章类文件结构.html.9f84d086.js"><link rel="prefetch" href="/assets/第7章虚拟机类加载机制.html.31c0a6a3.js"><link rel="prefetch" href="/assets/第8章虚拟机字节码执行引擎.html.6f40ca25.js"><link rel="prefetch" href="/assets/第9章类加载及执行子系统的案例与实战.html.5bf71bd8.js"><link rel="prefetch" href="/assets/index.html.18e34f59.js"><link rel="prefetch" href="/assets/第2章Java并行程序基础.html.79f6e18f.js"><link rel="prefetch" href="/assets/第3章JDK并发包.html.df0acd9f.js"><link rel="prefetch" href="/assets/第4章锁的优化及注意事项.html.5a2b559c.js"><link rel="prefetch" href="/assets/第5章并行模式与算法.html.c0ec6141.js"><link rel="prefetch" href="/assets/第6章Java8910与并发.html.9a2cc047.js"><link rel="prefetch" href="/assets/第7章使用Akka构建高并发程序.html.e1442a98.js"><link rel="prefetch" href="/assets/第8章并行程序调试.html.ddf890de.js"><link rel="prefetch" href="/assets/第9章多线程优化示例—Jetty核心代码分析.html.0ab5a261.js"><link rel="prefetch" href="/assets/index.html.9735d51d.js"><link rel="prefetch" href="/assets/第10章Class装载系统.html.50bb638d.js"><link rel="prefetch" href="/assets/第11章字节码执行.html.f0a2e1fd.js"><link rel="prefetch" href="/assets/第1章初探Java虚拟机.html.0a668344.js"><link rel="prefetch" href="/assets/第2章认识Java虚拟机的基本结构.html.1777df39.js"><link rel="prefetch" href="/assets/第3章常用Java虚拟机参数.html.65784af7.js"><link rel="prefetch" href="/assets/第4章垃圾回收的概念与算法.html.d6231456.js"><link rel="prefetch" href="/assets/第5章垃圾收集器和内存分配.html.6446a277.js"><link rel="prefetch" href="/assets/第6章性能监控工具.html.e9ce7787.js"><link rel="prefetch" href="/assets/第7章分析Java堆.html.ee273e82.js"><link rel="prefetch" href="/assets/第8章锁与并发.html.7624390a.js"><link rel="prefetch" href="/assets/第9章Class文件结构.html.f4c2ac9f.js"><link rel="prefetch" href="/assets/404.html.36540b0d.js"><link rel="prefetch" href="/assets/index.html.583c479d.js"><link rel="prefetch" href="/assets/index.html.c407fe6a.js"><link rel="prefetch" href="/assets/index.html.99a8f87f.js"><link rel="prefetch" href="/assets/index.html.7587b161.js"><link rel="prefetch" href="/assets/index.html.f6866d7d.js"><link rel="prefetch" href="/assets/index.html.a985c72b.js"><link rel="prefetch" href="/assets/index.html.4c96ae2e.js"><link rel="prefetch" href="/assets/404.629f43ab.js"><link rel="prefetch" href="/assets/Layout.26a2a4c9.js"><link rel="prefetch" href="/assets/Slide.b01858c1.js"><link rel="prefetch" href="/assets/Blog.ac038c81.js"><link rel="prefetch" href="/assets/auto.esm.52abc6cc.js"><link rel="prefetch" href="/assets/index.147398ee.js"><link rel="prefetch" href="/assets/index.e1c5a3de.js"><link rel="prefetch" href="/assets/mermaid.esm.min.e741c6cd.js"><link rel="prefetch" href="/assets/highlight.esm.9b852bc5.js"><link rel="prefetch" href="/assets/markdown.esm.77e8db25.js"><link rel="prefetch" href="/assets/math.esm.cb9d4be3.js"><link rel="prefetch" href="/assets/notes.esm.62c5f19d.js"><link rel="prefetch" href="/assets/reveal.esm.41ec5d7f.js"><link rel="prefetch" href="/assets/search.esm.04894411.js"><link rel="prefetch" href="/assets/zoom.esm.78977eba.js"><link rel="prefetch" href="/assets/photoswipe.esm.2debdee5.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="MyBlog"><!----><span class="site-name hide-in-pad">MyBlog</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="读书笔记"><span class="title"><span class="icon iconfont icon-note" style=""></span>读书笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/reading-notes/Effective%20Java" class="nav-link" aria-label="Effective Java"><!---->Effective Java<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91" class="nav-link" aria-label="Java 编程的逻辑"><!---->Java 编程的逻辑<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" class="nav-link" aria-label="Java 并发编程实战"><!---->Java 并发编程实战<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="nav-link" aria-label="Java 多线程编程核心技术"><!---->Java 多线程编程核心技术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E" class="nav-link" aria-label="Java 并发编程之美"><!---->Java 并发编程之美<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AJDK%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90" class="nav-link" aria-label="Java 并发实现原理：JDK 源码剖析"><!---->Java 并发实现原理：JDK 源码剖析<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" class="nav-link active" aria-label="实战 Java 高并发程序设计"><!---->实战 Java 高并发程序设计<!----></a></li><li class="dropdown-item"><a href="/reading-notes/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF" class="nav-link" aria-label="Java 并发编程的艺术"><!---->Java 并发编程的艺术<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" class="nav-link" aria-label="实战 Java 虚拟机：JVM 故障诊断与性能优化"><!---->实战 Java 虚拟机：JVM 故障诊断与性能优化<!----></a></li><li class="dropdown-item"><a href="/reading-notes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="nav-link" aria-label="深入理解 Java 虚拟机：JVM 高级特性与最佳实践"><!---->深入理解 Java 虚拟机：JVM 高级特性与最佳实践<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="leetcode"><span class="title"><span class="icon iconfont icon-note" style=""></span>leetcode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/leetcode/Top100" class="nav-link" aria-label="Top 100"><!---->Top 100<!----></a></li></ul></button></div></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/anansneaker/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><span class="icon iconfont icon-note" style=""></span><span class="title">读书笔记</span><!----></p><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Effective Java</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 编程的逻辑</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java多线程编程核心技术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程之美</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发实现原理：JDK 源码剖析</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">实战 Java 高并发程序设计</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第 1 章 走入并行世界"><!---->第 1 章 走入并行世界<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-何去何从的并行计算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1 何去何从的并行计算"><!---->1.1 何去何从的并行计算<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-1-忘掉那该死的并行" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.1 忘掉那该死的并行"><!---->1.1.1 忘掉那该死的并行<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-2-可怕的现实-摩尔定律的失效" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.2 可怕的现实：摩尔定律的失效"><!---->1.1.2 可怕的现实：摩尔定律的失效<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-3-柳暗花明-不断地前进" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.3 柳暗花明：不断地前进"><!---->1.1.3 柳暗花明：不断地前进<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-4-光明或是黑暗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.1.4 光明或是黑暗"><!---->1.1.4 光明或是黑暗<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-你必须知道的几个概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2 你必须知道的几个概念"><!---->1.2 你必须知道的几个概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-1-同步-synchronous-和异步-asynchronous" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.1 同步（Synchronous）和异步（Asynchronous）"><!---->1.2.1 同步（Synchronous）和异步（Asynchronous）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-2-并发-concurrency-和并行-parallelism" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.2 并发（Concurrency）和并行（Parallelism）"><!---->1.2.2 并发（Concurrency）和并行（Parallelism）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-3-临界区" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.3 临界区"><!---->1.2.3 临界区<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-4-阻塞-blocking-和非阻塞-non-blocking" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking）"><!---->1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-5-死锁-deadlock-、饥饿-starvation-和活锁-livelock" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><!---->1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-并发级别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3 并发级别"><!---->1.3 并发级别<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-1-阻塞" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.1 阻塞"><!---->1.3.1 阻塞<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-2-无饥饿-starvation-free" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.2 无饥饿（Starvation-Free）"><!---->1.3.2 无饥饿（Starvation-Free）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-3-无障碍-obstruction-free" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.3 无障碍（Obstruction-Free）"><!---->1.3.3 无障碍（Obstruction-Free）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-4-无锁-lock-free" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.4 无锁（Lock-Free）"><!---->1.3.4 无锁（Lock-Free）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-5-无等待-wait-free" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.3.5 无等待（Wait-Free）"><!---->1.3.5 无等待（Wait-Free）<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-有关并行的两个重要定律" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4 有关并行的两个重要定律"><!---->1.4 有关并行的两个重要定律<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-1-amdahl-定律" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.1 Amdahl 定律"><!---->1.4.1 Amdahl 定律<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-2-gustafson-定律" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.2 Gustafson 定律"><!---->1.4.2 Gustafson 定律<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-3-是否相互矛盾" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.4.3 是否相互矛盾"><!---->1.4.3 是否相互矛盾<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-回到-java-jmm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5 回到 Java：JMM"><!---->1.5 回到 Java：JMM<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-1-原子性-atomicity" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.1 原子性（Atomicity）"><!---->1.5.1 原子性（Atomicity）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-2-可见性-visibility" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.2 可见性（Visibility）"><!---->1.5.2 可见性（Visibility）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-3-有序性-ordering" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.3 有序性（Ordering）"><!---->1.5.3 有序性（Ordering）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-4-哪些指令不能重排-happen-before-规则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.5.4 哪些指令不能重排：Happen-Before 规则"><!---->1.5.4 哪些指令不能重排：Happen-Before 规则<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC2%E7%AB%A0Java%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80.html" class="nav-link sidebar-link sidebar-page" aria-label="第 2 章 Java 并行程序基础"><!---->第 2 章 Java 并行程序基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85.html" class="nav-link sidebar-link sidebar-page" aria-label="第 3 章 JDK 并发包"><!---->第 3 章 JDK 并发包<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html" class="nav-link sidebar-link sidebar-page" aria-label="第 4 章 锁的优化及注意事项"><!---->第 4 章 锁的优化及注意事项<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC5%E7%AB%A0%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 5 章 并行模式与算法"><!---->第 5 章 并行模式与算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC6%E7%AB%A0Java8910%E4%B8%8E%E5%B9%B6%E5%8F%91.html" class="nav-link sidebar-link sidebar-page" aria-label="第 6 章 Java 8 / 9 / 10 与并发"><!---->第 6 章 Java 8 / 9 / 10 与并发<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC7%E7%AB%A0%E4%BD%BF%E7%94%A8Akka%E6%9E%84%E5%BB%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="第 7 章 使用 Akka 构建高并发程序"><!---->第 7 章 使用 Akka 构建高并发程序<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC8%E7%AB%A0%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95.html" class="nav-link sidebar-link sidebar-page" aria-label="第 8 章 并行程序调试"><!---->第 8 章 并行程序调试<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC9%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B%E2%80%94Jetty%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.html" class="nav-link sidebar-link sidebar-page" aria-label="第 9 章 多线程优化示例—Jetty 核心代码分析"><!---->第 9 章 多线程优化示例—Jetty 核心代码分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">Java 并发编程的艺术</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">实战 Java 虚拟机：JVM 故障诊断与性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">深入理解 Java 虚拟机：JVM 高级特性与最佳实践</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><span class="icon iconfont icon-note" style=""></span><span class="title">leetcode</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/leetcode/Top100/" class="nav-link sidebar-link sidebar-page" aria-label="Top 100"><!---->Top 100<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第 1 章 走入并行世界</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月28日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://www.cxlsn.cn/" target="_blank" rel="noopener noreferrer">阿楠sneaker</a></span><span property="author" content="阿楠sneaker"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月28日</span><meta property="datePublished" content="2022-07-28T13:05:06.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月28日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 47 分钟</span><meta property="timeRequired" content="PT47M"></span><span class="words-info" aria-label="字数🔠" data-balloon-pos="down" localizeddate="2022年7月28日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 13952 字</span><meta property="wordCount" content="13952"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-何去何从的并行计算" class="router-link-active router-link-exact-active toc-link level2">1.1 何去何从的并行计算</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-1-忘掉那该死的并行" class="router-link-active router-link-exact-active toc-link level3">1.1.1 忘掉那该死的并行</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-2-可怕的现实-摩尔定律的失效" class="router-link-active router-link-exact-active toc-link level3">1.1.2 可怕的现实：摩尔定律的失效</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-3-柳暗花明-不断地前进" class="router-link-active router-link-exact-active toc-link level3">1.1.3 柳暗花明：不断地前进</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-1-4-光明或是黑暗" class="router-link-active router-link-exact-active toc-link level3">1.1.4 光明或是黑暗</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-你必须知道的几个概念" class="router-link-active router-link-exact-active toc-link level2">1.2 你必须知道的几个概念</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-1-同步-synchronous-和异步-asynchronous" class="router-link-active router-link-exact-active toc-link level3">1.2.1 同步（Synchronous）和异步（Asynchronous）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-2-并发-concurrency-和并行-parallelism" class="router-link-active router-link-exact-active toc-link level3">1.2.2 并发（Concurrency）和并行（Parallelism）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-3-临界区" class="router-link-active router-link-exact-active toc-link level3">1.2.3 临界区</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-4-阻塞-blocking-和非阻塞-non-blocking" class="router-link-active router-link-exact-active toc-link level3">1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-2-5-死锁-deadlock-、饥饿-starvation-和活锁-livelock" class="router-link-active router-link-exact-active toc-link level3">1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-并发级别" class="router-link-active router-link-exact-active toc-link level2">1.3 并发级别</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-1-阻塞" class="router-link-active router-link-exact-active toc-link level3">1.3.1 阻塞</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-2-无饥饿-starvation-free" class="router-link-active router-link-exact-active toc-link level3">1.3.2 无饥饿（Starvation-Free）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-3-无障碍-obstruction-free" class="router-link-active router-link-exact-active toc-link level3">1.3.3 无障碍（Obstruction-Free）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-4-无锁-lock-free" class="router-link-active router-link-exact-active toc-link level3">1.3.4 无锁（Lock-Free）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-3-5-无等待-wait-free" class="router-link-active router-link-exact-active toc-link level3">1.3.5 无等待（Wait-Free）</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-有关并行的两个重要定律" class="router-link-active router-link-exact-active toc-link level2">1.4 有关并行的两个重要定律</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-1-amdahl-定律" class="router-link-active router-link-exact-active toc-link level3">1.4.1 Amdahl 定律</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-2-gustafson-定律" class="router-link-active router-link-exact-active toc-link level3">1.4.2 Gustafson 定律</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-4-3-是否相互矛盾" class="router-link-active router-link-exact-active toc-link level3">1.4.3 是否相互矛盾</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-回到-java-jmm" class="router-link-active router-link-exact-active toc-link level2">1.5 回到 Java：JMM</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-1-原子性-atomicity" class="router-link-active router-link-exact-active toc-link level3">1.5.1 原子性（Atomicity）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-2-可见性-visibility" class="router-link-active router-link-exact-active toc-link level3">1.5.2 可见性（Visibility）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-3-有序性-ordering" class="router-link-active router-link-exact-active toc-link level3">1.5.3 有序性（Ordering）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC1%E7%AB%A0%E8%B5%B0%E5%85%A5%E5%B9%B6%E8%A1%8C%E4%B8%96%E7%95%8C.html#_1-5-4-哪些指令不能重排-happen-before-规则" class="router-link-active router-link-exact-active toc-link level3">1.5.4 哪些指令不能重排：Happen-Before 规则</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="第-1-章-走入并行世界" tabindex="-1"><a class="header-anchor" href="#第-1-章-走入并行世界" aria-hidden="true">#</a> 第 1 章 走入并行世界</h1><p>当你打开本书，也许你正试图将你的应用改造成并行模式运行，也许你只是单纯地对并行程序感兴趣。无论出于何种原因，你正对并行计算充满好奇、疑问和求知欲。如果是这样，那就对了，带着你的好奇和疑问，让我们一起遨游并行程序的世界，深入了解它们究竟是如何工作的吧！</p><p>不过首先，我想要公布一条令人沮丧的消息。就在大伙儿都认为并行计算必然成为未来的大趋势时，2014 年底，在 Avoiding ping pong 论坛上，伟大的 Linus Torvalds 提出了一个截然不同的观点，他说：“忘掉那该死的并行吧！”（原文：Give it up.The whole &quot;parallel computing is the future&quot; is a bunch of crock.）</p><h2 id="_1-1-何去何从的并行计算" tabindex="-1"><a class="header-anchor" href="#_1-1-何去何从的并行计算" aria-hidden="true">#</a> 1.1 何去何从的并行计算</h2><p>我们到底该如何选择呢？本节的目的就是拨云见日。</p><h3 id="_1-1-1-忘掉那该死的并行" tabindex="-1"><a class="header-anchor" href="#_1-1-1-忘掉那该死的并行" aria-hidden="true">#</a> 1.1.1 忘掉那该死的并行</h3><p>Linus Torvalds 是一个传奇式的人物（图1.1），是他给出了 Linux 的原型，并一直致力于推广和发展 Linux 系统。1991 年，他首先在网络上发布了 Linux 源码，从此 Linux 迅速崛起壮大，成为目前使用最广泛的操作系统之一。</p><img src="/assets/图1-1.449c2585.jpeg" alt="图1-1" style="zoom:50%;"><p>图1.1 传奇的 Linus Torvalds</p><p>自 2002 年起，Linus 就决定使用 BitKeeper 作为 Linux 内核开发的版本控制工具，以此来维护 Linux 的内核源码。BitKeeper 是一套分布式版本控制软件，它是一套商用系统，由 BitMover 公司开发。2005 年，BitKeeper 宣称发现 Linux 内核开发人员使用逆向工程来试图解析 BitKeeper 内部协议。因此，决定向 Linus 收回 BitKeeper 授权。虽然 Linux 核心团队与 BitMover 公司进行了协商，但是仍无法解决他们之间的分歧。因此，Linus 决定自行研发版本控制工具来代替 BitKeeper。于是，Git 诞生了。</p><p>如果你正在使用 Git，那么我相信你一定会为 Git 的魅力所征服；如果你还没有了解过 Git，那么我强烈建议你关注一下这款优秀的产品。</p><p>而正是这位传奇人物，给目前红红火火的并行计算泼了一大盆冷水。那么，并行计算究竟应该何去何从呢？</p><p>在 Linus 的发言中这么说道：</p><blockquote><p>Where the hell do you envision that those magical parallel algorithms would be used?</p><p>The only place where parallelism matters is in graphics or on the server side, where we already largely have it.Pushing it anywhere else is just pointless.</p><p>So the whole argument that people should parallelise their code is fundamentally <a href="http://flawed.It" target="_blank" rel="noopener noreferrer">flawed.It<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> rests on incorrect <a href="http://assumptions.It" target="_blank" rel="noopener noreferrer">assumptions.It<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>&#39;s a fad that has been going on too long.</p></blockquote><p>需要有多么奇葩的想象力才能想象出并行计算的用武之地？</p><p>并行计算只能在图像处理和服务端编程两个领域使用，并且它在这两个领域确实有着大量广泛的使用。但是在其他任何地方，并行计算毫无建树！</p><p>因此，人们争论是否应该将代码并行化是一个本质上的错误。这完全基于一个错误的假设。“并行” 是一个早该结束的时髦用语。</p><p>看了这段较为完整的表述，大家应该对 Linus 的观点有所感触，我对此也表示赞同。与串行程序不同，并行程序的设计和实现异常复杂，不仅体现在程序的功能分离上，多线程间的协调性、乱序性都会成为程序正确执行的障碍。只要你稍不留神，就会失之毫厘，谬以千里！混乱的程序难以阅读、难以理解，更难以调试。所谓并行，也就是把简单问题复杂化的典型。因此，只有 “疯子” 才会叫嚣并行就是未来（The crazies talking about scaling to hundreds of cores are just that crazy）。</p><p>但是，Linus 也提出了两个特例，那就是图像处理和服务端程序是可以也需要使用并行技术的。仔细想想，为什么图像处理和服务端程序是特例呢？</p><p>和用户终端程序不同，图像处理往往拥有极大的计算量。一张 1024 × 768 像素的图片，包含多达 78 万 6 千多个像素。即使将所有的像素遍历一遍，也得花不少时间。更何况，图像处理涉及大量的矩阵计算。矩阵的规模和数量都会非常大。因为如此密集的计算，很有可能超过单核 CPU 的计算能力，所以自然需要引入多核计算了。</p><p>而服务端程序与一般的用户终端程序相比，一方面，服务端程序需要承受很大的用户访问压力。根据淘宝的数据，它在 “双11” 一天，支付宝核心数据库集群处理了 41 亿个事务，执行 285 亿次 SQL，生成 15TB 日志，访问 1931 亿次内存数据块，发生 13 亿个物理读。如此密集的访问，恐怕任何一台单核计算机都难以胜任，因此，并行程序也就自然成了唯一的出路。另一方面，服务端程序往往会比用户终端程序拥有更复杂的业务模型。面对复杂业务模型，并行程序会比串行程序更容易适应业务需求，更容易模拟我们的现实世界。毕竟，我们的世界本质上是并行的。比如，当你开开心心去上学的时候，妈妈可能在家里忙着家务，爸爸在外打工赚钱，一家人其乐融融。如果有一天，你需要使用你的计算机来模拟这个场景，你会怎么做呢？如果你就在一个线程里，既做了你自己，又做了妈妈，又做了爸爸，显然这不是一种好的解决方案。但如果你使用三个线程，分别模拟这三个人，一切看起来那么自然，而且容易被人理解。</p><p>再举一个专业点的例子，比如基础平台 Java 虚拟机，虚拟机除了要执行 main 函数主线程外，还需要做 JIT 编译，需要做垃圾回收。无论是 main 函数、JIT 编译还是垃圾回收，在虚拟机内部都是一个单独的线程。是什么使得虚拟机的研发人员这么做的呢？显然，这是因为建模的需要。因为这里的每一个任务都是相对独立的。我们不应该将没有关联的业务代码拼凑在一起，分离为不同的线程更容易理解和维护。因此，使用并行也不完全是出于性能的考虑，而有时候，我们会很自然地那么做。</p><h3 id="_1-1-2-可怕的现实-摩尔定律的失效" tabindex="-1"><a class="header-anchor" href="#_1-1-2-可怕的现实-摩尔定律的失效" aria-hidden="true">#</a> 1.1.2 可怕的现实：摩尔定律的失效</h3><p>摩尔定律是由英特尔创始人之一戈登·摩尔提出来的，其内容为：集成电路上可容纳的电晶体（晶体管）数目，约每隔 24 个月便会增加一倍。经常被引用的 “18 个月”，是由英特尔首席执行官大卫·豪斯所说：预计 18 个月会将芯片的性能提高一倍（即更多的晶体管使其更快）。</p><p>说得直白点，就是每 18 个月到 24 个月，我们的计算机性能就能翻一番。</p><p>反过来说，就是每过 18 个月到 24 个月，你在未来用一半的价钱就能买到和现在性能相同的计算设备了。这听起来是一件多么激动人心的事情呀！</p><p>但是，摩尔定律并不是一种自然法则或者物理定律，它只是基于人为观测数据对未来的预测。按照这种速度，我们的计算能力将会按照指数速度增长，用不了多久，我们的计算能力就能超越 “上帝” 了！畅想未来，基于强劲的超级计算机，我们甚至可以模拟整个宇宙。</p><p>摩尔定律的有效性已经超过半个世纪了，然而，在 2004 年，Intel 宣布将 4GHz 芯片的发布时间推迟到 2005 年，在 2004 年秋季，Intel 宣布彻底取消 4GHz 计划（如图1.2 所示）。</p><img src="/assets/图1-2.b324087e.jpeg" alt="图1-2" style="zoom:50%;"><p>图1.2 Intel CEO Barret 单膝下跪对取消 4GHz 感到抱歉</p><p>是什么迫使世界顶级的科技巨头放弃 4GHz 的研发呢？显然，就目前的硅电路而言，很有可能已经走到了头。我们的制造工艺已经精确到了纳米了。1 纳米是 10<sup>-9</sup> 米，也就是十亿分之一米。这已经是一个相当小的数字了。就目前的科技水平而言，如果无法在物质分子层面以下进行工作，那么也许 4GHz 的芯片就已经接近理论极限了。因为即使一个水分子，它的直径也有 0.4 纳米。再往下发展就显得有些困难。当然，如果我们使用完全不同的计算理论或者芯片生成工艺，也许会有本质的突破，但目前还没有看到这种技术被大规模使用的可能。</p><p>因此，摩尔定律在 CPU 的计算性能上可能已经失效。虽然，现在 Intel 已经研制出了 4GHz 芯片，但可以看到，在近 10 年的发展中，CPU 主频的提升已经明显遇到了一些暂时不可逾越的瓶颈。</p><h3 id="_1-1-3-柳暗花明-不断地前进" tabindex="-1"><a class="header-anchor" href="#_1-1-3-柳暗花明-不断地前进" aria-hidden="true">#</a> 1.1.3 柳暗花明：不断地前进</h3><p>虽然 CPU 的性能已经几近止步，长达半个世纪的摩尔定律轰然倒地，但是这依然没有阻挡科学家和工程师们带领我们不断向前的脚步。</p><p>从 2005 年开始，我们已经不再追求单核的计算速度，而着迷于研究如何将多个独立的计算单元整合到单独的 CPU 中，也就是我们所说的多核 CPU。短短十几年的发展，家用型 CPU，比如 Intel i7 就可以拥有 4 核心，甚至 8 核心。而专业服务器则通常可以配有几个独立的 CPU，每一个 CPU 都拥有多达 8 个甚至更多的内核。从整体上看，专业服务器的内核总数甚至可以达到几百个。</p><p>非常令人激动，摩尔定律在另外一个侧面又生效了。根据这个定律，我们可以预测，每过 18 个月到 24 个月，CPU 的核心数就会翻一番。用不了多久，拥有几十甚至上百个 CPU 内核的芯片就能进入千家万户。</p><p>顶级计算机科学家唐纳德·尔文·克努斯（Donald Ervin Knuth），如此评价这种情况：在我看来，这种现象（并发）或多或少是由于硬件设计者已经无计可施导致的，他们将摩尔定律失效的责任推给软件开发者。</p><p>唐纳德（如图1.3 所示）是计算机巨著《计算机程序设计艺术》的作者。《美国科学家》杂志曾将该书与爱因斯坦的《相对论》、狄拉克的《量子力学》和理查·费曼的《量子电动力学》等书并列为 20 世纪最重要的 12 本物理科学类专论书之一。</p><img src="/assets/图1-3.ced2e201.jpeg" alt="图1-3" style="zoom:50%;"><p>图1.3 唐纳德</p><h3 id="_1-1-4-光明或是黑暗" tabindex="-1"><a class="header-anchor" href="#_1-1-4-光明或是黑暗" aria-hidden="true">#</a> 1.1.4 光明或是黑暗</h3><p>根据唐纳德的观点，摩尔定律本应该由硬件开发人员维持。但是，很不幸，硬件工程师似乎已经无计可施了。为了继续保持性能的高速发展，硬件工程师破天荒地想出了将多个 CPU 内核塞进一个 CPU 里的奇妙想法。由此，并行计算就被非常自然地推广开来，随之而来的问题也层出不穷，程序员的黑暗时期也随之到来。简化的硬件设计方案必然带来软件设计的复杂性。换句话说，软件工程师正在为硬件工程师无法完成的工作负责，因此，也就有了唐纳德的 “他们将摩尔定律失效的责任推给了软件开发者” 的说法。</p><p>所以，如何让多个 CPU 有效并且正确地工作也就成了一门技术，甚至是很大的学问。比如，多线程间如何保证线程安全，如何正确理解线程间的无序性、可见性，如何尽可能地设计并行程序，如何将串行程序改造为并行程序。而对并行计算的研究，也就是希望给这片黑暗带来光明。</p><h2 id="_1-2-你必须知道的几个概念" tabindex="-1"><a class="header-anchor" href="#_1-2-你必须知道的几个概念" aria-hidden="true">#</a> 1.2 你必须知道的几个概念</h2><p>现在，并行计算显然已经成为一门正式的学科。也许很多人（包括 Linus 在内）都觉得并行计算或者说并行算法是多么的奇葩。但现在我们也不得不承认，在某些领域，这些算法还是有用武之地的。既然说服务端编程还是需要大量并行计算的，而 Java 也主要占领着服务端市场，那么对 Java 并行计算的研究也就显得非常必要。但我想在这里先介绍几个重要的相关概念。</p><h3 id="_1-2-1-同步-synchronous-和异步-asynchronous" tabindex="-1"><a class="header-anchor" href="#_1-2-1-同步-synchronous-和异步-asynchronous" aria-hidden="true">#</a> 1.2.1 同步（Synchronous）和异步（Asynchronous）</h3><p>同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中 “真实” 地执行。整个过程，不会阻碍调用者的工作。图1.4 显示了同步方法调用和异步方法调用的区别。对于调用者来说，异步调用似乎是一瞬间就完成的。如果异步调用需要返回结果，那么当这个异步调用真实完成时，则会通知调用者。</p><img src="/assets/图1-4.ab8e445c.jpeg" alt="图1-4" style="zoom:100%;"><p>图1.4 同步方法调用和异步方法调用</p><p>打个比方，比如购物，如果你去商场买空调，当你到了商场看中了一款空调，你就向售货员下单。售货员去仓库帮你调配物品。这天你热得实在不行了，就催着商家赶紧给你送货，于是你就在商店里候着他们，直到商家把你和空调一起送回家，一次愉快的购物就结束了。这就是同步调用。</p><p>不过，如果我们赶时髦，就坐在家里打开电脑，在网上订购了一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没送到家，但是你的任务已经完成了。商家接到了你的订单后，就会加紧安排送货，当然这一切已经跟你无关了。你已经支付完成，想干什么就能去干什么，出去溜几圈都不成问题，等送货上门的时候，接到商家的电话，回家一趟签收就完事了。这就是异步调用。</p><h3 id="_1-2-2-并发-concurrency-和并行-parallelism" tabindex="-1"><a class="header-anchor" href="#_1-2-2-并发-concurrency-和并行-parallelism" aria-hidden="true">#</a> 1.2.2 并发（Concurrency）和并行（Parallelism）</h3><p>并发和并行是两个非常容易被混淆的概念。它们都可以表示两个或者多个任务一起执行，但是侧重点有所不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的，而并行是真正意义上的 “同时执行”，图1.5 很好地诠释了这点。</p><img src="/assets/图1-5.29c80d3d.jpeg" alt="图1-5" style="zoom:100%;"><p>图1.5 并发和并行</p><p>从严格意义上来说，并行的多个任务是真的同时执行，而对于并发来说，这个过程只是交替的，一会儿执行任务 A，一会儿执行任务 B，系统会不停地在两者之间切换。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间并行执行的错觉。</p><p>这两种情况在生活中都很常见。我曾经去黄山旅游过两次，黄山风景奇特，有着 “五岳归来不看山，黄山归来不看岳” 的美誉。只要去过黄山的人都应该知道，导游时常挂在嘴边的 “走路不看景，看景不走路”。因为黄山顶上经常下雨，地面湿滑，地形险峻。如果边走边看，跌倒擦伤那是常有的事。为了安全起见，就要求游客看景的时候停下脚步，走路的时候能够专心看着地面，管好双脚。这就是 “并发”。它和 “边走边看” 有着非常奇妙的关系，因为这两种情况都可以被认为是 “同时在看景和走路”。</p><p>那么在黄山上真正的 “并行” 应该是什么样的呢？聪明的同学应该可以想到，那就是坐缆车上山。缆车可以代替步行，你坐在缆车上才能专心欣赏沿途的风景，“走路” 这些事情全部交给缆车去完成就好了。</p><p>实际上，如果系统内只有一个 CPU，而使用多进程或者多线程任务，那么真实环境中这些任务不可能是真实并行的，毕竟一个 CPU 一次只能执行一条指令，在这种情况下多进程或者多线程就是并发的，而不是并行的（操作系统会不停地切换多个任务）。真实的并行也只可能出现在拥有多个 CPU 的系统中（比如多核 CPU）。</p><p>由于并发的最终效果可能和并行的一样，因此，如果没有特别的需要，我在本书中不会特别强调两者的区别。</p><h3 id="_1-2-3-临界区" tabindex="-1"><a class="header-anchor" href="#_1-2-3-临界区" aria-hidden="true">#</a> 1.2.3 临界区</h3><p>临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</p><p>比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件。小明的任务就只能等待小王打印结束后才能打印。这里的打印机就是一个临界区的例子。</p><p>在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务的情况，那么最可能的结果就是打印出来的文件是损坏的文件。它既不是小王想要的，也不是小明想要的。</p><h3 id="_1-2-4-阻塞-blocking-和非阻塞-non-blocking" tabindex="-1"><a class="header-anchor" href="#_1-2-4-阻塞-blocking-和非阻塞-non-blocking" aria-hidden="true">#</a> 1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking）</h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p><p>非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断前向执行。有关这个概念，将在本章 “并发级别” 一节中做更详细的描述。</p><h3 id="_1-2-5-死锁-deadlock-、饥饿-starvation-和活锁-livelock" tabindex="-1"><a class="header-anchor" href="#_1-2-5-死锁-deadlock-、饥饿-starvation-和活锁-livelock" aria-hidden="true">#</a> 1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</h3><p>死锁、饥饿和活锁都属于多线程的活跃性问题。如果发现上述几种情况，那么相关线程可能就不再活跃，也就是说它可能很难再继续往下执行了。</p><p>死锁应该是最糟糕的一种情况了（当然，其他几种情况也好不到哪里去），图1.6 显示了一个死锁的发生。</p><img src="/assets/图1-6.f9308121.jpeg" alt="图1-6" style="zoom:100%;"><p>图1.6 死锁的发生</p><p>A、B、C、D 四辆小车在这种情况下都无法继续行驶了。它们彼此之间相互占用了其他车辆的车道，如果大家都不愿意释放自己的车道，那么这个状态将永远持续下去，谁都不可能通过。死锁是一个很严重的并且应该避免和时时小心的问题，我们将安排在 “锁的优化及注意事项” 中进行更详细的讨论。</p><p>饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。在自然界中，母鸟给雏鸟喂食时很容易出现这种情况：由于雏鸟很多，食物有限，雏鸟之间的食物竞争可能非常厉害，经常抢不到食物的雏鸟有可能会被饿死。线程的饥饿非常类似这种情况。此外，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如，高优先级的线程已经完成任务，不再疯狂执行）。</p><p>活锁是一种非常有趣的情况。不知道大家是否遇到过这么一种场景，当你要坐电梯下楼时，电梯到了，门开了，这时你正准备出去。但很不巧的是，门外一个人挡着你的去路，他想进来。于是，你很礼貌地靠左走，避让对方。同时，对方也非常礼貌地靠右走，希望避让你。结果，你们俩就又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右边走，同时，他立即向左边走。结果，又撞上了！不过介于人类的智能，我相信这个动作重复两三次后，你应该可以顺利解决这个问题。因为这个时候，大家都会本能地对视，进行交流，保证这种情况不再发生。</p><p>但如果这种情况发生在两个线程之间可能就不会那么幸运了。如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。这种情况就是活锁。</p><h2 id="_1-3-并发级别" tabindex="-1"><a class="header-anchor" href="#_1-3-并发级别" aria-hidden="true">#</a> 1.3 并发级别</h2><p>由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别分为阻塞、无饥饿、无障碍、无锁、无等待几种。</p><h3 id="_1-3-1-阻塞" tabindex="-1"><a class="header-anchor" href="#_1-3-1-阻塞" aria-hidden="true">#</a> 1.3.1 阻塞</h3><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用 synchronized 关键字或者重入锁时（我们将在第 2、3 章介绍这两种技术），我们得到的就是阻塞的线程。</p><p>synchronized 关键字和重入锁都试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。</p><h3 id="_1-3-2-无饥饿-starvation-free" tabindex="-1"><a class="header-anchor" href="#_1-3-2-无饥饿-starvation-free" aria-hidden="true">#</a> 1.3.2 无饥饿（Starvation-Free）</h3><p>如果线程之间是有优先级的，那么线程调度的时候总是会倾向于先满足高优先级的线程。也就说是，对于同一个资源的分配，是不公平的！图1.7 显示了非公平锁与公平锁两种情况（五角星表示高优先级线程）。对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，按照先来后到的规则，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队，这样所有的线程都有机会执行。</p><img src="/assets/图1-7.beb41533.jpeg" alt="图1-7" style="zoom:100%;"><p>图1.7 非公平锁与公平锁</p><h3 id="_1-3-3-无障碍-obstruction-free" tabindex="-1"><a class="header-anchor" href="#_1-3-3-无障碍-obstruction-free" aria-hidden="true">#</a> 1.3.3 无障碍（Obstruction-Free）</h3><p>无障碍是一种最弱的非阻塞调度。两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起。换言之，大家都可以大摇大摆地进入临界区了。那么大家一起修改共享数据，把数据改坏了怎么办呢？对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。</p><p>如果说阻塞的控制方式是悲观策略，也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此以保护共享数据为第一优先级，相对来说，非阻塞的调度就是一种乐观的策略。它认为多个线程之间很有可能不会发生冲突，或者说这种概率不大。因此大家都应该无障碍地执行，但是一旦检测到冲突，就应该进行回滚。</p><p>从这个策略中也可以看到，无障碍的多线程程序并不一定能顺畅运行。因为当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。所以，我们可能会非常希望在这一堆线程中，至少可以有一个线程能够在有限的时间内完成自己的操作，而退出临界区。至少这样可以保证系统不会在临界区中进行无限的等待。</p><p>一种可行的无障碍实现可以依赖一个 “一致性标记” 来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。</p><h3 id="_1-3-4-无锁-lock-free" tabindex="-1"><a class="header-anchor" href="#_1-3-4-无锁-lock-free" aria-hidden="true">#</a> 1.3.4 无锁（Lock-Free）</h3><p>无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。</p><p>在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的，不至于全军覆没。至于临界区中竞争失败的线程，它们必须不断重试，直到自己获胜。如果运气很不好，总是尝试不成功，则会出现类似饥饿的现象，线程会停止。</p><p>下面就是一段无锁的示意代码，如果修改不成功，那么循环永远不会停止。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>atomicVar<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>loclaVar<span class="token punctuation">,</span> localVar <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    localVar <span class="token operator">=</span> atomicVar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有关无锁，我们将在 “锁的优化及注意事项” 一章中详细介绍。</p><h3 id="_1-3-5-无等待-wait-free" tabindex="-1"><a class="header-anchor" href="#_1-3-5-无等待-wait-free" aria-hidden="true">#</a> 1.3.5 无等待（Wait-Free）</h3><p>无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步扩展。它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。如果限制这个步骤的上限，还可以进一步分解为有界无等待和线程数无关的无等待等几种，它们之间的区别只是对循环次数的限制不同。</p><p>一种典型的无等待结构就是 RCU（Read Copy Update）。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。</p><h2 id="_1-4-有关并行的两个重要定律" tabindex="-1"><a class="header-anchor" href="#_1-4-有关并行的两个重要定律" aria-hidden="true">#</a> 1.4 有关并行的两个重要定律</h2><p>有关为什么要使用并行程序的问题前面已经进行了简单的探讨。总的来说，最重要的应该是出于两个目的。第一，为了获得更好的性能；第二，由于业务模型的需要，确实需要多个执行实体。在这里，我将更加关注于第一种情况，也就是有关性能的问题。将串行程序改造为并发程序，一般来说可以提高程序的整体性能，但是究竟能提高多少，甚至说究竟是否真的可以提高，还是一个需要研究的问题。目前，主要有两个定律对这个问题进行解答，一个是 Amdahl 定律，另外一个是 Gustafson 定律。</p><h3 id="_1-4-1-amdahl-定律" tabindex="-1"><a class="header-anchor" href="#_1-4-1-amdahl-定律" aria-hidden="true">#</a> 1.4.1 Amdahl 定律</h3><p>Amdahl 定律是计算机科学中非常重要的定律。它定义了串行系统并行化后的加速比的计算公式和理论上限。</p><p>加速比定义：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>加速比</mtext><mo>=</mo><mtext>优化前系统耗时</mtext><mi mathvariant="normal">/</mi><mtext>优化后系统耗时</mtext></mrow><annotation encoding="application/x-tex">加速比 = 优化前系统耗时 / 优化后系统耗时 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">加速比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">优化前系统耗时</span><span class="mord">/</span><span class="mord cjk_fallback">优化后系统耗时</span></span></span></span></span></p><p>所谓加速比就是优化前的耗时与优化后耗时的比值。加速比越高，表明优化效果越明显。图1.8 显示了 Amdahl 公式的推导过程，其中 n 表示处理器个数，T 表示时间，T1 表示优化前耗时（也就是只有 1 个处理器时的耗时），Tn 表示使用 n 个处理器优化后的耗时。F 是程序中只能串行执行的比例。</p><img src="/assets/图1-8.3f89531a.jpeg" alt="图1-8" style="zoom:100%;"><p>图1.8　Amdahl 公式的推导</p><p>根据这个公式，如果 CPU 处理器数量趋于无穷，那么加速比与系统的串行化比例成反比，如果系统中必须有 50% 的代码串行执行，那么系统的最大加速比为 2。</p><p>假设有一个程序分为以下步骤执行，每个执行步骤花费 100 个单位时间。其中，只有步骤 2 和步骤 5 可以并行，步骤 1、3、4 必须串行，如图1.9 所示。在全串行的情况下，系统合计耗时为 500 个单位时间。</p><img src="/assets/图1-9.1903f5d4.jpeg" alt="图1-9" style="zoom:100%;"><p>图1.9 串行工作流程</p><p>若将步骤 2 和步骤 5 并行化，假设在双核处理上，则有如图1.10 所示的处理流程。在这种情况下，步骤 2 和步骤 5 的耗时将为 50 个单位时间。故系统整体耗时为 400 个单位时间。根据加速比的定义有：</p><p>加速比 = 优化前系统耗时 / 优化后系统耗时 = 500 / 400 = 1.25</p><img src="/assets/图1-10.566324b0.jpeg" alt="图1-10" style="zoom:100%;"><p>图1.10 双核处理上的并行化</p><p>由于 5 个步骤中，3 个步骤必须串行，因此其串行化比例为 3 / 5 = 0.6，即 F = 0.6，且双核处理器的处理器个数 N 为 2。代入加速比公式得：</p><p>加速比 = 1 / (0.6 + (1 - 0.6) / 2) = 1.25</p><p>在极端情况下，假设并行处理器个数为无穷大，则有如图1.11 所示的处理过程。步骤 2 和步骤 5 的处理时间趋于 0。即使这样，系统整体耗时依然大于 300 个单位时间。使用加速比计算公式，N 趋于无穷大，有加速比 = 1 / F，且 F = 0.6，故有加速比 = 1.67。即加速比的极限为 500 / 300 = 1.67。</p><img src="/assets/图1-11.341c24ba.jpeg" alt="图1-11" style="zoom:100%;"><p>图1.11 极端情况下的并行化</p><p>由此可见，为了提高系统的速度，仅增加 CPU 处理器的数量并不一定能起到有效的作用。需要从根本上修改程序的串行行为，提高系统内可并行化的模块比重，在此基础上，合理增加并行处理器数量，才能以最小的投入，得到最大的加速比。</p><p>注意：根据 Amdahl 定律，使用多核 CPU 对系统进行优化，优化的效果取决于 CPU 的数量，以及系统中的串行化程序的比例。CPU 数量越多，串行化比例越低，则优化效果越好。仅提高 CPU 数量而不降低程序的串行化比例，也无法提高系统性能。</p><h3 id="_1-4-2-gustafson-定律" tabindex="-1"><a class="header-anchor" href="#_1-4-2-gustafson-定律" aria-hidden="true">#</a> 1.4.2 Gustafson 定律</h3><p>Gustafson 定律也试图说明处理器个数、串行化比例和加速比之间的关系，如图1.12 所示，但是 Gustafson 定律和 Amdahl 定律的角度不同。同样，加速比都被定义为优化前的系统耗时除以优化后的系统耗时。</p><img src="/assets/图1-12.c9f7eebd.jpeg" alt="图1-12" style="zoom:100%;"><p>图1.12 Gustafson 定律的推导</p><p>可以看到，由于切入角度的不同，Gustafson 定律的公式和 Amdahl 定律的公式截然不同。从 Gustafson 定律中，我们可以更容易地发现，如果串行化比例很小，并行化比例很大，那么加速比就是处理器的个数。只要不断地累加处理器，就能获得更快的速度。</p><h3 id="_1-4-3-是否相互矛盾" tabindex="-1"><a class="header-anchor" href="#_1-4-3-是否相互矛盾" aria-hidden="true">#</a> 1.4.3 是否相互矛盾</h3><p>Amdahl 定律和 Gustafson 定律的结论不同，这是不是说明这两个理论之间有一个是错误的呢？其实不然，两者的差异其实是因为这两个定律对同一个客观事实从不同角度去审视后的结果，它们的侧重点有所不同。</p><p>举一个生活中的例子，一辆汽车行驶在 60km 的路上，你花了一个小时，行驶了 30km。无论接下来开多快，你都不可能达到 90km/h 的速度。图1.13 很好地说明了原因。</p><img src="/assets/图1-13.01ca90d9.jpeg" alt="图1-13" style="zoom:100%;"><p>图1.13 Amdahl 定律的偏重点</p><p>求解图1.13 中的方程，你会发现如果想达到 90km 的时速，那么你从 AB 中点到达 B 点的时间会是一个负数，这显然不是一个合理的结论。实际上，如果前半程 30km 你使用了一小时，那么即使你从中点到 B 点使用光速，也只能把整体的平均时速维持在 60km/h。</p><p>也就是说 Amdahl 强调：当串行化比例一定时，加速比是有上限的，不管你堆叠多少个 CPU 参与计算，都不能突破这个上限！</p><p>而 Gustafson 定律的出发点与之不同，对 Gustafson 定律来说，不管你从 A 点出发的速度有多慢，只要给你足够的时间和距离，只要你后期的速度比期望值快那么一点点，你总是可以把平均速度调整到非常接近那个期望值的。比如，你想要达到均速 90km/h，即使在前 30km 你的时速只有 30km/h，你只要在后面的速度达到 91km/h，给你足够的时间和距离，总有一天可以把均速提高到 90km/h。</p><p>因此，Gustafson 定律关心的是：如果可被并行化的代码所占比例足够大，那么加速比就能随着 CPU 的数量线性增长。</p><p>所以，这两个定律并不矛盾。从极端的角度来说，如果系统中没有可被并行化的代码（即 F = 1），那么对于这两个定律，其加速比都是 1。反之，如果系统中可被并行化代码的比例达到 100%，那么这两个定律得到的加速比都是 n（处理器个数）。</p><h2 id="_1-5-回到-java-jmm" tabindex="-1"><a class="header-anchor" href="#_1-5-回到-java-jmm" aria-hidden="true">#</a> 1.5 回到 Java：JMM</h2><p>前面我已经介绍了有关并行程序的一些关键概念和定律。这些概念可以说是与语言无关的。无论你使用 Java 或者 C，或者其他任何一门语言编写并发程序，都有可能会涉及这些问题。但本书是一本面向 Java 程序员的书籍，因此，在本章最后，我们还是希望可以探讨一下有关 Java 的内存模型（JMM）。</p><p>由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序中数据访问的一致性和安全性将会受到严重挑战。如何保证一个线程可以看到正确的数据呢？这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是 1，那么你读到的一定是 1，就是这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是 1 的数值，你也有可能读到 2。因此，我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个线程间可以有效地、正确地协同工作。而 JMM 也就是为此而生的。</p><p>JMM 的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。因此，我们首先必须了解这些概念。</p><h3 id="_1-5-1-原子性-atomicity" tabindex="-1"><a class="header-anchor" href="#_1-5-1-原子性-atomicity" aria-hidden="true">#</a> 1.5.1 原子性（Atomicity）</h3><p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>比如，对于一个静态全局变量 int i，两个线程同时对它赋值，线程 A 给它赋值 1，线程 B 给它赋值为 -1。那么不管这两个线程以何种方式、何种步调工作，i 的值要么是 1，要么是 -1。线程 A 和线程 B 之间是没有干扰的。这就是原子性的一个特点，不可被中断。</p><p>但如果我们不使用 int 型数据而使用 long 型数据，可能就没有那么幸运了。对于 32 位系统来说，long 型数据的读写不是原子性的（因为 long 型数据有 64 位）。也就是说，如果两个线程同时对 long 型数据进行写入（或者读取），则对线程之间的结果是有干扰的。</p><p>大家可以仔细观察一下下面的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiThreadLong</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ChangeT</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token keyword">to</span><span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">ChangeT</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">MultiThreadLong</span><span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReadT</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token class-name">MultiThreadLong</span><span class="token punctuation">.</span>t<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token number">111L</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">999L</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">!=</span> <span class="token number">333L</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">444L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChangeT</span><span class="token punctuation">(</span><span class="token number">111L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChangeT</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">999L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChangeT</span><span class="token punctuation">(</span><span class="token number">333L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChangeT</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">444L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReadT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码有 4 个线程对 long 型数据 t 进行赋值，分别对 t 赋值为 111、-999、333、-444。然后，有一个读取线程读取这个 t 的值。一般来说，t 的值总是这 4 个数值中的一个。这当然也是我们的期望了。但很不幸，在 32 位的 Java 虚拟机中，未必总是这样。</p><p>如果读取线程 ReadT 总是读到合理的数据，那么这个程序应该没有任何输出。但是，实际上，这个程序一旦运行，就会大量输出以下信息（再次强调，使用 32 位虚拟机）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">-</span><span class="token number">4294966963</span>
<span class="token number">4294966852</span>
<span class="token operator">-</span><span class="token number">4294966963</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里截取了部分输出。我们可以看到，读取线程居然读到了两个似乎根本不可能存在的数值。这不是幻觉，在这里，你看到的确实是事实，因为在 32 位系统中 long 型数据的读和写都不是原子性的，多线程之间相互干扰了！</p><p>如果给出这几个数值的二进制表示，大家就会有更清晰的认识了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">+</span><span class="token number">111</span><span class="token operator">=</span><span class="token number">0000000000000000000000000000000000000000000000000000000001101111</span>
<span class="token operator">-</span><span class="token number">999</span><span class="token operator">=</span><span class="token number">1111111111111111111111111111111111111111111111111111110000011001</span>
<span class="token operator">+</span><span class="token number">333</span><span class="token operator">=</span><span class="token number">0000000000000000000000000000000000000000000000000000000101001101</span>
<span class="token operator">-</span><span class="token number">444</span><span class="token operator">=</span><span class="token number">1111111111111111111111111111111111111111111111111111111001000100</span>
<span class="token operator">+</span><span class="token number">4294966852</span><span class="token operator">=</span><span class="token number">0000000000000000000000000000000011111111111111111111111001000100</span>
<span class="token operator">-</span><span class="token number">4294967185</span><span class="token operator">=</span><span class="token number">1111111111111111111111111111111100000000000000000000000001101111</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面显示了这几个相关数字的补码形式，也就是在计算机内的真实存储内容。不难发现，这个奇怪的 4294966852，其实是 111 或者 333 的前 32 位与 -444 的后 32 位夹杂后的数字。而 -4294967185 只是 -999 或者 -444 的前 32 位与 111 夹杂后的数字。换句话说，由于并行的关系，数字被写乱了，或者读的时候，读串位了。</p><p>通过这个例子，我想大家对原子性应该有了基本的认识。</p><h3 id="_1-5-2-可见性-visibility" tabindex="-1"><a class="header-anchor" href="#_1-5-2-可见性-visibility" aria-hidden="true">#</a> 1.5.2 可见性（Visibility）</h3><p>可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。显然，对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，在后续的步骤中读取这个变量的值时，读取的一定是修改后的新值。</p><p>但是这个问题存在于并行程序中。如果一个线程修改了某一个全局变量，那么其他线程未必可以马上知道这个改动。图1.14 展示了发生可见性问题的一种可能。如果在 CPU1 和 CPU2 上各运行了一个线程，它们共享变量 t，由于编译器优化或者硬件优化的缘故，在 CPU1 上的线程将变量 t 进行了优化，将其缓存在 cache 中或者寄存器里。在这种情况下，如果在 CPU2 上的某个线程修改了变量 t 的实际值，那么 CPU1 上的线程可能无法意识到这个改动，依然会读取 cache 中或者寄存器里的数据。因此，就产生了可见性问题。外在表现为：变量 t 的值被修改，但是 CPU1 上的线程依然会读到一个旧值。可见性问题也是并行程序开发中需要重点关注的问题之一。</p><img src="/assets/图1-14.5a6f33bb.jpeg" alt="图1-14" style="zoom:100%;"><p>图1.14 可见性问题</p><p>可见性问题是一个综合性问题。除上面提到的缓存优化或者硬件优化（有些内存读写可能不会立即触发，而会先进入一个硬件队列等待）会导致可见性问题以外，指令重排（这个问题将在下一节中详细讨论）及编辑器的优化，也有可能导致一个线程的修改不会立即被其他线程察觉。下面来看一个简单的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread1</span>		<span class="token class-name">Thread2</span>
<span class="token number">1</span><span class="token operator">:</span> r2 <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">;</span>	<span class="token number">3</span><span class="token operator">:</span> r1 <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token number">2</span><span class="token operator">:</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span class="token number">4</span><span class="token operator">:</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述两个线程并行执行，分别有 1、2、3、4 四条指令。其中指令 1、2 属于线程 1，而指令 3、4 属于线程 2。</p><p>从指令的执行顺序上看，r2 == 2 并且 r1 == 1 似乎是不可能出现的。但实际上，我们并没有办法从理论上保证这种情况不出现。因为编译器可能将指令重排成：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread1</span>		<span class="token class-name">Thread2</span>
<span class="token class-name">B</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>		r1 <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
r2 <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">;</span>		<span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种执行顺序中，就有可能出现刚才看似不可能出现的 r2 == 2 并且 r1 == 1 的情况了。</p><p>这个例子就说明，在一个线程中观察另外一个线程的变量，它们的值是否能观测到、何时能观测到是没有保证的。</p><p>再来看一个稍微复杂一些的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread1</span>		<span class="token class-name">Thread2</span>
r1 <span class="token operator">=</span> p<span class="token punctuation">;</span>		r6 <span class="token operator">=</span> p<span class="token punctuation">;</span>
r2 <span class="token operator">=</span> r1<span class="token punctuation">.</span>x<span class="token punctuation">;</span>	r6<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
r3 <span class="token operator">=</span> q<span class="token punctuation">;</span>
r4 <span class="token operator">=</span> r3<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
r5 <span class="token operator">=</span> r1<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里假设在初始时，p == q 并且 p.x == 0。对于大部分编译器来说，可能会对线程 1 进行向前替换的优化，也就是 r5 = r1.x 这条指令会被直接替换成 r5 = r2。由于它们都读取了 r1.x，又发生在同一个线程中，因此，编译器很可能认为第 2 次读取是完全没有必要的。因此，上述指令可能会变成：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Thread1</span>		<span class="token class-name">Thread2</span>
r1 <span class="token operator">=</span> p<span class="token punctuation">;</span>		r6 <span class="token operator">=</span> p<span class="token punctuation">;</span>
r2 <span class="token operator">=</span> r1<span class="token punctuation">.</span>x<span class="token punctuation">;</span>	r6<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
r3 <span class="token operator">=</span> q<span class="token punctuation">;</span>
r4 <span class="token operator">=</span> r3<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
r5 <span class="token operator">=</span> r2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在思考这么一种场景。假设线程 2 中的 r6.x = 3 发生在 r2 = r1.x 和 r4 = r3.x 之间，而编译器又打算重用 r2 来表示 r5，那么就有可能出现非常奇怪的现象。你看到的 r2 是 0，r4 是 3，但是 r5 还是 0。因此，如果从线程 1 代码的直观感觉上看就是：p.x 的值从 0 变成了 3（因为 r4 是 3），接着又变成了 0（这是不是算一个非常怪异的问题呢？）。</p><h3 id="_1-5-3-有序性-ordering" tabindex="-1"><a class="header-anchor" href="#_1-5-3-有序性-ordering" aria-hidden="true">#</a> 1.5.3 有序性（Ordering）</h3><p>有序性问题可能是三个问题中最难理解的了。对于一个线程的执行代码而言，我们总是习惯性地认为代码是从前往后依次执行的。这么理解也不能说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。听起来有些不可思议，是吗？有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。下面来看一个简单的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">OrderExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设线程 A 首先执行 writer() 方法，接着线程 B 执行 reader() 方法，如果发生指令重排，那么线程 B 在代码第 10 行时，不一定能看到 a 已经被赋值为 1 了。图1.15 展示了两个线程的调用关系。</p><img src="/assets/图1-15.8375a2d7.jpeg" alt="图1-15" style="zoom:100%;"><p>图1.15 指令重排引起线程间语义不一致</p><p>这确实是一个看起来很奇怪的问题，但是它确实可能存在。</p><p>注意：这里说的是可能存在。因为如果指令没有重排，这个问题就不存在了，但是指令是否发生重排、如何重排，恐怕是我们无法预测的。因此，对于这类问题，我认为比较严谨的描述是：线程 A 的指令执行顺序在线程 B 看来是没有保证的。如果运气好的话，线程 B 也许真的可以看到和线程 A 一样的执行顺序。</p><p>不过这里还需要强调一点，对于一个线程来说，它看到的指令执行顺序一定是一致的（否则应用根本无法正常工作）。也就是说指令重排是有一个基本前提的，就是保证串行语义的一致性。指令重排不会使串行的语义逻辑发生问题。因此，在串行代码中，大可不必担心。</p><p>注意：指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</p><p>那么，好奇的你可能马上就会在脑海里闪出一个疑问，为什么要指令重排呢？一步一步执行多好呀！也不会有那么多奇葩的问题。</p><p>之所以那么做，完全是出于性能考虑。我们知道，一条指令的执行是可以分为很多步的。简单地说，可以分为以下几步。</p><ul><li>取指 IF。</li><li>译码和取寄存器操作数 ID。</li><li>执行或者有效地址计算 EX。</li><li>存储器访问 MEM。</li><li>写回 WB。</li></ul><p>我们的汇编指令也不是一步就可以执行完毕的，在 CPU 中实际工作时，它还是需要分为多个步骤依次执行的。当然，每个步骤所涉及的硬件也可能不同。比如，取指时会用到 PC 寄存器和存储器，译码时会用到指令寄存器组，执行时会使用 ALU，写回时需要寄存器组。</p><p>注意：ALU 指算术逻辑单元。它是 CPU 的执行单元，是 CPU 的核心组成部分，主要功能是进行二进制算术运算。</p><p>由于每一个步骤都可能使用不同的硬件完成，因此，聪明的工程师们就发明了流水线技术来执行指令。图1.16 显示了指令流水线的工作原理。</p><img src="/assets/图1-16.9488009c.jpeg" alt="图1-16" style="zoom:100%;"><p>图1.16 指令流水线的工作原理</p><p>可以看到，当第 2 条指令执行时，第 1 条指令其实并未执行完，确切地说第一条指令还没开始执行，只是刚刚完成了取值操作而已。这样的好处非常明显，假如这里每一个步骤都需要花费 1 毫秒，那么指令 2 等待指令 1 完全执行后，再执行，则需要等待 5 毫秒，而使用流水线后，指令 2 只需要等待 1 毫秒就可以执行了。如此大的性能提升，当然让人眼红。更何况，实际的商业 CPU 的流水线级别甚至可以达到 10 级以上，性能提升更加明显。</p><p>有了流水线，CPU 才能真正高效地执行，但是，别忘了一点，流水线总是害怕被中断的。流水线满载时，性能确实相当不错，但是一旦中断，所有的硬件设备都会进入一个停顿期，再次满载又需要几个周期，因此，性能损失会比较大。所以，我们必须要想办法尽量不让流水线中断！</p><p>那么答案就来了，之所以需要做指令重排，就是为了尽量少地中断流水线。当然了，指令重排只是减少中断的一种技术，实际上，在 CPU 的设计中，我们还会使用更多的软硬件技术来防止中断，不过对它们的讨论已经远远超出本书范围，有兴趣的读者可以查阅相关资料。</p><p>让我们来仔细看一个例子。图1.17 展示了 A = B + C 这个操作的执行过程。写在左边的指令就是汇编指令。LW 表示 load，其中 LW R1,B，表示把 B 的值加载到 R1 寄存器中。ADD 指令就是加法，把 R1、R2 的值相加，并存放到 R3 中。SW 表示 store，存储，就是将 R3 寄存器的值保存到变量 A 中。</p><img src="/assets/图1-17.be01bea7.jpeg" alt="图1-17" style="zoom:100%;"><p>图1.17 A = B + C 的执行过程</p><p>右边就是流水线的情况。注意，在 ADD 指令上，有一个大叉，表示一个中断。也就是说 ADD 在这里停顿了一下。为什么 ADD 会在这里停顿呢？原因很简单，R2 中的数据还没有准备好，所以，ADD 操作必须进行一次等待。由于 ADD 的延迟，导致其后所有的指令都要慢一拍。</p><p>理解了上面这个例子，我们就可以来看一个更加复杂的情况：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>a <span class="token operator">=</span> b <span class="token operator">+</span> c
d <span class="token operator">=</span> e <span class="token operator">-</span> f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的执行应该是这样的，如图1.18 所示。</p><img src="/assets/图1-18.d5c2ba06.jpeg" alt="图1-18" style="zoom:100%;"><p>图1.18 重排前指令执行过程</p><p>由于 ADD 和 SUB 都需要等待上一条指令的结果，因此，在这里插入了不少停顿。那么对于这段代码，是否有可能消除这些停顿呢？显然是可以的，如图1.19 所示，显示了减少这些停顿的方法。我们只需要将 LW Re, e 和 LW Rf, f 移动到前面执行即可。思想很简单，先加载 e 和 f 对程序是没有影响的。既然在 ADD 的时候一定要停顿一下，那么停顿的时间还不如去做点有意义的事情。</p><img src="/assets/图1-19.942eb297.jpeg" alt="图1-19" style="zoom:100%;"><p>图1.19 指令重排以消除停顿</p><p>重排后，最终的结果如图1.20 所示。可以看到，所有的停顿都已经消除，流水线已经可以十分顺畅地执行了。</p><img src="/assets/图1-20.6dc959f0.jpeg" alt="图1-20" style="zoom:100%;"><p>图1.20 重排后的指令</p><p>由此可见，指令重排对于提高 CPU 处理性能是十分必要的。虽然确实带来了乱序的问题，但是这点牺牲是完全值得的。</p><h3 id="_1-5-4-哪些指令不能重排-happen-before-规则" tabindex="-1"><a class="header-anchor" href="#_1-5-4-哪些指令不能重排-happen-before-规则" aria-hidden="true">#</a> 1.5.4 哪些指令不能重排：Happen-Before 规则</h3><p>在前文已经介绍了指令重排，虽然 Java 虚拟机和执行系统会对指令进行一定的重排，但是指令重排是有原则的，并非所有的指令都可以随便改变执行位置，以下罗列了一些基本原则，这些原则是指令重排不可违背的。</p><ul><li>程序顺序原则：一个线程内保证语义的串行性。</li><li>volatile 规则：volatile 变量的写先于读发生，这保证了 volatile 变量的可见性。</li><li>锁规则：解锁（unlock）必然发生在随后的加锁（lock）前。</li><li>传递性：A 先于 B，B 先于 C，那么 A 必然先于 C。</li><li>线程的 start()方法先于它的每一个动作。</li><li>线程的所有操作先于线程的终结（Thread.join()）。</li><li>线程的中断（interrupt()）先于被中断线程的代码。</li><li>对象的构造函数的执行、结束先于 finalize()方法。</li></ul><p>以程序顺序原则为例，重排后的指令绝对不能改变原有的串行语义，比如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于第 2 条语句依赖第一条语句的执行结果。如果贸然交换两条语句的执行顺序，那么程序的语义就会修改。因此这种情况是绝对不允许发生的，这也是指令重排的一条基本原则。</p><p>此外，锁规则强调，unlock 操作必然发生在后续的对同一个锁的 lock 之前。也就是说，如果对一个锁解锁后，再加锁，那么加锁的动作绝对不能重排到解锁的动作之前。很显然，如果这么做，则加锁行为是无法获得这把锁的。</p><p>其他几条原则也是类似的，这些原则都是为了保证指令重排不会破坏原有的语义结构。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/anansneaker/vuepress-theme-hope/edit/master/docs/reading-notes/实战Java高并发程序设计/第1章走入并行世界.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/7/28 下午9:05:06</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: cl55563@163.com">阿楠sneaker</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/reading-notes/%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AC%AC2%E7%AB%A0Java%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80.html" class="nav-link next" aria-label="第 2 章 Java 并行程序基础"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第 2 章 Java 并行程序基础<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2022 阿楠sneaker</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.0d56c066.js" defer></script>
  </body>
</html>
